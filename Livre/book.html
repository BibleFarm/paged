<!DOCTYPE html>
<html lang="fr" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Livre documentation Cityfab 2</title>
    <link rel="stylesheet" href="style.css" >
    <script src="https://unpkg.com/pagedjs/dist/paged.polyfill.js"></script>
    <script src="hypher/examples/jquery/jquery-1.7.1.min.js"></script>
    <script src="hypher/dist/jquery.hypher.js"></script>
    <script src="hyphenation-patterns/dist/browser/fr.js"></script>
    <script>
	class MyHandler extends Paged.Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageFragment, page) {
      jQuery(function ($) {
        $('p').hyphenate('fr');
        $('h1').hyphenate('fr');
        $('li').hyphenate('fr');
        $('.entree').hyphenate('fr');
      });
		}
	}
	  Paged.registerHandlers(MyHandler);
  </script>
  </head>
  <body>
    <div class="garde">Cityfab2.docs</div>


    <div class="part">
      <div id="sommaire">SOMMAIRE</div>
      <span style="margin-top: 0mm;"><a href="#ap"></a>Avant-propos</span>
      <span><a href="#pt01"></a>Modélisation 3D</span>
      <a href="#pj01" class="proj"><span><span class="underscore">__</span>Modéliser un cube dans Freecad</span></a>
      <a href="#pj02" class="proj"><span><span class="underscore">__</span>Utiliser les contraintes dans Freecad</span></a>
      <a href="#pj03" class="proj"><span><span class="underscore">__</span>Utiliser les opérations booléennes dans Freecad</span></a>
      <a href="#pj04" class="proj"><span><span class="underscore">__</span>Modéliser un solide sur un autre dans Freecad</span></a>
      <a href="#pj05" class="proj"><span><span class="underscore">__</span>Arrondis et chamfreins dans Freecad</span></a>
      <a href="#pj06" class="proj"><span><span class="underscore">__</span>Faire des trous et des creux dans un solide avec Freecad</span></a>
      <a href="#pj07" class="proj"><span><span class="underscore">__</span>Utiliser les motifs <br/>de répétition de Freecad</span></a>
      <span style="text-indent:-5mm;"><a href="#pt02"></a>Impression 3D</span>
      <a href="#pj08" class="proj"><span><span class="underscore">__</span>Préparer l'impression 3D dans Cura</span></a>
      <a href="#pj09" class="proj"><span><span class="underscore">__</span>Préparer l'impression 3D dans Repetier Host</span></a>
      <br/><br/><br/><br/>
      <span style="text-indent:-5mm;"><a href="#pt03"></a>Découpe laser</span>
      <a href="#pj11" class="proj"><span><span class="underscore">__</span>Préparer un fichier <br/>à découper ou à graver <br/>avec Inkscape</span></a>
      <a href="#pj55" class="proj"><span><span class="underscore">__</span>Vectoriser une image <br/>à graver</span></a>
      <a href="#pj10" class="proj"><span><span class="underscore">__</span>Exporter un fichier DXF depuis Freecad</span></a>

      <span style="text-indent:-7mm;"><a href="#pt04"></a>CNC</span>
      <a href="#pj12" class="proj"><span><span class="underscore">__</span>Exporter un fichier GCODE depuis Freecad</span></a>
      <a href="#pj13" class="proj"><span><span class="underscore">__</span>Exporter un fichier GCODE depuis Inkscape</span></a>
      <a href="#pj14" class="proj"><span><span class="underscore">__</span>Gérer l'usinage d'un fichier GCODE dans Mach3</span></a>
      <span style="text-indent:-7mm;"><a href="#pt05"></a>Arduino</span>
      <a href="#pj15" class="proj"><span><span class="underscore">__</span>Montage électronique en série</span></a>
      <a href="#pj16" class="proj"><span><span class="underscore">__</span>Montage électronique en parallèle</span></a>
      <a href="#pj17" class="proj"><span><span class="underscore">__</span>LED + 2 boutons</span></a>
      <a href="#pj18" class="proj"><span><span class="underscore">__</span>Potentiomètre + 4 LED</span></a>
      <a href="#pj21" class="proj"><span><span class="underscore">__</span>Clavier sonore</span></a>
      <a href="#pj22" class="proj"><span><span class="underscore">__</span>Potentiomètre <br/>+ servo moteur</span></a>
      <a href="#pj24" class="proj"><span><span class="underscore">__</span>Pont en H</span></a>

    </div>
    <br/><br/><br/><br/><br/>
    <div class="part" style="margin-left:-5mm;">


      <a href="#pj26" class="proj"><span><span class="underscore">__</span>Mini station météo</span></a>

      <a href="#pj28" class="proj"><span><span class="underscore">__</span>Shield moteur <br/>+ photorésistance</span></a>
      <a href="#pj29" class="proj"><span><span class="underscore">__</span>Shields moteur imbriqués</span></a>
      <a href="#pj30" class="proj"><span><span class="underscore">__</span>Datalogging shield</span></a>
      <a href="#pj31" class="proj"><span><span class="underscore">__</span>Arduino + Processing&nbsp;: transmission par le port série</span></a>
      <a href="#pj32" class="proj"><span><span class="underscore">__</span>Message OSC</span></a>
      <a href="#pj33" class="proj"><span><span class="underscore">__</span>Firmata</span></a>
      <a href="#pj34" class="proj"><span><span class="underscore">__</span>Contrôler un servo <br/>et une LED depuis une <br/>page web</span></a>
      <a href="#pj35" class="proj"><span><span class="underscore">__</span>Serveur web météo</span></a>
      <a href="#pj37" class="proj"><span><span class="underscore">__</span>Adafruit Flora <br/>+ NeoPixels</span></a>
      <a href="#pj38" class="proj"><span><span class="underscore">__</span>Adafruit Flora <br/>+ module GPS</span></a>
      <span style="text-indent:-7mm;"><a href="#pt06"></a>Raspberry Pi</span>
      <a href="#pj39" class="proj"><span><span class="underscore">__</span>Installer Raspberry <br/>Pi OS (Raspbian)</span></a>

      <a href="#pj41" class="proj"><span><span class="underscore">__</span>Configurer la connexion à distance</span></a>
      <a href="#pj40" class="proj"><span><span class="underscore">__</span>Premier démarrage <br/>du Raspberry Pi</span></a>
      <a href="#pj42" class="proj"><span><span class="underscore">__</span>Configurer le partage <br/>de dossiers (Samba)</span></a>

      <a href="#pj43" class="proj"><span><span class="underscore">__</span>Lancer une vidéo <br/>à distance</span></a>
      <a href="#pj44" class="proj"><span><span class="underscore">__</span>Créer un point d'accès wifi</span></a>
      <a href="#pj45" class="proj"><span><span class="underscore">__</span>Faire clignoter <br/>une LED en Python</span></a>
      <a href="#pj47" class="proj"><span><span class="underscore">__</span>Contrôler un servo moteur en Python</span></a>
      <a href="#pj48" class="proj"><span><span class="underscore">__</span>Contrôler un moteur <br/>à courant continu</span></a>
      <a href="#pj49" class="proj"><span><span class="underscore">__</span>Page web de contrôle de composants</span></a>
      <a href="#pj50" class="proj"><span><span class="underscore">__</span>Tweeter en ligne <br/>de commande</span></a>
      <a href="#pj51" class="proj"><span><span class="underscore">__</span>Bot Twitter + LED</span></a>
      <a href="#pj52" class="proj"><span><span class="underscore">__</span>Bot Twitter&nbsp;: retweet <br/>et favori automatique</span></a>
      <a href="#pj53" class="proj"><span><span class="underscore">__</span>Application bot Twitter web-to-print</span></a>
      <a href="#pj54" class="proj"><span><span class="underscore">__</span>Application bot Twitter web-to-print n°2</span></a>
      <span style="text-indent:-7mm;"><a href="#gloss"></a>Glossaire</span>
      <span style="text-indent:-7mm;margin-top:2mm;"><a href="#liens"></a>Liens utiles</span>
      <span style="text-indent:-7mm;margin-top:2mm;"><a href="#col"></a>Colophon</span>

    </div>

    <div class="page_blanche">

    </div>
    <h1 id="ap" style="text-indent:0mm;"><span class="cityfab">Cityfab2.docs</span> est un recueil des ateliers et projets proposés au fablab Cityfab2 à Bruxelles entre décembre 2019 et mai 2020.
    </h1><h1>La documentation de ces projets était mise à disposition des membres du fablab sur une plateforme web hébergée localement sur l'un des Raspberry Pi de l'atelier. Cette plateforme était web-to-print&nbsp;: elle permettait de générer des PDF des projets directement depuis leurs pages web, afin que les membres ou les participants ponctuels aux ateliers, s'ils le souhaitaient, puissent garder une documentation des projets qui les intéressaient. Dans un souci de cohérence avec cette première version de la documentation, ce recueil a également été mis en page en web-to-print avec l'outil Paged.js.
    </h1><h1>Les projets compilés dans ce livre utilisent résolument des outils libres et open source que toute personne peut installer et utiliser sur sa propre machine. Ces projets vont d'un niveau débutant à des concepts complexes, ils sont à considérer comme autant de points de départ servant à s'approprier les outils présentés en vue de s'en servir à nouveau dans de futurs projets.</span></h1>

<!-- PARTIE 1 -->
  <div class="partie_gauche">

  </div>
  <div class="partie_droite">
    <h2 id="pt01">Modélisation 3D</h2>
  </div>


    <div class="page_blanche">

    </div>

      <div class="projet" id="pj01">
        <div class="bloc1">
          <h3>Modéliser <br/>un cube <br/>avec Freecad</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/freecad_logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro">Freecad est un logiciel de modélisation 3D paramétrique avec lequel on peut concevoir des modèles destinés à l'impression 3D ou à un usinage sur une machine CNC.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/fc01_titre.png'); background-position: 50% 65%;"></div>

      </div>

      <h4>Marche à suivre</h4>

      <p>Pour modéliser un objet en 3D, il faut utiliser l'atelier <span class="code">Part design</span> <img class="icone" src="images/Workbench_PartDesign.svg" alt=""> de Freecad. <br/>Les ateliers sont les différents espaces de travail de Freecad&nbsp;; l'ensemble de ceux-ci se trouve dans un menu déroulant de la barre d'outils du haut de la fenêtre. Pour la modélisation 3D, <span class="code">Part design</span> <img class="icone" src="images/Workbench_PartDesign.svg" alt=""> sera l'atelier auquel on fera le plus souvent appel.</p>


      <p class="p_img_bas">Une fois dans l'atelier <span class="code">Part design</span> <img class="icone" src="images/Workbench_PartDesign.svg" alt="">, cliquez sur l'icône <span class="code">Sketcher</span> <img class="icone" src="images/Sketcher_NewSketch.svg" alt=""> pour démarrer une esquisse (en réalité ceci vous envoie dans l'atelier <span class="code">Sketcher</span> <img class="icone" src="images/Workbench_Sketcher.svg" alt="">, mais vous reviendrez automatiquement dans l'atelier <span class="code">Part design</span> <img class="icone" src="images/Workbench_PartDesign.svg" alt=""> une fois l'esquisse terminée). Il vous sera alors demandé de choisir le plan sur lequel vous voulez placer votre esquisse.</p>
      <figure class="encart">
        <img class="tuto" src="images/fc01.png" alt="">
        <div class="numero"></div><figcaption>Créer un nouveau «&nbsp;Sketch&nbsp;» <br/>dans Freecad</figcaption>
      </figure>
      <figure class="encart">
        <img class="tuto" src="images/fc02.png" alt="">
        <div class="numero"></div><figcaption>Choisir le plan dans lequel <br/>va se trouver l'esquisse</figcaption>
      </figure>

      <p>Pour dessiner un carré dans votre esquisse, sélectionnez l'outil <span class="code">Rectangle</span> <img class="icone" src="images/Sketcher_CreateRectangle.svg" alt=""> dans la barre supérieure des outils de dessin. Cliquez une première fois sur le plan et tirez les poignées pour obtenir une forme de carré. Si l'on voulait, à la place d'un cube, obtenir un pavé, il suffirait de dessiner un rectangle dont la longueur et la largeur ne se valent pas. Pour obtenir un cylindre il faudrait esquisser un cercle avec l'outil <span class="code">Circle</span> <img class="icone" src="images/48px-Sketcher_CompCreateCircle.png" alt="">.</p>


      <p class="p_img_bas">Afin de s'assurer que le carré aura des proportions parfaites, on utilise les contraintes que propose Freecad. Avec les contraintes <span class="code">Set horizontal length</span> <img class="icone" src="images/Constraint_HorizontalDistance.svg" alt=""> et <span class="code">Set vertical length</span> <img class="icone" src="images/Constraint_VerticalDistance.svg" alt=""> on peut définir précisément la longueur des côtés.</p>
      <figure class="encart">
        <img class="tuto" src="images/fc03.png" alt="">
        <div class="numero"></div><figcaption>Dessiner un carré avec <br/>l'outil «&nbsp;Rectangle&nbsp;»</figcaption>
      </figure>
      <figure class="encart">
        <img class="tuto" src="images/fc05.png" alt="">
        <div class="numero"></div><figcaption>Contraintes de largeur horizontale et verticale</figcaption>
      </figure>



      <p>Une fois que le carré fait la bonne dimension, fermez l'esquisse en cliquant sur le bouton <span class="code">Close</span> dans l'onglet <span class="code">Tasks</span> de la barre d'outils latérale. Si vous revenez à l'onglet <span class="code">Model</span>, vous pouvez voir dans l'arborescence de votre projet un objet de type <span class="code">Body</span> qui contient l'esquisse que vous venez de créer.</p>


      <p class="p_img_bas">Pour mettre en volume l'esquisse en 2D, cliquez sur l'outil <span class="code">Create Pad</span> <img class="icone" src="images/PartDesign_Pad.svg" alt=""> qui va procéder à l'extrusion de la forme. Vous pouvez y déterminer de combien de millimètres vous souhaitez que votre objet soit extrudé.</p>
      <figure>
        <img class="tuto" src="images/fc07.png" alt="">
        <div class="numero"></div><figcaption>L'esquisse est devenue <br/>un «&nbsp;Body&nbsp;»</figcaption>
      </figure>
      <figure>
        <img class="tuto" src="images/fc08.png" alt="">
        <div class="numero"></div><figcaption>Outil «&nbsp;Create Pad&nbsp;» (extrusion)</figcaption>
      </figure>

      <p>Quand vous terminez l'extrusion, vous pouvez visualiser votre objet en 3D, et noter que l'esquisse est devenue un <span class="code">Pad</span> dans l'arborescence du projet.</p>

      <p class="p_img_bas">Pour exporter l'objet 3D, sélectionnez l'objet <span class="code">Pad</span> et cliquez sur <span class="code">File</span> > <span class="code">Export</span>, ce qui ouvrira une boîte de dialogue où vous pouvez choisir à quel format exporter l'objet. Pour une impression 3D il faut exporter au format STL ou OBJ.</p>
      <figure>
        <img class="tuto" src="images/fc09.png" alt="">
        <div class="numero"></div><figcaption>Cube extrudé</figcaption>
      </figure>

      <figure>
        <img class="tuto" src="images/fc10.png" alt="">
        <div class="numero"></div><figcaption>Exporter l'objet 3D <br/>au format STL</figcaption>
      </figure>

      <div class="page_blanche">

      </div>

      <div class="projet" id="pj02">
        <div class="bloc1">
          <h3>Utiliser les <br/>contraintes <br/>dans Freecad</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>
        <div class="logo">
          <img src="images/freecad_logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro" style="width: 81mm;">Les contraintes sont une composante essentielle de Freecad puisqu'elles permettent de rendre l'objet créé paramétrique. On s'en sert par exemple pour déterminer la longueur de côté d'un objet, le rayon d'un cercle, si l'on veut que deux segments soient perpendiculaires, etc. Le grand avantage de les utiliser est que l'on peut changer les paramètres plus tard, et notre objet s'adapte automatiquement à ses nouvelles cotes.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/fc02_titre.png'); background-position: 50% 65%;width:25mm;"></div>

      </div>

      <h4>Marche à suivre</h4>

      <p>Les contraintes se trouvent à droite de la barre d'outil supérieure de la fenêtre de Freecad quand on se trouve dans l'atelier <span class="code">Sketcher</span> <img class="icone" src="images/Workbench_Sketcher.svg" alt=""> . Attention à ne pas les confondre avec les outils de dessin, qui se trouvent également dans cette barre d'outil et sont eux aussi de couleur rouge.</p>



      <p class="p_img_bas">On peut contraindre un cercle à avoir un rayon donné avec la contrainte <span class="code">Radius</span> <img class="icone" src="images/Constraint_Radius.svg" alt="">, où l'on rentre dans une boîte de dialogue le rayon souhaité. <br/>Dans la dernière version de Freecad, on peut choisir si l'on veut contraindre le rayon ou le diamètre d'un cercle.</p>



      <figure>
        <img class="tuto" src="images/fc11.png" alt="">
        <div class="numero"></div><figcaption>Outils de contrainte <br/>dans le menu</figcaption>
      </figure>

      <figure>
        <img class="tuto" src="images/fc12.png" alt="">
        <div class="numero"></div><figcaption>Contraindre le rayon <br/>d'un cercle</figcaption>
      </figure>



      <p>Une autre contrainte intéressante est de faire concorder deux points, autrement dit de faire en sorte que deux points différents deviennent le même point. Cette contrainte est <span class="code">Point on point</span> <img class="icone" src="images/Constraint_PointOnPoint.svg" alt="">. Sélectionnez les deux points à faire concorder puis cliquez sur la contrainte.</p>
      <p class="p_img_bas">Dans le cas de polygones, on peut utiliser les contraintes <span class="code">Set horizontal</span> <img class="icone" src="images/Constraint_Horizontal.svg" alt=""> et <span class="code">Set vertical</span> <img class="icone" src="images/Constraint_Vertical.svg" alt=""> pour forcer des côtés à être alignés sur l'axe des abscisses ou sur celui des ordonnées.</p>

      <figure>
        <img class="tuto" src="images/fc13.png" alt="">
        <div class="numero"></div><figcaption>Fusionner deux points</figcaption>
      </figure>
      <figure>
        <img class="tuto" src="images/fc14.png" alt="">
        <div class="numero"></div><figcaption>Contrainte d'horizontalité <br/>et de verticalité</figcaption>
      </figure>

      <p>Pour faire en sorte que deux segments soient rigoureusement parallèles, il y a la contrainte <span class="code">Parallel</span> <img class="icone" src="images/Constraint_Parallel.svg" alt="">, qui s'utilise en sélectionnant les deux segments à aligner puis en cliquant sur la contrainte.</p>

      <p class="p_img_bas">Pour paramétrer la longueur d'un segment, on utilise les contraintes <span class="code">Set horizontal length</span> <img class="icone" src="images/Constraint_HorizontalDistance.svg" alt=""> ou <span class="code">Set vertical length</span> <img class="icone" src="images/Constraint_VerticalDistance.svg" alt=""> en fonction de l'orientation du segment.</p>

      <figure>
        <img class="tuto" src="images/fc15.png" alt="">
        <div class="numero"></div><figcaption>Contrainte de parallélisme <br/>entre deux lignes</figcaption>
      </figure>

      <figure>
        <img class="tuto" src="images/fc16.png" alt="">
        <div class="numero"></div><figcaption>Déterminer la longueur <br/>d'un segment</figcaption>
      </figure>

      <p>Si l'on souhaite que deux segments se croisent selon un angle manuellement déterminé, on utilise la contrainte <span class="code">Set angle between two lines</span>&nbsp;<img class="icone" src="images/Constraint_InternalAngle.svg" alt=""> qui nous permet de définir paramétriquement cet angle. <br/><br/>Prenez le temps d'essayer toutes les contraintes, celles-ci permettent de faire appel à des règles géométriques scrupuleuses dans vos esquisses et restent modifiables à tout moment si vous souhaitez adapter votre objet plus tard.</p>


      <figure>
        <img class="tuto" src="images/fc17.png" alt="">
        <div class="numero"></div><figcaption>Définir un angle entre <br/>deux lignes</figcaption>
      </figure>


      <div class="page_blanche">

      </div>

      <div class="projet" id="pj03">
        <div class="bloc1">
          <h3>Utiliser les <br/>opérations <br/>booléennes <br/>dans Freecad</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>
        <div class="logo">
          <img src="images/freecad_logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro">Freecad permet d'appliquer des opérations booléennes à différents objets 3D afin de les assembler, de ne garder que leur intersection, leur différence, ou encore de les fusionner.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/fc03_titre.png'); background-position: 60% 65%;"></div>

      </div>


      <h4>Marche à suivre</h4>
      <p>On peut utiliser les opérations booléennes dans l'atelier <span class="code">Part</span> <img class="icone" src="images/Workbench_Part.svg" alt=""> de Freecad. Celles-ci se trouvent dans la barre d'outils supérieure de la fenêtre, elles sont représentées par deux sphères superposées.</p>

      <p class="p_img_bas">Si vous avez créé un objet 3D dans l'atelier <span class="code">Part design</span> <img class="icone" src="images/Workbench_PartDesign.svg" alt="">, il se retrouvera dans l'atelier <span class="code">Part</span> <img class="icone" src="images/Workbench_Part.svg" alt="">. Sinon, on peut créer directement des solides réguliers tels que des sphères, des cylindres, des cubes ou encore des cônes. en cliquant sur leurs icônes&nbsp;: <br/><img class="icone" src="images/Part_Box.svg" alt="">, <img class="icone" src="images/Part_Cone.svg" alt="">,<img class="icone" src="images/Part_Cylinder.svg" alt="">, <img class="icone" src="images/Part_Sphere.svg" alt="">, <img class="icone" src="images/Part_Torus.svg" alt="">.</p>

      <figure>
        <img class="tuto" src="images/fc18.png" alt="">
        <div class="numero"></div><figcaption>Atelier «&nbsp;Part&nbsp;»</figcaption>
      </figure>

      <figure>
        <img class="tuto" src="images/fc19.png" alt="">
        <div class="numero"></div><figcaption>Solides générés <br/>dans l'atelier «&nbsp;Part&nbsp;»</figcaption>
      </figure>

      <p>Par défaut les objets 3D se retrouvent au milieu du repère. Pour déplacer l'un d'entre eux, il faut le sélectionner dans l'arborescence du projet, déplier la propriété <span class="code">Placement</span> dans le menu de gauche, sélectionner la sous-propriété <span class="code">Position</span>, et faire varier les valeurs <span class="code">x</span>, <span class="code">y</span> et <span class="code">z</span> pour le déplacer selon les différents axes du repère.</p>
      <p class="p_img_bas">Pour réaliser une opération booléenne entre deux objets, il faut cliquer sur l'icône <span class="code">Create boolean operation</span> <img class="icone" src="images/PartDesign_Boolean.svg" alt="">. Une boîte de dialogue s'ouvre alors dans le menu de gauche. L'ordre dans lequel vous sélectionnez les objets compte dans le résultat de l'opération booléenne&nbsp;: vous devez déterminer quelle est la première forme à traiter, puis la seconde en cochant les checkboxes dans <span class="code">First shape</span> et <span class="code">Second shape</span>. Il faut également sélectionner le type d'opération booléenne à réaliser entre <span class="code">Union</span> <img class="icone" src="images/Part_Fuse.svg" alt="">, <span class="code">Difference</span> <img class="icone" src="images/Part_Cut.svg" alt=""> et <span class="code">Intersection</span> <img class="icone" src="images/Part_Common.svg" alt="">.</p>

      <figure>
        <img class="tuto" src="images/fc20.png" alt="">
        <div class="numero"></div><figcaption>Modifier le placement <br/>d'un objet</figcaption>
      </figure>

      <figure>
        <img class="tuto" src="images/fc21.png" alt="">
        <div class="numero"></div><figcaption>Menu des opérations booléennes</figcaption>
      </figure>


      <p>Une fois l'opération faite, vous pouvez voir dans l'arborescence du projet que les deux objets 3D sont devenus un même objet portant le nom de l'opération booléenne réalisée dessus.</p>
      <p class="p_img_bas">Les opérations booléennes sont particulièrement utiles pour obtenir des croisements entre deux objets 3D qu'on ne pourrait pas avoir autrement. Par exemple si on place une sphère à l'intérieur d'un cube, on peut obtenir différents résultats selon l'opération booléenne effectuée et l'ordre des objets.</p>

      <figure>
        <img class="tuto" src="images/fc22.png" alt="">
        <div class="numero"></div><figcaption>Solide fusionné</figcaption>
      </figure>

      <figure class="encart">
        <img class="tuto" src="images/fc23.png" alt="">
        <div class="numero"></div><figcaption>Entrelacer deux solides <br/>dans l'atelier «&nbsp;Part&nbsp;»</figcaption>
      </figure>


      <p>La <span class="code">Difference</span> <img class="icone" src="images/Part_Cut.svg" alt=""> exclut de la première forme les parties communes aux deux objets.</p>
      <p class="p_img_bas">Si on inverse l'ordre de sélection des solides, la <span class="code">Difference</span> <img class="icone" src="images/Part_Cut.svg" alt=""> donne un tout autre résultat.</p>


      <figure class="encart">
        <img class="tuto" src="images/fc25.png" alt="">
        <div class="numero"></div><figcaption>«&nbsp;Difference&nbsp;» avec la sphère comme première forme</figcaption>
      </figure>
      <figure class="encart">
        <img class="tuto" src="images/fc34.png" alt="">
        <div class="numero"></div><figcaption>«&nbsp;Difference&nbsp;» avec le cube <br/>comme première forme</figcaption>
      </figure>



      <div class="page_blanche">

      </div>

      <div class="projet" id="pj04">
        <div class="bloc1">
          <h3>Modéliser <br/>un solide <br/>sur un autre <br/>dans Freecad</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>
        <div class="logo">
          <img src="images/freecad_logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro">Freecad est un logiciel très complet permettant de modéliser des objets complexes. Nous allons voir comment ajouter une forme 3D sur une face d'un solide préalablement modélisé.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/fc04_titre.png'); background-position: 70% 65%;"></div>

      </div>
      <h4>Marche à suivre</h4>
      <p>On part d'un pavé modélisé et extrudé dans l'atelier <span class="code">Part design</span> <img class="icone" src="images/Workbench_PartDesign.svg" alt="">. Pour plus d'informations sur la modélisation d'un tel objet, voir le projet «&nbsp;Modéliser un cube dans Freecad&nbsp;» (p. <a class="crossref" href="#pj01"></a>).</p>
      <p class="p_img_bas">Si l'on veut créer une nouvelle forme sur l'une des faces du pavé, il faut sélectionner la face en question, puis cliquer sur <span class="code">Create new sketch</span> <img class="icone" src="images/Sketcher_NewSketch.svg" alt="">.</span></p>


      <figure class="encart">
        <img class="tuto" src="images/fc27.png" alt="">
        <div class="numero"></div><figcaption>Solide de base</figcaption>
      </figure>
      <figure class="encart">
        <img class="tuto" src="images/fc35.png" alt="">
        <div class="numero"></div><figcaption>Sélectionner la face <br/>de la nouvelle esquisse</figcaption>
      </figure>


      <p>On se retrouve alors à nouveau dans l'atelier <span class="code">Sketcher</span> <img class="icone" src="images/Workbench_Sketcher.svg" alt="">, mais avec la face du solide préalablement sélectionnée comme arrière-plan. On peut alors y dessiner la ou les formes souhaitées et utiliser toutes les propriétés de l'atelier <span class="code">Sketcher</span> <img class="icone" src="images/Workbench_Sketcher.svg" alt=""> telles que les contraintes (voir le projet «&nbsp;Utiliser les contraintes dans Freecad&nbsp;» p. <a class="crossref" href="#pj02"></a>).</p>
      <p class="p_img_bas">Une fois la nouvelle esquisse terminée, <br/>on peut l'extruder et ainsi obtenir des solides placés sur le solide de base. Il est possible de dessiner de nouvelles esquisses sur n'importe quelle face d'un objet 3D et ainsi d'obtenir un objet complexe.</p>


      <figure class="encart">
        <img class="tuto" src="images/fc36.png" alt="">
        <div class="numero"></div><figcaption>Dessiner la deuxième esquisse</figcaption>
      </figure>
      <figure class="encart">
        <img class="tuto" src="images/fc37.png" alt="">
        <div class="numero"></div><figcaption>Extruder le deuxième objet 3D</figcaption>
      </figure>


      <div class="page_blanche">

      </div>

      <div class="projet" id="pj05">
        <div class="bloc1">
          <h3>Arrondis et <br/>chamfreins <br/>dans Freecad</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>
        <div class="logo">
          <img src="images/freecad_logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro">Arrondis et chamfreins permettent d'adoucir ou de créer des profils particuliers dans les angles d'objets modélisés en 3D. C'est particulièrement utile dans le cas d'objets à découper avec une CNC, afin de rendre l'objet fabriqué plus ergonomique.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/fc06_titre.png'); background-position: 50% 55%;"></div>

      </div>
      <h4>Marche à suivre</h4>
      <p>Pour appliquer un arrondi («&nbsp;fillet&nbsp;» en anglais) sur une arête ou une face du solide, il faut, en se trouvant dans l'atelier <span class="code">Part Design</span> <img class="icone" src="images/Workbench_PartDesign.svg" alt="">, la sélectionner en cliquant dessus.</p>
      <p class="p_img_bas">Puis il faut sélectionner l'outil <span class="code">Create fillet</span> <img class="icone" src="images/PartDesign_Fillet.svg" alt="">. Une boîte de dialogue s'ouvre dans le menu de gauche, vous y déterminez le rayon de l'arrondi.</p>

      <figure class="encart">
        <img class="tuto" src="images/fc40.png" alt="">
        <div class="numero"></div><figcaption>Sélectionner l'arête à arrondir</figcaption>
      </figure>
      <figure class="encart">
        <img class="tuto" src="images/fc41.png" alt="">
        <div class="numero"></div><figcaption>Paramètres de l'arrondi</figcaption>
      </figure>

      <p>Pour appliquer un chamfrein sur une autre arête, cliquez dessus pour la sélectionner.</p>
      <p class="p_img_bas">Sélectionnez l'outil <span class="code">Create chamfer</span> <img class="icone" src="images/PartDesign_Chamfer.svg" alt="">. <br/>De la même façon que pour faire un arrondi, la boîte de dialogue dans le menu vous permet de choisir la longueur du chamfrein.</p>


      <figure class="encart">
        <img class="tuto" src="images/fc42.png" alt="">
        <div class="numero"></div><figcaption>Sélectionner l'arête <br/>à chamfreiner</figcaption>
      </figure>
      <figure class="encart">
        <img class="tuto" src="images/fc43.png" alt="">
        <div class="numero"></div><figcaption>Paramètres du chamfrein</figcaption>
      </figure>


      <div class="page_blanche">

      </div>

      <div class="projet" id="pj06">
        <div class="bloc1">
          <h3>Faire des <br/>trous et des <br/>creux dans <br/>un solide <br/>avec Freecad</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>
        <div class="logo">
          <img src="images/freecad_logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro">Si l'on veut doter de poches ou de trous un modèle, il est possible de retirer de la matière à des objets 3D grâce à des outils intégrés de Freecad.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/fc07_titre.png'); background-position: 65% 70%;"></div>

      </div>
      <h4>Marche à suivre</h4>
      <p>À partir d'un solide modélisé au préalable (voir le projet «&nbsp;Modéliser un cube dans Freecad&nbsp;» p. <a class="crossref" href="#pj01"></a> pour cette partie), crééz un nouveau <span class="code">Sketch</span> <img class="icone" src="images/Sketcher_NewSketch.svg" alt=""> sur la face à laquelle vous voulez retirer de la matière et dessinez-y la forme désirée. Une fois l'esquisse terminée, cliquez sur l'outil <span class="code">Create a pocket</span> <img class="icone" src="images/PartDesign_Pocket.svg" alt=""> de <span class="code">Part design</span> <img class="icone" src="images/Workbench_PartDesign.svg" alt="">.</p>
      <p class="p_img_bas">Une boîte de dialogue dans le menu de gauche vous permet de déterminer la profondeur du creux dans la face du solide de base.</p>
      <figure>
        <img class="tuto" src="images/fc44.png" alt="">
        <div class="numero"></div><figcaption>Faire l'esquisse du creux <br/>sur la face voulue</figcaption>
      </figure>
      <figure>
        <img class="tuto" src="images/fc45.png" alt="">
        <div class="numero"></div><figcaption>Régler la profondeur du creux</figcaption>
      </figure>


      <p>Pour créer un trou dans la matière, <br/>le procédé est similaire. Faîtes une nouvelle esquisse sur la face à creuser.</p>
      <p class="p_img_bas">Quand l'esquisse est terminée, cliquez sur <span class="code">Create a hole</span> <img class="icone" src="images/PartDesign_Hole.svg" alt=""> dans <span class="code">Part design</span> <img class="icone" src="images/Workbench_PartDesign.svg" alt="">. Vous pouvez choisir dans la boîte de dialogue le diamètre du trou ainsi que sa profondeur.</p>

      <figure>
        <img class="tuto" src="images/fc47.png" alt="">
        <div class="numero"></div><figcaption>Esquisser le trou sur la face<br/>du solide de base</figcaption>
      </figure>

      <figure>
        <img class="tuto" src="images/fc48.png" alt="">
        <div class="numero"></div><figcaption>Régler les paramètres du trou</figcaption>
      </figure>

      <div class="page_blanche">

      </div>

      <div class="projet" id="pj07">
        <div class="bloc1">
          <h3>Utiliser les <br/>motifs de <br/>répétition <br/>de Freecad</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>
        <div class="logo">
          <img src="images/freecad_logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro">Si l'on veut répéter un motif de manière régulière dans une modélisation 3D, Freecad dispose d'outils pour gérer la disposition du motif.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/fc57_titre.png'); background-position: 67% 44%;"></div>

      </div>
      <h4>Marche à suivre</h4>
      <p>On part d'un solide de base modélisé dans l'atelier <span class="code">Part design</span> <img class="icone" src="images/Workbench_PartDesign.svg" alt=""> (voir le projet «&nbsp;Modéliser un cube dans Freecad&nbsp;», p. <a class="crossref" href="#pj01"></a>), sur lequel on a créé un nouveau <span class="code">Sketch</span> <img class="icone" src="images/Sketcher_NewSketch.svg" alt=""> puis extrudé la forme dessinée sur la face du solide de base (voir le projet «&nbsp;Modéliser un solide sur un autre dans Freecad&nbsp;» p.<a class="crossref" href="#pj04"></a> à ce propos).</p>
      <p class="p_img_bas">Pour appliquer un motif de répétition, il faut tout d'abord sélectionner le solide à répéter.</p>

      <figure>
        <img class="tuto" src="images/fc53.png" alt="">
        <div class="numero"></div><figcaption>Solide de base avec <br/>un objet extrudé dessus</figcaption>
      </figure>
      <figure>
        <img class="tuto" src="images/fc54.png" alt="">
        <div class="numero"></div><figcaption>Sélectionner le solide à répéter selon un motif</figcaption>
      </figure>

      <p>Pour obtenir une répétition de motif linéaire il faut cliquer sur l'outil <span class="code">Create linear pattern</span> <img class="icone" src="images/PartDesign_LinearPattern.svg" alt="">. Dans la boîte de dialogue on peut régler la longueur sur laquelle se produit la répétition ainsi que le nombre d'occurrences. La transformation ne pourra pas se faire tant qu'au moins une occurrence de la répétition dépasse du solide de base.</p>
      <p class="p_img_bas">Si l'on veut appliquer un motif de répétition circulaire, il faut sélectionner le solide à répéter puis cliquer sur l'outil <span class="code">Create circular pattern</span> <img class="icone" src="images/PartDesign_PolarPattern.svg" alt="">. De la même façon que pour la répétition linéaire, la boîte de dialogue permet de régler l'angle selon lequel se produit la répétition ainsi que le nombre d'occurrences.</p>


      <figure>
        <img class="tuto" src="images/fc55.png" alt="">
        <div class="numero"></div><figcaption>Paramétrer la répétition <br/>du motif</figcaption>
      </figure>
      <figure>
        <img class="tuto" src="images/fc56.png" alt="">
        <div class="numero"></div><figcaption>Motif de répétition circulaire</figcaption>
      </figure>

      <p>On peut également choisir l'axe selon lequel va se produire la répétition du motif. <br/>Le choix de cet axe change tout à fait la disposition du motif.</p>
      <p class="p_img_bas">Pour obtenir des motifs complexes il faut combiner les répétitions. Pour cela on fait appel à l'outil <span class="code">Create multitransform pattern</span> <img class="icone" src="images/PartDesign_MultiTransform.svg" alt="">. On trouve dans la boîte de dialogue les mêmes paramètres que pour les répétitions linéaires et circulaires simples, à la différence notable que lors d'une multi-transformation, vous n'obtiendrez pas le même résultat en fonction de l'ordre des transformations.</p>


      <figure>
        <img class="tuto" src="images/fc57.png" alt="">
        <div class="numero"></div><figcaption>Même répétition circulaire <br/>mais selon un autre axe</figcaption>
      </figure>

      <figure>
        <img class="tuto" src="images/fc58.png" alt="">
        <div class="numero"></div><figcaption>Multi-transformation</figcaption>
      </figure>


      <div class="partie_gauche">

      </div>
      <div class="partie_droite">
        <h2 id="pt02">Impression 3D</h2>
      </div>



      <div class="page_blanche">

      </div>

      <div class="projet" id="pj08">
        <div class="bloc1">
          <h3>Préparer <br/>l'impression <br/>3D dans Cura</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>
        <div class="logo">
          <img src="images/ultimaker-cura.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro">Cura est un slicer, un logiciel qui permet de décomposer un objet à imprimer en 3D en un certain nombre de couches superposées déterminé par différents paramètres.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/cura_titre.png'); background-position: 50% 85%;">

        </div>

      </div>

      <h4>Marche à suivre</h4>
      <p>La première chose à faire lorsqu'on ouvre Cura est de choisir l'imprimante 3D. Il existe des profils intégrés pour les imprimantes les plus répandues sur le marché, mais si votre machine ne se trouve pas dans la liste vous pouvez créer un profil personnalisé dans lequel vous rentrerez toutes ses fonctionnalités et détails techniques. Pour importer votre objet 3D, cliquez sur l'icône de dossier en haut à gauche. </p>

      <p class="p_img_bas">Si vous cliquez sur votre objet importé, vous verrez une barre d'outils apparaître à gauche de la fenêtre. Le premier outil permet de déplacer votre objet sur le plateau. <br/>Le second outil permet de redimensionner votre objet, proportionnellement ou non.<br/>Le troisième outil permet de le faire pivoter (cela est particulièrement utile si vous imprimez un objet complexe pour lequel vous avez besoin que les supports soient placés d'une certaine façon), etc.</p>

      <figure>
        <img class="tuto" src="images/cura01.png" alt="">
        <div class="numero"></div><figcaption>Choisir l'imprimante 3D</figcaption>
      </figure>

      <figure>
        <img class="tuto" src="images/cura02.png" alt="">
        <div class="numero"></div><figcaption>Déplacer, redimensionner, pivoter l'objet 3D</figcaption>
      </figure>

      <p>Si vous souhaitez imprimer votre objet en plusieurs exemplaires, faîtes un clic-droit dessus et sélectionnez <span class="code">Multiplier les objets sélectionnés</span>.</p>
      <p class="p_img_bas">Une fois votre ou vos objets placés à votre guise, cliquez au milieu de la barre d'outils supérieure pour sélectionner parmi la liste proposée le matériau dans lequel votre objet va être imprimé (il va de soi que le matériau sélectionné doit également être positionné dans l'extrudeur de la machine avant de lancer l'impression).</p>

      <figure>
        <img class="tuto" src="images/cura05.png" alt="">
        <div class="numero"></div><figcaption>Multiplier les objets</figcaption>
      </figure>

      <figure>
        <img class="tuto" src="images/cura06.png" alt="">
        <div class="numero"></div><figcaption>Choix du matériau d'impression</figcaption>
      </figure>

      <p>Ensuite, il est temps de passer aux paramètres d'impression 3D. La première chose à régler est l'épaisseur de couche de l'impression. Plus l'épaisseur est importante, plus l'impression sera rapide, mais la finition sera plus imprécise. Pour un résultat plus net mais plus long à imprimer, choisissez une faible épaisseur de couche.</p>

      <p class="p_img_bas">Le deuxième paramètre important est le remplissage de l'objet. Plus celui-ci est dense, plus le temps d'impression est long, mais cela solidifie la pièce. Il n'est cependant pas nécessaire de remplir complètement une pièce pour qu'elle soit solide. <br/>20% de remplissage est une bonne valeur. Vous pouvez choisir différents motifs de remplissage, chacun ayant ses propriétés, dans le menu déroulant.</p>

      <figure class="encart">
        <img class="tuto" src="images/cura07.png" alt="">
        <div class="numero"></div><figcaption>Épaisseur des couches d'impression</figcaption>
      </figure>

      <figure  class="encart">
        <img class="tuto" src="images/cura08.png" alt="">
        <div class="numero"></div><figcaption>Remplissage de l'impression</figcaption>
      </figure>

      <p>Il est important de vérifier les températures d'impression&nbsp;: celle de la buse ainsi que celle du lit d'impression. Cura vous propose automatiquement des valeurs pour chaque type de matériau, mais tous les filaments ne correspondent pas exactement à ces températures standard. Si votre fil a du mal à être extrudé, augmentez la température de la buse. Si votre objet se décolle du lit pendant l'impression, essayez d'augmenter la température du plateau.</p>

      <p class="p_img_bas">Autre paramètre important&nbsp;: activer les supports d'impression. L'imprimante va imprimer un surplus de matière autour de l'objet dans les premières couches afin de garantir le bon maintien de l'objet sur le lit au cours de l'impression, et de placer correctement des parties en hauteur de l'objet n'ayant pas de contact avec le lit.</p>

      <figure class="encart">

        <img class="tuto" src="images/cura09.png" alt="">
        <div class="numero"></div><figcaption class="legende_page_droite">Température de la buse <br/>et du lit d'impression</figcaption>

      </figure>

      <figure class="encart">
        <img class="tuto" src="images/cura10.png" alt="">
        <div class="numero"></div><figcaption>Ajouter des supports autour <br/>de l'objet imprimé</figcaption>
      </figure>

      <p>Une fois que les paramètres d'impression sont bons, cliquez sur <span class="code">Slice</span>. L'objet est alors transformé en fichier G-CODE reprenant les paramètres venant d'être déterminés. Vous pouvez prévisualiser les couches de votre impression avant de sauver le fichier sur une carte SD ou une clé USB.</p>

      <figure>
        <img class="tuto" src="images/cura11.png" alt="">
        <div class="numero"></div><figcaption>Trancher le modèle</figcaption>
      </figure>

      <div class="page_blanche">

      </div>

      <div class="projet" id="pj09">
        <div class="bloc1">
          <h3>Préparer <br/>l'impression <br/>3D avec <br/>Repetier Host</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>
        <div class="logo">
          <img src="images/rh_logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro">Repetier Host est un slicer open source avec lequel on peut préparer l'impression 3D d'un objet.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/rh_titre.png'); background-position: 40% 75%;">

        </div>

      </div>

      <h4>Marche à suivre</h4>

      <p>Sélectionnez tout d'abord le profil de l'imprimante 3D que vous souhaitez utiliser en cliquant sur <span class="code">Réglages imprimante</span> en haut à gauche. Pour importer un objet 3D, cliquez sur l'icône <span class="code">+</span> entourée d'un cercle ou sur <span class="code">Charger</span> en haut à gauche.</p>

      <p class="p_img_bas">C'est également dans cet onglet que se font les réglages concernant la température de l'extrudeur ainsi que celle du lit. <br/>Dans Repetier Host, on ne définit pas le matériau qui va servir à l'impression, mais les températures d'impression. Renseignez-vous donc sur les températures de l'extrudeur et du lit d'impression propres à chaque matériau (en général indiquées sur la boîte du filament).</p>

      <figure>
        <img class="tuto" src="images/rh02.png" alt="">
        <div class="numero"></div><figcaption>Choisir l'imprimante 3D</figcaption>
      </figure>

      <figure>
        <img class="tuto" src="images/rh07.png" alt="">
        <div class="numero"></div><figcaption>Régler la température de l'extrudeur et du lit d'impression</figcaption>
      </figure>

      <p>Dans l'onglet <span class="code">Placement d'objets</span> du menu de gauche on trouve un outil permettant de redimensionner l'objet.</p>
      <p class="p_img_bas">On trouve dans la même barre des outils pour déplacer ou faire pivoter l'objet. Cela se révèle utile si votre objet a une forme complexe et que vous voulez placer les supports d'impression d'une certaine façon.</p>

      <figure>
        <img class="tuto" src="images/rh01.png" alt="">
        <div class="numero"></div><figcaption>Redimensionner l'objet 3D</figcaption>
      </figure>
      <figure>
        <img class="tuto" src="images/rh03.png" alt="">
        <div class="numero"></div><figcaption>Pivoter l'objet 3D</figcaption>
      </figure>


      <p>Pour trancher l'objet, il faut se rendre dans l'onglet <span class="code">Trancheur</span>. Vous pouvez sélectionner différents trancheurs dans le menu déroulant, mais <span class="code">Slic3r</span> est un bon trancheur et fonctionne très bien dans Repetier Host. Pour lancer le tranchage, cliquez sur le bouton <span class="code">Trancher avec Slic3r</span>.</p>
      <p class="p_img_bas">Une fois le tranchage fait on se retrouve dans l'onglet <span class="code">Pré visualiser impression</span>, où on peut voir les couches de l'impression à venir. C'est ici qu'on peut enregistrer le fichier G-CODE sur un périphérique.</p>

      <figure>
        <img class="tuto" src="images/rh05.png" alt="">
        <div class="numero"></div><figcaption>Trancher avec Slic3r</figcaption>
      </figure>


      <figure>
        <img class="tuto" src="images/rh06.png" alt="">
        <div class="numero"></div><figcaption>Objet 3D tranché prêt <br/>à être exporté</figcaption>
      </figure>


      <div class="partie_gauche">

      </div>
      <div class="partie_droite">
        <h2 id="pt03">Découpe laser</h2>
      </div>


      <div class="page_blanche">

      </div>



      <div class="projet" id="pj11">
        <div class="bloc1">
          <h3>Préparer <br/>un fichier <br/>à découper <br/>ou à graver <br/>avec Inkscape</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>
        <div class="logo">
          <img src="images/Inkscape_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro">Inkscape est un logiciel libre de dessin vectoriel utilisant le format SVG, un format d'image vectorielle open source. Grâce aux outils qu'il propose, on peut s'en servir pour créer des visuels destinés à la découpe ou la gravure laser.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/ink_titre.png'); background-position: 25% 75%;"></div>

      </div>
      <h4>Marche à suivre</h4>
      <p>Quand on ouvre Inkscape, on a devant soi un document vierge. La première chose à faire est de mettre le document, par défaut au format A4, au format du dessin que vous souhaitez faire. Pour cela, allez dans <span class="code">Fichier</span> > <span class="code">Propriétés du document</span>, et là, dans la boîte de dialogue, vous pouvez changer les dimensions de la page. Pour que le zoom corresponde bien à votre page, cliquez sur <span class="code">Affichage</span> > <span class="code">Zoom</span> > <span class="code">Page</span>.</p>

      <p class="p_img_bas">La barre d'outils à gauche de l'écran contient des outils permettant de dessiner des formes&nbsp;: <span class="code">Ellipse</span> <img class="icone" src="images/draw-ellipse.svg" alt="">, <span class="code">Rectangle</span> <img class="icone" src="images/rectangle_tool.png" alt=""> ou encore <span class="code">Polygone</span> <img class="icone" src="images/star-tool-icon.png" alt="">. Chaque fois que vous créez une forme, vous pouvez modifier ses paramètres dans la barre d'outils du haut de la fenêtre pour obtenir des formes sur mesure. Il faut bien comprendre qu'en découpe/gravure laser, on ne fait que brûler le matériau&nbsp;; d'autre part il n'y a pas d'aplats, le laser ne pouvant dessiner que des traits de la largeur de son faisceau. Il faut donc bien avoir à l'esprit que le dessin doit être travaillé en contours car c'est tout ce que la machine sera capable de reproduire.</p>

      <figure>
        <img class="tuto" src="images/ink0000.png" alt="">
        <div class="numero"></div><figcaption>Redimensionner la page <br/>au format du dessin</figcaption>
      </figure>
      <figure>
        <img class="tuto" src="images/ink000.png" alt="">
        <div class="numero"></div><figcaption>Utiliser les formes de base <br/>et leurs paramètres</figcaption>
      </figure>

      <p>Pour afficher le document uniquement en contours, et ainsi visualiser précisément ce que la machine laser reproduira, allez dans le menu <span class="code">Affichage</span> > <span class="code">Mode d'affichage</span> > <span class="code">Contours</span>. <br/>
        Pour le dessin, il y a aussi un outil <span class="code">Stylo</span> <img class="icone" src="images/pen_tool_icon.png" alt=""> qui permet de dessiner une forme vectorielle en plaçant des points dans le document. Si vous tirez les poignées au moment où vous placez le point, cela crée des courbes.</p>

      <p class="p_img_bas">L'outil <span class="code">Texte</span> <img class="icone" src="images/outil-texte.png" alt=""> permet de taper un texte au clavier dans le document. Quand il est sélectionné, les propriétés du texte apparaissent dans la barre d'outil supérieure. <br/>On peut changer le corps du texte, la police utilisée, l'interlignage, etc. Vous remarquez alors que, bien que votre affichage soit en mode <span class="code">Contours</span>, vous voyez le texte à&nbsp;l'écran avec un fond noir. C'est parce que le texte que vous venez de taper n'est pas vectorisé. Pour ce faire, sélectionnez le texte et cliquez sur <span class="code">Chemin</span> > <span class="code">Objet en chemin</span>, puis sur <span class="code">Objet</span> > <span class="code">Dégrouper</span>. Chaque lettre est alors vectorisée et sélectionnable individuellement.</p>

      <figure>
        <img class="tuto" src="images/ink00.png" alt="">
        <div class="numero"></div><figcaption>Affichage en «&nbsp;Contours&nbsp;»</figcaption>
      </figure>

      <figure>
        <img class="tuto" src="images/ink01.png" alt="">
        <div class="numero"></div><figcaption>Ajouter du texte dans le dessin</figcaption>
      </figure>



      <p>Il existe une extension particulièrement appropriée pour graver du texte au laser, <span class="code">Texte Hershey</span>. Les fontes Hershey sont une famille de typographies vectorielles, dessinées par le squelette plutôt que par le contour (on n'a donc pas besoin de se préoccuper de les vectoriser). Pour utiliser l'extension, créez un bloc de texte, sélectionnez-le puis allez dans <span class="code">Extensions</span> > <span class="code">Texte</span> > <span class="code">Texte Hershey</span>. Dans la boîte de dialogue qui s'affiche, vous pouvez modifier le texte et choisir quelle typographie de la famille utiliser.</p>

      <p class="p_img_bas">Une fois votre dessin prêt, assurez-vous que tout est bien transformé en chemin et que rien ne dépasse du format (sauf si vous souhaitez avoir un fond perdu). Le format sous lequel exporter le fichier dépend du logiciel qui communique avec le contrôleur de la découpeuse laser. Si celui-ci accepte le format SVG, sauvegardez tout simplement le document. Pour exporter le fichier au format DXF, format standard pour les tables traçantes, cliquez sur <span class="code">Fichier</span> > <span class="code">Enregistrer sous</span>, puis sélectionnez le format <span class="code">Table traçante ou coupante (Autocad DXF R14)</span>.</p>

      <figure>
        <img class="tuto" src="images/ink02.png" alt="">
        <div class="numero"></div><figcaption>Extension «&nbsp;Texte Hershey&nbsp;»</figcaption>
      </figure>
      <figure>
        <img class="tuto" src="images/ink03.png" alt="">
        <div class="numero"></div><figcaption>Enregistrer le fichier au format SVG ou DXF</figcaption>
      </figure>

      <div class="page_blanche">

      </div>


      <div class="projet" id="pj55">
        <div class="bloc1">
          <h3>Vectoriser <br/>une image <br/>à graver</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>
        <div class="logo">
          <img src="images/Inkscape_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro">La découpe laser ne pouvant reproduire ni les couleurs ni les surfaces pleines d'ume image, il faut vectoriser celle-ci afin de pouvoir la graver. Plusieurs solutions à cela&nbsp;: transformer les contrastes de l'image originelle en trames, ou ne garder que les contours de ce qu'elle représente.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/ink12_titre.png'); background-position: 15% 70%;"></div>

      </div>
      <h4>Marche à suivre</h4>
      <p>Inkscape possède un outil de vectorisation d'images. Pour l'utiliser, il faut sélectionner l'image à traiter (après l'avoir importée dans le document avec <span class="code">Fichier</span> > <span class="code">Importer...</span>) et aller dans <span class="code">Chemin</span> > <span class="code">Vectoriser un objet matriciel</span>. Étant donné qu'on ne peut graver que des lignes, on utilisera la fonction <span class="code">Détection de contour</span> qui va tracer automatiquement les contours repérés dans l'image. En jouant sur les différents paramètres on obtient une détection plus ou moins sensible.</p>

      <p class="p_img_bas">La détection de contour d'Inkscape se base sur les contrastes et les différences de couleurs trouvés dans l'image originelle.</p>

      <figure>
        <img class="tuto" src="images/ink11.png" alt="">
        <div class="numero"></div><figcaption>Outil «&nbsp;Vectoriser un objet matriciel&nbsp;»</figcaption>
      </figure>
      <figure>
        <img class="tuto" src="images/ink12.png" alt="">
        <div class="numero"></div><figcaption>Résultat de la détection <br/>de contour</figcaption>
      </figure>

      <p>Une autre fonction de vectorisation d'objet matriciel que l'on peut utiliser pour obtenir des contours est <span class="code">Autotrace</span>, qui utilise un autre algorithme de vectorisation des images matricielles.</p>

      <p class="p_img_bas">Avec <span class="code">Autotrace</span>, le résultat dépend énormément des contrastes de l'image d'origine. Plus ceux-ci sont marqués, plus l'algorithme détectera des surfaces à remplir de lignes. Cette fonction vectorise de manière moins précise, mais donne des résultats plus artistiques.</p>

      <figure>
        <img class="tuto" src="images/ink13.png" alt="">
        <div class="numero"></div><figcaption>Vectoriser avec «&nbsp;Autotrace&nbsp;»</figcaption>
      </figure>

      <figure>
        <img class="tuto" src="images/ink14.png" alt="">
        <div class="numero"></div><figcaption>Résultat de l'outil «&nbsp;Autotrace&nbsp;»</figcaption>
      </figure>

      <p>Si Inkscape ne suffit pas à obtenir une vectorisation satisfaisante, il existe un site web qui permet d'appliquer les algorithmes de rasterisation utilisés pour les plotters et de télécharger au format SVG l'image transformée&nbsp;: mitxela.com/plotterfun. Chaque algorithme répertorié donne un résultat singulier, il faut prendre le temps de tous les essayer. <br/>À partir de chaque algorithme on peut modifier les paramètres de traitement de <br/>l'image pour des résultats allant du simple tramage à la déformation artistique. Lorsque le résultat vous satisfait, cliquez <br/>sur <span class="code">Download SVG</span></p>


      <p class="p_img_bas">On récupère alors notre image vectorisée selon un algorithme au format SVG, qu'on peut ouvrir dans Inkscape pour préparer le fichier à la gravure laser.</p>

      <figure>
        <img class="tuto" src="images/plot01.png" alt="">
        <div class="numero"></div><figcaption>Rasterisation avec PlotterFun</figcaption>
      </figure>
      <figure>
        <img class="tuto" src="images/plot04.png" alt="">
        <div class="numero"></div><figcaption>Image SVG récupérée <br/>depuis PlotterFun</figcaption>
      </figure>


      <div class="page_blanche">

      </div>

      <div class="projet" id="pj10">
        <div class="bloc1">
          <h3>Exporter un <br/>fichier DXF <br/>depuis Freecad</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>
        <div class="logo">
          <img src="images/freecad_logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro">Le format DXF est utilisé par les découpeuses laser et les tables traçantes&nbsp;;<br/>il s'agit d'un format de fichier 2D à l'origine propriétaire créé par Autodesk dont certaines versions sont tombées dans le domaine public.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/fc05_titre.png'); background-position: 70% 65%;"></div>

      </div>
      <h4>Marche à suivre</h4>
      <p>On peut dessiner une forme traçable par une découpeuse laser dans Freecad en créant un <span class="code">Sketch</span> <img class="icone" src="images/Sketcher_NewSketch.svg" alt=""> depuis l'atelier <span class="code">Part design</span> <img class="icone" src="images/Workbench_PartDesign.svg" alt="">. On peut utiliser tous les outils de dessin disponibles ainsi que les contraintes si on veut pouvoir modifier le croquis paramétriquement. <br/>Pour plus d'informations sur le dessin paramétrique dans Freecad, voir les projets «&nbsp;Modéliser un cube dans Freecad&nbsp;» (<a class="crossref" href="#pj01">p.</a>) <br/>et «&nbsp;Utiliser les contraintes dans Freecad&nbsp;» (<a class="crossref" href="#pj02">p.</a>).</p>
      <p class="p_img_bas">Une fois l'esquisse terminée, cliquez sur <span class="code">Close</span> dans la barre de tâches. Pour exporter le fichier en DXF, sélectionnez l'esquisse dans l'arborescence du projet et cliquez sur <span class="code">Fichier</span> > <span class="code">Exporter</span> puis choisissez le format <span class="code">Autodesk DXF 2D</span>.</p>

      <figure>
        <img class="tuto" src="images/fc50.png" alt="">
        <div class="numero"></div><figcaption>Dessiner l'esquisse avec <br/>les outils de «&nbsp;Sketcher&nbsp;»</figcaption>
      </figure>

      <figure>
        <img class="tuto" src="images/fc51.png" alt="">
        <div class="numero"></div><figcaption>Export au format DXF</figcaption>
      </figure>



      <div class="partie_gauche">

      </div>
      <div class="partie_droite">
        <h2 id="pt04">CNC</h2>
      </div>


      <div class="page_blanche">

      </div>

      <div class="projet" id="pj12">
        <div class="bloc1">
          <h3>Exporter <br/>un fichier <br/>G-CODE depuis <br/>Freecad</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>
        <div class="logo">
          <img src="images/freecad_logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro">On peut utiliser Freecad pour modéliser un objet et générer le fichier G-CODE qui permettra l'usinage d'une pièce sur une fraiseuse à contrôle numérique.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/fc68_titre.png'); background-position: 50% 55%;"></div>

      </div>
      <h4>Marche à suivre</h4>
      <p>On prend pour exemple un pavé extrudé de 10 mm dont la face supérieure est ponctuée de quatre trous et d'une poche centrale. Une fois l'objet voulu modélisé dans l'atelier <span class="code">Part design</span> <img class="icone" src="images/Workbench_PartDesign.svg" alt="">, on se déplace dans l'atelier <span class="code">Path</span> <img class="icone" src="images/Workbench_Path.svg" alt=""> (voir les projets du chapitre «&nbsp;Modélisation 3D&nbsp;», p. <a class="crossref" href="#pt01"></a>, pour plus d'informations sur la création d'objets 3D dans Freecad).</p>
      <p class="p_img_bas">Il faut créer un <span class="code">Job</span> pour l'usinage en cliquant sur l'outil <span class="code">Create job</span> <img class="icone" src="images/Path_Job.svg" alt="">. Dans la première boîte de dialogue qui s'affiche, assurez-vous que le solide à usiner est bien sélectionné.</p>


      <figure class="encart">
        <img class="tuto" src="images/fc59.png" alt="">
        <div class="numero"></div><figcaption>Aller dans l'atelier «&nbsp;Path&nbsp;» <br/>une fois l'objet modélisé</figcaption>
      </figure>
      <figure class="encart">
        <img class="tuto" src="images/fc60.png" alt="">
        <div class="numero"></div><figcaption>Créer un nouveau «&nbsp;Job&nbsp;»</figcaption>
      </figure>

      <p>Ensuite, la boîte de dialogue dans le menu de gauche vous place dans l'onglet <span class="code">Setup</span> de votre <span class="code">Job</span>. On peut y déplacer l'origine de notre repère à l'aide des flèches en bas à gauche.</p>
      <p class="p_img_bas">Rendez-vous dans l'onglet <span class="code">Tools</span> pour sélectionner l'outil qui procèdera à l'usinage. Une liste des outils déjà configurés apparaît alors.</p>

      <figure class="encart">
        <img class="tuto" src="images/fc61.png" alt="">
        <div class="numero"></div><figcaption>Définir l'origine du «&nbsp;Job&nbsp;»</figcaption>
      </figure>
      <figure class="encart">
        <img class="tuto" src="images/fc62.png" alt="">
        <div class="numero"></div><figcaption>Sélectionner un outil</figcaption>
      </figure>

      <p>Pour modifier les paramètres de l'outil, sélectionnez-le puis cliquez sur le bouton <span class="code">Edit</span>. C'est ici qu'on peut régler la vitesse de déplacement de l'outil ou encore son sens de rotation.</p>
      <p class="p_img_bas">Si vous souhaitez configurer un nouvel outil et l'ajouter à votre liste, cliquez sur <span class="code">Tool editor</span>. Une boîte de dialogue vous demande alors de renseigner le type de <br/>l'outil ainsi que ses cotes.</p>

      <figure class="encart">
        <img class="tuto" src="images/fc63.png" alt="">
        <div class="numero"></div><figcaption>Modifier les paramètres <br/>de l'outil</figcaption>
      </figure>
      <figure class="encart">
        <img class="tuto" src="images/fc69.png" alt="">
        <div class="numero"></div><figcaption>Configurer un nouvel outil</figcaption>
      </figure>

      <p>Il faut maintenant déterminer les différentes actions de l'usinage. On commence par les découpes intérieures des quatre trous de la face supérieure de l'objet. Il faut les sélectionner en cliquant sur l'intérieur de leur creux. Pour obtenir une découpe circulaire, il faut créer une tâche <span class="code">Helix</span> <img class="icone" src="images/Path_Helix.svg" alt="">. <br/>Dans la boîte de dialogue qui s'affiche, vérifiez dans l'onglet <span class="code">Profondeurs</span> que les valeurs <span class="code">Start depth</span> et <span class="code">Final depth</span> correspondent bien pour la première à la hauteur de la pièce entière, et pour la deuxième à cette hauteur moins celle du creux des trous (ici, puisqu'on perce l'objet, on doit finir à 0&nbsp;mm).</p>
      <p class="p_img_bas">Il faut créer une autre tâche pour creuser la poche de la face supérieure de l'objet. <br/>Pour ce type de creux non-circulaire, on utilise l'outil <span class="code">Create pocket shape</span> <img class="icone" src="images/Path_Pocket.svg" alt=""> après avoir sélectionné la poche en cliquant sur son fond ou bien sur l'intérieur de son creux. Dans la boîte de dialogue à gauche, vérifiez également dans l'onglet <span class="code">Profondeurs</span> que les valeurs <span class="code">Start depth</span> et <span class="code">Final depth</span> correspondent bien pour la première à la hauteur de la pièce entière, et pour la deuxième à cette hauteur moins celle du creux de la poche. Vous pouvez également choisir le motif et l'angle selon lequel le fraisage de la poche sera effectué.</p>
      <figure class="encart">
        <img class="tuto" src="images/fc64.png" alt="">
        <div class="numero"></div><figcaption>Créer une tâche «&nbsp;Helix&nbsp;» <br/>pour faire les trous</figcaption>
      </figure>
      <figure class="encart">
        <img class="tuto" src="images/fc65.png" alt="">
        <div class="numero"></div><figcaption>Créer une tâche «&nbsp;Pocket&nbsp;» <br/>pour faire la poche</figcaption>
      </figure>

      <p>La dernière tâche à ajouter est la découpe extérieure de la pièce. Pour cela, on utilise l'outil <span class="code">Create profile</span> <img class="icone" src="images/Path_Contour.svg" alt=""> qui va générer un chemin de découpe pour l'extérieur de la pièce.</p>
      <p class="p_img_bas">Une fois toutes les tâches de l'usinage déterminées, on peut voir en rouge <br/>les déplacements de l'outil au-dessus de <br/>la pièce, et en vert les opérations de découpe.</p>

      <figure class="encart">
        <img class="tuto" src="images/fc66.png" alt="">
        <div class="numero"></div><figcaption>Ajouter un «&nbsp;Profile&nbsp;» pour la découpe extérieure de la pièce</figcaption>
      </figure>
      <figure class="encart">
        <img class="tuto" src="images/fc67.png" alt="">
        <div class="numero"></div><figcaption>Les chemins de découpe <br/>sont visibles</figcaption>
      </figure>

      <p>Pour pré-visualiser le fraisage de la pièce par la CNC, cliquez sur l'outil <span class="code">Simulate G-CODE Path</span> <img class="icone" src="images/32px-Path_Simulator.png" alt="">. Vous pouvez alors voir l'ordre dans lequel vont se dérouler les opérations. <br/>Si vous souhaitez vérifier le G-CODE avant l'export du fichier, faîtes un clic-droit sur le <span class="code">Job</span> dans l'arborescence du projet et sélectionnez <span class="code">Inspect G-CODE</span>.</p>

      <p class="p_img_bas">Quand le fichier est prêt à être exporté, cliquez sur <span class="code">Job</span> dans l'arborescence du projet et choisissez dans la liste de sa sous-propriété <span class="code">Post Processor</span> (dans la propriété <span class="code">Output</span>) le post-processeur qui correspond au contrôleur de votre CNC. En effet Freecad utilise son propre dialecte de G-CODE et le transcrit au moment de l'export en fonction du contrôleur. Une fois ce réglage fait, cliquez sur l'outil <span class="code">Post process</span> <img class="icone" src="images/Path_PostProcess.svg" alt=""> pour exporter le fichier G-CODE vers la destination de votre choix.</p>

      <figure class="encart">
        <img class="tuto" src="images/fc68.png" alt="">
        <div class="numero"></div><figcaption>Pré-visualiser l'usinage</figcaption>
      </figure>

      <figure class="encart">
        <img class="tuto" src="images/fc71.png" alt="">
        <div class="numero"></div><figcaption>Exporter le fichier avec <br/>«&nbsp;Post process&nbsp;»</figcaption>
      </figure>


      <div class="page_blanche">

      </div>

      <div class="projet" id="pj13">
        <div class="bloc1">
          <h3>Exporter <br/>un fichier <br/>G-CODE depuis <br/>Inkscape</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>
        <div class="logo">
          <img src="images/Inkscape_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro">Inkscape dispose d'une extension permettant d'exporter un dessin au format G-CODE en vue de son usinage sur une CNC&nbsp;: GcodeTools. Cette méthode crée un fichier G-CODE dans lequel la profondeur d'usinage est uniforme&nbsp;; cela ne convient pas à tous les types de travaux.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/ink09_titre.png'); background-position: 35% 70%;"></div>

      </div>

      <p>Dans Inkscape, commencez par mettre le document au format de votre matériau dans <span class="code">Fichier</span> > <span class="code">Propriétés du document</span>. Puis dessinez les chemins à découper (si vous avez besoin de davantage d'informations sur le dessin vectoriel dans Inkscape, voir le projet «&nbsp;Préparer un fichier à découper ou à graver avec Inkscape&nbsp;» p. <a class="crossref" href="#pj11"></a>). <br/>S'il y a plus d'un chemin sur votre dessin, sélectionnez-les tous et faîtes <span class="code">Chemin</span> > <span class="code">Combiner</span>. Enfin sélectionnez votre chemin combiné et réglez l'épaisseur de son contour à la valeur égale au rayon de la fraise que vous allez utiliser pour l'usinage.</p>
      <p class="p_img_bas">Allez dans <span class="code">Extensions</span> > <span class="code">GcodeTools</span> > <span class="code">Points d'orientation</span> et réglez la valeur <span class="code">Profondeur sur l'axe Z</span> selon la profondeur de découpe que vous souhaitez obtenir. Puis cliquez sur <span class="code">Appliquer</span>.</p>
      <figure>
        <img class="tuto" src="images/ink05.png" alt="">
        <div class="numero"></div><figcaption>Mettre le contour du chemin <br/>au rayon de la fraise</figcaption>
      </figure>
      <figure>
        <img class="tuto" src="images/ink06.png" alt="">
        <div class="numero"></div><figcaption>Régler les points d'orientation et la profondeur de l'axe Z</figcaption>
      </figure>


      <p>À présent deux triplets de points sont apparus en bas de la page. La flèche de celui de gauche doit impérativement pointer le coin inférieur gauche de la page et la flèche de celui de droite le coin inférieur droit de la page. Si ce n'est pas le cas vous pouvez redimensionner proportionnellement le bloc des triplets et adapter la première valeur du triplet de droite à la bonne dimension (la largeur du document).</p>
      <p class="p_img_bas">Allez dans <span class="code">Extensions</span> > <span class="code">GcodeTools</span> > <span class="code">Bibliothèque d'outils</span> et choisissez l'outil qui correspond à l'usinage que vous allez faire. Puis cliquez sur <span class="code">Appliquer</span>.</p>

      <figure>
        <img class="tuto" src="images/ink07.png" alt="">
        <div class="numero"></div><figcaption>Faire coïncider les triplets avec les coins bas du document</figcaption>
      </figure>
      <figure>
        <img class="tuto" src="images/ink08.png" alt="">
        <div class="numero"></div><figcaption>Choisir le type d'outil</figcaption>
      </figure>

      <p>Un cadre gris apparaît alors dans le document. Vous pouvez modifier ses valeurs, notamment le diamètre de l'outil, qui doit être celui de votre fraise à l'aide de l'outil <span class="code">Texte</span> <img class="icone" src="images/outil-texte.png" alt="">.</p>
      <p class="p_img_bas">Allez dans <span class="code">Extensions</span> > <span class="code">GcodeTools</span> > <span class="code">Chemin vers G-code</span> pour exporter le fichier. Dans l'onglet <span class="code">Préférences</span> vous pouvez choisir le nom du fichier ainsi que le dossier où il sera sauvegardé. Cliquez sur <span class="code">Appliquer</span> quand les options sont bonnes.</p>
      <figure>
        <img class="tuto" src="images/ink09.png" alt="">
        <div class="numero"></div><figcaption>Vérifier les valeurs dans <br/>le cadre gris</figcaption>
      </figure>
      <figure>
        <img class="tuto" src="images/ink10.png" alt="">
        <div class="numero"></div><figcaption>Exporter le fichier en G-CODE</figcaption>
      </figure>

      <div class="page_blanche">

      </div>

      <div class="projet" id="pj14">
        <div class="bloc1">
          <h3>Gérer <br/>l'usinage <br/>d'un fichier <br/>G-CODE dans <br/>Mach3</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>
        <div class="logo">
          <img src="images/logo-mach3.jpg" alt="">
          <div class="blanc_logo">

          </div>
        </div>
        <div class="bloc_intro">
          <p class="intro">Mach3 est un logiciel de type contrôleur CNC&nbsp;: il permet de contrôler le mouvement des moteurs de la machine par l'éxécution de fichiers G-CODE.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="background-image:url('images/mach3_titre.PNG'); background-position: 50% 50%;"></div>

      </div>

      <p>La CNC doit être allumée avant d'ouvrir Mach3 car le logiciel va chercher le contrôleur avec lequel il va communiquer. <br/>La première chose à faire lorsqu'on ouvre l'interface de Mach3 est de cliquer sur le gros bouton rouge <span class="code">Reset</span> en bas à gauche pour stopper tous les processus qui pourraient encore être en cours sur la machine. <br/>Pour charger votre fichier G-CODE, cliquez sur le bouton <span class="code">Load G-code</span> qui va vous permettre de parcourir les fichiers de l'ordinateur. Le contenu du fichier G-CODE choisi s'affiche alors dans la fenêtre en haut à gauche. <br/><br/>Si vous souhaitez modifier des lignes du fichier G-CODE, cliquez sur le bouton <span class="code">Edit G-code</span> qui ouvrira alors le fichier dans un éditeur de texte.</p>

      <figure>
        <img class="tuto" src="images/mach3_02.PNG" alt="">
        <div class="numero"></div><figcaption>Appuyer sur «&nbsp;Reset&nbsp;» et charger <br/>le fichier G-CODE</figcaption>
      </figure>


      <p>Il faut à présent positionner les axes de la machine à leurs origines. Pour ouvrir la fenêtre <span class="code">MPG mode</span>, pressez la touche <span class="code">Tab</span> du clavier. Les boutons rouges et verts permettent de déplacer négativement ou positivement chacun des quatre axes. <br/>Par défaut le <span class="code">Jog Mode</span> est réglé sur <span class="code">Continuous</span>. <br/>Ce mode déplace les axes en continu&nbsp;: <br/>aussi longtemps que vous pressez l'un des boutons verts ou rouges, l'axe continuera de se déplacer dans cette direction. <br/>Pour déplacer les axes de façon plus précise on peut régler le <span class="code">Jog Mode</span> sur <span class="code">Step</span> en cliquant sur le bouton. Quand ce mode est activé, les axes se déplacent selon les pas que l'on a définis (la valeur des pas se règle dans la case <span class="code">Cycle Jog Step</span>).</p>
      <figure>
        <img class="tuto" src="images/mach3_04.PNG" alt="">
        <div class="numero"></div><figcaption>Déplacer les axes en mode continu ou pas-à-pas</figcaption>
      </figure>


      <p>Quand les axes sont positionnés convenablement, cliquez sur les boutons <span class="code">Zero X</span>, <span class="code">Zero Y</span> et <span class="code">Zero Z</span> pour définir l'emplacement de l'origine de chacun des axes. <br/>Les valeurs numériques des axes passent alors à <span class="code">0.0000</span>.</p>
      <figure>
        <img class="tuto" src="images/mach3_06.PNG" alt="">
        <div class="numero"></div><figcaption>Déterminer l'origine des axes X, Y et Z</figcaption>
      </figure>

      <p>Pressez à nouveau la touche <span class="code">Tab</span> du clavier pour quitter la fenêtre <span class="code">MPG mode</span>. Allumez <br/>le moteur de la fraise sur la machine si ce n'était pas déjà fait et lancez l'usinage en cliquant sur le bouton vert <span class="code">Cycle Start</span>.</p>
      <figure>
        <img class="tuto" src="images/mach3_07.PNG" alt="">
        <div class="numero"></div><figcaption>Lancer l'usinage avec <br/>«&nbsp;Cycle start&nbsp;»</figcaption>
      </figure>

      <p>L'onglet <span class="code">Tool Path</span> de Mach3 permet également de contrôler l'usinage tout en offrant une fenêtre d'affichage du travail en cours plus grande. Vous pouvez voir pendant l'usinage comment Mach3 parcourt les lignes de G-CODE une par une dans la fenêtre en haut à gauche. En cas de problème pendant l'usinage, cliquez sur <span class="code">Stop</span> pour mettre fin au travail en cours. Ne pressez le bouton <span class="code">Reset</span> en cours d'usinage qu'en cas de problème majeur car lorsque ce bouton est pressé toute la configuration que vous aviez faite est perdue.</p>
      <figure>
        <img class="tuto" src="images/mach3_08.PNG" alt="">
        <div class="numero"></div><figcaption>Contrôler le bon déroulement <br/>de l'usinage</figcaption>
      </figure>


      <div class="partie_gauche">

      </div>
      <div class="partie_droite">
        <h2 id="pt05">Arduino</h2>
      </div>


      <div class="page_blanche">

      </div>

      <div class="projet" id="pj15">
        <div class="bloc1">
          <h3>Montage <br/>électronique <br/>en série</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro">Avant de commencer à programmer avec l'Arduino, voyons les rudiments de l'électronique. Un circuit monté en série rend les composants dépendants les uns des autres et de l'ordre dans lequel ils sont placés. Dans ce premier circuit, nous allons utiliser l'Arduino comme source d'alimentation.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="width:40mm">
          <div class="led">
            <img src="images/led_rouge.png" alt="">
          </div>
          <div class="bouton">
            <img src="images/bouton.png" alt="">
          </div>
          <div class="bouton">
            <img src="images/bouton.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>

        </div>
      </div>

      <img class="schema" src="images/serie.svg" alt="">

      <ol>
        <li>On commence par brancher le 5V et le GND <br/>de l'Arduino à la breadboard pour l'alimenter.</li>
        <li>Ensuite on place une résistance de 220 Ω entre le 5V et le premier bouton. Reliez la sortie <br/>du premier bouton à l'entrée du second.</li>
        <li>Puis reliez la sortie du second bouton à l'anode (patte la plus longue) de la LED.</li>
        <li>Enfin reliez l'autre patte de la LED au GND.</li>
      </ol>

      <h4>Manipuler le circuit</h4>
      <p>Pressez chaque bouton séparément et observez ce qu'il se passe.</p>
      <p>Pressez ensuite les deux boutons en même temps. La LED s'allume seulement dans ce cas. C'est normal puisque le circuit est monté en série : le courant ne circule vers le deuxième interrupteur que si le premier est pressé, et vers la LED que si les deux interrupteurs sont pressés. Le fonctionnement du circuit est donc bien dépendant de l'ordre du montage.</p>

      <div class="projet" id="pj16">
        <div class="bloc1">
          <h3>Montage <br/>électronique <br/>en parallèle</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro">À l'inverse du montage en série, un montage en parallèle relie indépendamment chaque composant à l'alimentation, ce qui permet au courant d'emprunter plusieurs chemins à la fois.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="width:40mm">
          <div class="led">
            <img src="images/led_rouge.png" alt="">
          </div>
          <div class="bouton">
            <img src="images/bouton.png" alt="">
          </div>
          <div class="bouton">
            <img src="images/bouton.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>

        </div>
      </div>

      <img class="schema" src="images/parallele.svg" alt="">

      <ol>
        <li>On commence par brancher le 5V et le GND <br/>de l'Arduino à la breadboard pour l'alimenter.</li>
        <li>Reliez la résistance de 220 Ω aux deux interrupteurs à la fois, puis connectez la sortie de chaque interrupteur à la LED.</li>
      </ol>

      <h4>Manipuler le circuit</h4>
      <p>Pressez un bouton puis l'autre, et les deux en même temps et observez ce qu'il se passe.</p>
      <p>La LED s'allume dans tous les cas. <br/>C'est logique si on se penche sur le circuit&nbsp;: les deux boutons sont alimentés de manière indépendante et reliés à le LED, le courant peut donc trouver son chemin via un bouton ou l'autre. Les éléments sont indépendants de l'ordre du montage.</p>


      <div class="projet" id="pj17">
        <div class="bloc1">
          <h3>LED + 2<br/> boutons</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro" style="width: 70mm;">On va commencer la programmation de l'Arduino avec un projet simple&nbsp;: contrôler une LED avec 2 interrupteurs et des conditions différentes sur chacun (if/else) qui détermineront le comportement de la LED.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="width:40mm">
          <div class="led">
            <img src="images/led_rouge.png" alt="">
          </div>
          <div class="bouton">
            <img src="images/bouton.png" alt="">
          </div>
          <div class="bouton">
            <img src="images/bouton.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>


        </div>
      </div>

      <img class="schema" style="margin-left: 10mm;" src="images/led_boutons.svg" alt="">

      <ol>
        <li>Branchez l'un des interrupteurs au 5V et à la broche digitale 2 de l'Arduino.</li>
        <li>Connectez le deuxième bouton au 5V et à la broche digitale 3.</li>
        <li>La LED doit être connectée à la broche digitale 12 sur son anode (côté le plus long) et par sa cathode rejoindre le GND à travers une résistance de 220 Ω.</li>
      </ol>

      <h4>Le code</h4>
      <p>Ouvrez votre IDE Arduino. Lorsque vous ouvrez un nouveau sketch, vous pouvez voir deux fonctions vides. <br/>
      <br/>La première fonction, <span class="code">setup()</span>, gère ce que l'Arduino doit initialiser au démarrage du sketch. La seconde fonction, <span class="code">loop()</span> contient le code qui se répète indéfiniment (tant que le sketch tourne), généralement les actions du script.</p>
      <p class="expl_code">Passons à notre code&nbsp;: voici les premières lignes du script. Tout d'abord nous initialisons deux variables, <span class="code">switchState1</span> et <span class="code">switchState2</span> qui nous permettront de stocker l'état de chacun des deux boutons (pressé ou relâché). Pour commencer nous définissons la valeur à 0, donc relâché. <br/> <br/> Ensuite on définit le mode des broches utilisées&nbsp;: puisqu'on récupére les valeurs d'état des interrupteurs, ceux-ci sont en mode <span class="code">INPUT</span>, la broche de la LED, elle, se contentera de recevoir un signal électrique quand on veut l'allumer, elle est donc un <span class="code">OUTPUT</span>.</p>

      <pre class="prenb pre01">
        <span class="type">void</span> <span class="fonction">setup()</span> {
        }

        <span class="type">void</span> <span class="fonction">loop()</span> {
        }
      </pre>

      <pre id="pre04">
        <span class="type">int</span> switchState1 = 0;
        <span class="type">int</span> switchState2 = 0;

        <span class="type">void</span> <span class="fonction">setup()</span> {
          <span class="fonction">pinMode</span>(2, INPUT);
          <span class="fonction">pinMode</span>(3, INPUT);
          <span class="fonction">pinMode</span>(12, OUTPUT);
        }
      </pre>
      <p class="expl_break">Décomposons la suite du code&nbsp;: dans la fonction <span class="code">loop()</span>, nous commençons par actualiser les valeurs des variables <span class="code">switchState1</span> et <span class="code">switchState2</span>. Nous leur demandons à présent de lire perpétuellement les valeurs lues par les broches 2 et 3 de l'Arduino. Les broches 2 et 3 sont digitales, ce qui signifie qu'elles ne renvoient des valeurs qui ne peuvent être égales qu'à 0 ou 1 (oui ou non, vrai ou faux). La valeur sera de 1 si l'interrupteur est pressé, sinon elle sera de 0. <br/><br/>Le premier bloc <span class="code">if()</span> est la première condition&nbsp;: si le premier interrupteur est pressé. Dans ce cas nous donnons l'ordre à la broche 12 de l'Arduino d'envoyer du courant dans la LED (<span class="code">digitalWrite(12, HIGH)</span>). <br/>La fonction <span class="code">digitalWrite()</span> sert en effet à envoyer ou non du courant dans une broche. La fonction <span class="code">delay(1000)</span> placée sur la ligne suivante détermine le temps en milli-secondes pendant lequel l'instruction doit être exécutée. Ensuite nous arrêtons d'envoyer du courant dans la LED (<span class="code">digital<br/>Write(12, LOW)</span>), également pendant 1000 milli-secondes. Étant donné que le script tournera en boucle sur l'Arduino, cela fera alterner la LED entre les états allumée et éteinte.</p>



      <pre class="prenb">

        <span class="type">void</span> <span class="fonction">loop()</span> {
          switchState1 = <span class="fonction">digitalRead</span>(2);
          switchState2 = <span class="fonction">digitalRead</span>(3);

        <span class="type">if</span>(switchState1 == HIGH) {
          <span class="fonction">digitalWrite</span>(12, HIGH);
          <span class="fonction">delay</span>(1000);
          <span class="fonction">digitalWrite</span>(12, LOW);
          <span class="fonction">delay</span>(1000);
        }
      </pre>


    <p>Le deuxième bloc, <span class="code">else if()</span>, est la seconde condition&nbsp;: si le deuxième interrupteur est pressé. Il faut comprendre un <span class="code">else if()</span> comme une alternative au premier <span class="code">if()</span>, il s'agit d'une autre possibilité. L'instruction envoyée à la LED est similaire à celle du premier bloc, seule la valeur du <span class="code">delay()</span> change, ce qui aura pour conséquence un clignotement plus rapide.</p>
    <p class="expl_code">Enfin avec le <span class="code">else()</span> nous donnons le contrepoint aux conditions précédemment déclarées&nbsp;; si aucune des deux conditions n'est rencontrée, alors le code présent dans le bloc <span class="code">else()</span> s'exécute. Dans notre cas il s'agira des moments où aucun des interrupteurs n'est pressé.</p>

<pre class="prenb">
        <span class="type">else if</span>(switchState2 == HIGH) {
          <span class="fonction">digitalWrite</span>(12, HIGH);
          <span class="fonction">delay</span>(250);
          <span class="fonction">digitalWrite</span>(12, LOW);
          <span class="fonction">delay</span>(250);
        }
      </pre>

      <pre id="pre05">
        <span class="type">else</span> {
          <span class="fonction">digitalWrite</span>(12, LOW);
        }
      }
      </pre>


      <div class="page_blanche">

      </div>

      <div class="projet" id="pj18">
        <div class="bloc1">
          <h3>Potentiomètre <br/>+ 4 LED</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro">Ce circuit nous permettra de voir les autres notions de base d'Arduino&nbsp;: lire une valeur analogique et utiliser dans le code une boucle conditionnelle complexe grâce à laquelle nous allumerons les LEDS en fonction de la valeur envoyée par le potentiomètre.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="width:40mm">
          <div class="potentiometre">
            <img src="images/potentiometre.png" alt="">
          </div>
          <div class="led">
            <img src="images/led_rouge.png" alt="">
          </div>
          <div class="led">
            <img src="images/led_rouge.png" alt="">
          </div>
          <div class="led">
            <img src="images/led_rouge.png" alt="">
          </div>
          <div class="led">
            <img src="images/led_rouge.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>


        </div>
      </div>

      <img class="schema" src="images/4_leds_pot.svg" alt="">

      <ol>
        <li>Le montage du circuit commence par les LEDS. Connectez l'anode de la LED rouge à la broche digitale 2 de l'Arduino et sa cathode au GND via une résistance de 220 Ω.</li>
        <li>D'après la même logique, branchez les anodes des LEDS jaune, verte et bleue respectivement sur les pins digitales 3, 4 et 5, <br/>et leurs cathodes sur le GND à travers des résistances de 220 Ω.</li>
        <li>Venons-en ensuite au potentiomètre&nbsp;: <br/>ce composant fait varier l'intensité du courant qui le traverse en fonction de la position de son curseur. Nous pouvons ainsi l'utiliser pour lire un éventail de valeurs allant de 0 à 1023&nbsp;; c'est une valeur analogique (à la différence de la valeur digitale qui ne peut être que de 0 ou 1). Son branchement est facile&nbsp;: l'une des broches externes va sur le 5V, l'autre sur le GND, enfin la broche du milieu  doit être connectée à la broche A0 (A pour «&nbsp;Analog&nbsp;») de l'Arduino.</li>
      </ol>

      <h4>Le code</h4>
      <p>Nous commençons par déclarer toutes les variables dont nous allons avoir besoin. <br/>La première, <span class="code">potPin</span>, stocke la broche à laquelle est relié le potentiomètre. Ensuite nous déclarons une variable <span class="code">potVal</span> mais nous ne l'initialisons pas encore (cela viendra dans la <span class="code">loop()</span>). Pour finir nous déclarons une variable par LED pour leur associer leurs broches digitales.</p>
      <p class="expl_code">Dans le <span class="code">setup()</span> nous définissons le mode des 4 LEDS sur <span class="code">OUTPUT</span>. Cela permet à <br/>l'Arduino de savoir que les broches des LEDS ne seront utilisées que pour faire sortir du courant dedans (et non pour recevoir et lire un signal électrique). La dernière ligne, <span class="code">Serial.begin(9600);</span> sert à ouvrir un moniteur série. Cet outil nous sert de console&nbsp;: nous pourrons y afficher les valeurs transitant par l'Arduino pour déboguer.</p>

      <pre class="prenb pre01">
        <span class="type">int</span> const potPin = A0;
        <span class="type">int</span> potVal;
        <span class="type">int</span> led1 = 2;
        <span class="type">int</span> led2 = 3;
        <span class="type">int</span> led3 = 4;
        <span class="type">int</span> led4 = 5;
      </pre>

      <pre id="pre02">
        <span class="type">void</span> <span class="fonction">setup()</span> {
          <span class="fonction">pinMode</span>(led1, OUTPUT);
          <span class="fonction">pinMode</span>(led2, OUTPUT);
          <span class="fonction">pinMode</span>(led3, OUTPUT);
          <span class="fonction">pinMode</span>(led4, OUTPUT);
          <span class="type">Serial</span>.<span class="fonction">begin(9600)</span>;
        }
      </pre>
      <p class="expl_break">Nous commençons dans la <span class="code">loop()</span> par actualiser la valeur de la variable <span class="code">potVal</span>&nbsp;: nous lui demandons à présent de stocker la valeur analogique envoyée par le potentiomètre. Étant donné que la fonction <span class="code">loop()</span> tourne en boucle indéfiniment, la valeur provenant du potentiomètre sera donc continuellement mise à jour selon la position de son curseur. Ensuite nous demandons au moniteur série d'afficher cette valeur (<span class="code">Serial.print()</span>). Cela nous permettra de savoir la valeur de <span class="code">potVal</span> et de déboguer si nécessaire.</p>
      <p class="expl_code">Pour finir nous écrivons (toujours dans la <span class="code">loop()</span>) une boucle conditionnelle qui traitera 4 cas de figure, un par LED. Les valeurs pouvant être envoyées par le potentiomètre à la broche analogique allant de 0 à 1023, nous avons découpé cet intervalle en 4 parties pour créer 4 conditions.</p>
        <ul>
          <li>Première condition&nbsp;: si <span class="code">potVal</span> vaut moins que 256, alors c'est la LED rouge qui <br/>s'allume, les autres restent éteintes.</li>
          <li>Deuxième condition&nbsp;: si <span class="code">potVal</span> vaut entre 257 et 512, c'est la LED jaune qui s'allume, les autres restent éteintes.</li>

        </ul>


      <pre class="prenb">

        <span class="type">void</span> <span class="fonction">loop()</span> {
          potVal = <span class="fonction">analogRead</span>(potPin);
          <span class="type">Serial</span>.<span class="fonction">print</span>("Valeur potentiomètre : ");
          <span class="type">Serial</span>.<span class="fonction">print</span>(potVal);
      </pre>

      <pre id="pre03">

        <span class="type">if</span>(potVal <= 256) {
          <span class="fonction">digitalWrite</span>(led1, HIGH);
          <span class="fonction">digitalWrite</span>(led2, LOW);
          <span class="fonction">digitalWrite</span>(led3, LOW);
          <span class="fonction">digitalWrite</span>(led4, LOW);
        } <span class="type">else if</span>(potVal > 256 && potVal <= 512) {
          <span class="fonction">digitalWrite</span>(led2, HIGH);
          <span class="fonction">digitalWrite</span>(led1, LOW);
          <span class="fonction">digitalWrite</span>(led3, LOW);
          <span class="fonction">digitalWrite</span>(led4, LOW);
        }
</pre>

    <ul>
      <li>Troisième condition&nbsp;: si <span class="code">potVal</span> vaut entre 513 et 768, c'est la LED verte qui s'allume, les autres restent éteintes.</li>
      <li>Enfin, si aucune des trois conditions ci-dessus n'est rencontrée, c'est que <span class="code">potVal</span> vaut plus que 768, c'est alors la LED bleue qui s'allume et les autres restent éteintes.</li>
    </ul>

<pre class="prenb">
        <span class="type">else if</span>(potVal > 512 && potVal <= 768) {
          <span class="fonction">digitalWrite</span>(led3, HIGH);
          <span class="fonction">digitalWrite</span>(led2, LOW);
          <span class="fonction">digitalWrite</span>(led1, LOW);
          <span class="fonction">digitalWrite</span>(led4, LOW);
        } <span class="type">else</span> {
          <span class="fonction">digitalWrite</span>(led4, HIGH);
          <span class="fonction">digitalWrite</span>(led2, LOW);
          <span class="fonction">digitalWrite</span>(led3, LOW);
          <span class="fonction">digitalWrite</span>(led1, LOW);
        }
        <span class="fonction">delay</span>(15);
      }
      </pre>


      <div class="page_blanche">

      </div>


      <div class="projet" id="pj21">
        <div class="bloc1">
          <h3>Clavier <br/>sonore</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro" style="width: 70mm">Dans ce projet nous allons jouer sur l'un des composants essentiels de l'électronique pour faire varier un signal analogique&nbsp;: la résistance. La résistance est la capacité d'un composant à empêcher le passage du courant à travers lui. Plus celle-ci est élevée moins le courant passe. Nous allons donc jouer sur différentes valeurs de résistances pour laisser passer un courant plus ou moins important vers l'Arduino.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="width:40mm">
          <div class="bouton">
            <img src="images/bouton.png" alt="">
          </div>
          <div class="bouton">
            <img src="images/bouton.png" alt="">
          </div>
          <div class="bouton">
            <img src="images/bouton.png" alt="">
          </div>
          <div class="bouton">
            <img src="images/bouton.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>
          <div class="piezo">
            <img src="images/piezo.png" alt="">
          </div>
        </div>
      </div>

      <img class="schema" id="schema01" src="images/clavier.svg" alt="">

      <ol>
        <li>Un piezo buzzer est un petit haut-parleur qui sonne à la fréquence du courant qui lui est envoyée. On le branche entre la broche digitale 8 de l'Arduino et le GND.</li>
        <li>Le premier interrupteur est directement connecté au 5V et au GND via une résistance de 10k Ω.</li>
        <li>Le deuxième interrupteur est connecté au 5V via une résistance de 220 Ω et au GND via une résistance de 10k Ω.</li>
        <li>Le troisième interrupteur est connecté au 5V via une résistance de 10k Ω et au GND via une résistance de 10k Ω.</li>
        <li>Le quatrième interrupteur est connecté au 5V via une résistance de 1M Ω et au GND via une résistance de 10k Ω.</li>
        <li>Sur la même ligne que celle où se rejoignent les sorties des interrupteurs vers le GROUND, branchez un câble que vous irez connecter <br/>à la broche A0 de l'Arduino.</li>
      </ol>

      <h4>Le code</h4>
      <p>Au début du script nous créons un tableau <span class="code">notes[]</span> qui contient 4 fréquences correspondant à 4 notes (do, ré, mi, fa, octave 3) que nous jouerons avec le clavier. Puis nous initialisons un moniteur série. <br/><br/>Nous utilisons dans ce projet une broche analogique (A0) pour lire la tension transitant par des composants non-analogiques, les interrupteurs. Selon la valeur de la résistance que nous avons placée en entrée de chaque interrupteur, la tension que laisse passer chaque interrupteur est proportionnelle à cette résistance. Plus la valeur de la résistance est grande, moins la tension qui passera de l'interrupteur à l'Arduino est grande, ce qui nous permet d'établir un ordre de grandeur.</p>



      <pre class="prenb pre01">
        <span class="type">int</span> notes[] = {262,294,330,349};

        <span class="type">void</span> <span class="fonction">setup()</span> {
          <span class="type">Serial</span>.<span class="fonction">begin</span>(9600);
        }
      </pre>

      <p>La logique de notre boucle conditionnelle dans la fonction <span class="code">loop()</span> est donc la suivante&nbsp;: si la valeur lue par A0 est égale à 1023, c'est qu'aucune résistance ne se trouve sur le circuit, donc on est en train de presser le premier interrupteur, et la pre-mière note du tableau <span class="code">notes[]</span> est jouée par le piezo. Ensuite les différentes valeurs de résistances entrent en jeu pour obtenir une valeur correspondant à chaque interrupteur. Ainsi le deuxième interrupteur envoie un signal pouvant aller de 990 à 1010, le troisième de 505 à 515, et le dernier de 5 à 10&nbsp;; avec une note différente jouée dans chaque cas de figure. Enfin si aucune des valeurs recherchées dans les conditions n'est lue par l'Arduino, on demande au piezo de ne jouer aucune note.</p>

      <pre class="prenb">
        <span class="type">void</span> <span class="fonction">loop()</span> {
          <span class="type">int</span> keyVal = <span class="fonction">analogRead</span>(A0);
          <span class="type">Serial</span>.<span class="fonction">println</span>(keyVal);

          <span class="type">if</span>(keyVal == 1023) {
            <span class="fonction">tone</span>(8, notes[0]);
          } <span class="type">else if</span>(keyVal >= 990
          && keyVal <= 1010){
            <span class="fonction">tone</span>(8, notes[1]);
          } <span class="type">else if</span>(keyVal >= 505
          && keyVal <= 515){
            <span class="fonction">tone</span>(8, notes[2]);
          } <span class="type">else if</span>(keyVal >= 5
          && keyVal <= 10){
            <span class="fonction">tone</span>(8, notes[3]);
          } <span class="type">else</span> {
            <span class="fonction">noTone</span>(8);
          }
        }
      </pre>


      <div class="page_blanche">

      </div>

      <div class="projet" id="pj22">
        <div class="bloc1">
          <h3>Potentiomètre <br/>+ servo moteur</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro" style="width:70mm">Nous allons utiliser notre premier moteur, un servo. Ce type de moteur peut tourner sur un angle allant de 0 à 180°. L'IDE possède nativement une librairie pour contrôler les servo moteurs, qui nous permet de leur envoyer l'angle auquel nous voulons les voir tourner. Nous allons coupler le contrôle de notre moteur à un potentiomètre afin que l'angle du moteur soit proportionnel à la position du curseur du potentiomètre.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="width:40mm">
          <div class="potentiometre">
            <img src="images/potentiometre.png" alt="">
          </div>
          <div class="servo">
            <img src="images/servo.png" alt="">
          </div>
          <div class="condensateur">
            <img src="images/condensateur.png" alt="">
          </div>
          <div class="condensateur">
            <img src="images/condensateur.png" alt="">
          </div>

        </div>
      </div>

      <img class="schema" id="schema02" src="images/servopot.svg" alt="">

      <ol>
        <li>On connecte le potentiomètre au 5V et au GND ainsi que sa patte du milieu à la broche A0.</li>
        <li>N'oubliez pas d'ajouter un condensateur de 100µF entre les deux pattes reliées à l'alimentation du potentiomètre. Ces composants sont polarisés, la bande sérigraphiée indique le côté négatif. Un condensateur est un composant qui stocke de l'énergie&nbsp;: il se charge de courant puis le relâche quand il a atteint sa capacité maximale. Dans notre circuit, les condensateurs serviront à lisser les signaux électriques du côté du potentiomètre et du servo moteur.</li>
        <li>Reliez le câble rouge du servo au 5V et le noir au GND, avec un condensateur de 100µF reliant les deux. Le troisième câble doit être relié à la broche digitale 9 de l'Arduino.</li>
      </ol>

      <h4>Le code</h4>
      <p>Pour contrôler un servo moteur, la librairie <span class="code">Servo</span> nous fournit les méthodes dont nous allons avoir besoin. L'appel d'une librairie se fait grâce au mot-clé <span class="code">#include</span>, suivi du nom de fichier de la librairie (on peut faire l'import depuis l'IDE Arduino, dans l'onglet <span class="code">Croquis</span> &gt; <span class="code">Inclure une bibliothèque</span>). Ensuite pour associer la librairie <span class="code">Servo</span> à notre moteur branché sur l'Arduino, nous créons un objet <span class="code">Servo myServo;</span> grâce auquel nous pouvons appliquer les méthodes de la librairie au moteur. Enfin nous initialisons la variable de la pin du potentiomètre et créons deux variables qui stockeront respectivement la valeur envoyée par le potentiomètre et l'angle du servo.</p>
      <p class="expl_code">Utiliser un servo requiert que nous initialisions la broche du servo dans le <span class="code">setup()</span> à l'aide de la fonction <span class="code">myServo.attach()</span>, <br/>où le numéro entre parenthèse est celui de la pin reliée au câble de signal du moteur.</p>


      <pre class="prenb pre01">
        <span class="type">#include</span> &lt;Servo.h&gt;

        <span class="type">Servo</span> myServo;

        <span class="type">int const</span> potPin = A0;
        <span class="type">int</span> potVal;
        <span class="type">int</span> angle;
      </pre>


      <pre id="pre08">
        <span class="type">void</span> <span class="fonction">setup()</span> {
          myServo.<span class="fonction">attach</span>(9);
          <span class="type">Serial</span>.<span class="fonction">begin</span>(9600);
        }
      </pre>

      <p>Le corps du script consiste à lire en continu la valeur envoyée par le potentiomètre et à transposer celle-ci de sa valeur analogique comprise entre 0 et 1023 vers un angle possible pour le servo, entre 0 et 180. Nous réalisons cette opération grâce à la fonction <span class="code">map()</span>. Cet angle compréhensible par le moteur étant stocké dans la variable <span class="code">angle</span>, nous envoyons l'ordre au servo de se positionner à cet angle avec la fonction <span class="code">myServo.write(angle)</span>. <br/><br/>Chargez le script sur l'Arduino et observez comment bouge le moteur lorsque vous faîtes varier le potentiomètre.</p>

      <pre class="prenb">
        <span class="type">void</span> <span class="fonction">loop()</span> {
          potVal = <span class="fonction">analogRead</span>(potPin);
          <span class="type">Serial</span>.<span class="fonction">print</span>("Valeur potentiomètre : ");
          <span class="type">Serial</span>.<span class="fonction">print</span>(potVal);
          angle = <span class="fonction">map</span>(potVal, 0, 1023, 0, 179);
          <span class="type">Serial</span>.<span class="fonction">println</span>(". Angle : ");
          <span class="type">Serial</span>.<span class="fonction">println</span>(angle);
          myServo.<span class="fonction">write</span>(angle);
          <span class="fonction">delay</span>(15);
        }
      </pre>

      <div class="page_blanche">

      </div>

      <div class="projet" id="pj24">
        <div class="bloc1">
          <h3>Pont en H</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro">Utiliser un moteur à courant continu (moteur CC) avec l'Arduino requiert un circuit plus complexe car celui-ci doit être alimenté avec plus de tension que celle qu'un Arduino peut produire. Avec un pont en H, on va séparer la partie du circuit gérant le moteur de ce qui est directement connecté à l'Arduino. <br/>Un retour de courant supérieur à 5V sur la carte Arduino la grillerait, c'est pourquoi nous devons procéder ainsi.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="width:40mm">
          <div class="bouton">
            <img src="images/bouton.png" alt="">
          </div>
          <div class="bouton">
            <img src="images/bouton.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>
          <div class="potentiometre">
            <img src="images/potentiometre.png" alt="">
          </div>
          <div class="l293d">
            <img src="images/l293d.png" alt="">
          </div>
          <div class="moteurcc">
            <img src="images/moteurcc.png" alt="">
          </div>

        </div>
      </div>

      <img class="schema" id="schema04" src="images/ponth.svg" alt="">

      <ol>
        <li>On branche la breadboard d'un côté au 5V, <br/>de l'autre à la pile de 9V. Les GROUND des deux côtés du circuit doivent être reliés.</li>
        <li>Les interrupteurs doivent tous les deux être branchés en entrée sur le 5V, et en sortie, <br/>du côté du 5V aux broches digitales 4 et 5 de l'Arduino, du côté du 9V au GND via des résistances de 10k Ω (pour empêcher un retour de courant dans les interrupteurs qui sont à cheval entre les deux côtés du circuit).</li>
        <li>Le potentiomètre doit être alimenté par le 5V et relié à la broche A0 de l'Arduino.</li>
        <li>Le circuit intégré nous permet de relier deux circuits de tension et d'intensité différente tout en isolant chaque partie. Une encoche à sa surface indique son sens. <br/>Du côté droit, la première broche du CI doit être reliée au 5V. Du côté gauche, la première broche se connecte à la pin 9 de l'Arduino, <br/>et la deuxième à la pin 3. Nous branchons le moteur dans les troisième et sixième broches du côté gauche. Les quatrième et cinquième broches de ce côté du CI sont à relier au GND. Toujours de ce côté la septième broche va dans la pin digitale 2 de l'Arduino, et la huitième dans le 9V.</li>
      </ol>

      <h4>Le code</h4>
      <p>Pour commencer le script, on déclare un certain nombre de variables. Prenons-les dans l'ordre. <span class="code">controlPin1</span> et <span class="code">controlPin2</span> déterminent les broches de contrôle du CI reliées aux pins de l'Arduino. <span class="code">enablePin</span> contient le numéro de la broche Arduino reliée à la broche du circuit intégré qui contrôlera l'activation du moteur. Ensuite nous initialisons les pins connectées aux deux interrupteurs avec <span class="code">directionPin</span> et <span class="code">onOffPin</span>, et le potentiomètre sur la A0. Toutes les variables suivantes nous permettront à chaque tour de boucle de la fonction <span class="code">loop()</span> de stocker l'état des interrupteurs, d'activation du moteur, de sa vitesse et de sa direction afin de pouvoir passer d'un état à son contraire s'il y a eu un changement.</p>
      <p class="expl_code">Dans la fonction <span class="code">setup()</span> on initialise l'état de toutes les pins que nous venons de déclarer&nbsp;: les deux interrupteurs sont des <span class="code">INPUT</span>, les pins connectées au circuit intégré sont des <span class="code">OUTPUT</span>. On initialise également le valeur de <span class="code">enablePin</span> sur <span class="code">LOW</span>, afin que le moteur soit éteint au lancement du script.</p>

      <pre class="prenb pre01">
        <span class="type">const int</span> controlPin1 = 2;
        <span class="type">const int</span> controlPin2 = 3;
        <span class="type">const int</span> enablePin = 9;
        <span class="type">const int</span> directionPin = 4;
        <span class="type">const int</span> onOffPin = 5;
        <span class="type">const int</span> potPin = A0;

        <span class="type">int</span> onOff = 0;
        <span class="type">int</span> previousOnOff = 0;
        <span class="type">int</span> direction = 0;
        <span class="type">int</span> previousDirection = 0;

        <span class="type">int</span> motorEnabled = 0;
        <span class="type">int</span> motorSpeed = 0;
        <span class="type">int</span> motorDirection = 1;
      </pre>

      <pre id="pre09">
        <span class="type">void</span> setup() {
          <span class="fonction">pinMode</span>(directionPin, INPUT);
          <span class="fonction">pinMode</span>(onOffPin, INPUT);
          <span class="fonction">pinMode</span>(controlPin1, OUTPUT);
          <span class="fonction">pinMode</span>(controlPin2, OUTPUT);
          <span class="fonction">pinMode</span>(enablePin, OUTPUT);

          <span class="fonction">digitalWrite</span>(enablePin, LOW);
        }
      </pre>

      <p>Dans la <span class="code">loop()</span>, on commence par lire en continu les valeurs des interrupteurs et du potentiomètre (celle-ci est directement stockée dans la variable <span class="code">motorSpeed</span>). <br/>Comme nous avons initialisé les états des boutons à 0, nous pouvons savoir dans la <span class="code">loop()</span> si ces états ont changé depuis le démarrage du script (donc si les boutons sont pressés) en comparant les valeurs actuelles des interrupteurs à leurs valeurs originelles de 0. <br/>Si ces valeurs ne sont plus égales à 0, alors on inverse les valeurs de <span class="code">motorEnabled</span> et de <span class="code">motorDirection</span>, qui passent de ce fait à 1. Puis, dans deux boucles conditionnelles <span class="code">if()</span>, qui vérifient si <span class="code">motorEnabled</span> et <span class="code">motorDirection</span> valent 1, on va pouvoir commander le moteur. Si <span class="code">motorDirection</span> vaut 1, on envoie du courant dans le circuit intégré dans un sens, sinon dans l'autre. <br/>Si <span class="code">motorEnabled</span> vaut 1, on envoie un signal analogique à la broche d'activation du <br/>circuit intégré ainsi que la valeur de <span class="code">motorSpeed</span>, ce qui aura pour conséquence de mettre en mouvement le moteur à la vitesse donnée.<br/>Enfin à la fin de chaque tour de boucle <span class="code">loop()</span> on donne à <span class="code">previousOnOff</span> et <span class="code">previousDirection</span> les valeurs actuelles <br/>de <span class="code">onOff</span> et de <span class="code">direction</span>, pour pouvoir comparer ces valeurs au tour suivant.</p>

      <pre class="prenb">
        <span class="type">void</span> loop() {
          onOff = <span class="fonction">digitalRead</span>(onOffPin);
          <span class="fonction">delay</span>(1);
          direction = <span class="fonction">digitalRead</span>(directionPin);

          motorSpeed = <span class="fonction">analogRead</span>(potPin) / 4;

          <span class="type">if</span>(onOffState != previousOnOff) {
            <span class="type">if</span>(onOffState == HIGH) {
              motorEnabled = !motorEnabled;
            }
          }

          <span class="type">if</span>(direction != previousDirection) {
            <span class="type">if</span>(direction == HIGH) {
              motorDirection = !motorDirection;
            }
          }

          <span class="type">if</span>(motorDirection == 1) {
            <span class="fonction">digitalWrite</span>(controlPin1, HIGH);
            <span class="fonction">digitalWrite</span>(controlPin2, LOW);
          } <span class="type">else</span> {
            <span class="fonction">digitalWrite</span>(controlPin1, LOW);
            <span class="fonction">digitalWrite</span>(controlPin2, HIGH);
          }

          <span class="type">if</span>(motorEnabled == 1) {
            <span class="fonction">analogWrite</span>(enablePin, motorSpeed);
          } <span class="type">else</span> {
            <span class="fonction">analogWrite</span>(enablePin, 0);
          }
          previousDirection = direction;
          previousOnOff = onOff;
        }
      </pre>


      <div class="page_blanche">

      </div>

      <div class="projet" id="pj26">
        <div class="bloc1">
          <h3>Mini station <br/>météo</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro">Un écran LCD est très intéressant à utiliser avec un Arduino si on lui fait afficher les valeurs lues par des capteurs. Cela rend le projet public et appréhendable par des personnes n'ayant aucunement pris part à la programmation. <br/>On peut faire une station météo basique avec un capteur de température et un écran LCD.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="width:40mm">
          <div class="temperature">
            <img src="images/temperature.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>
          <div class="potentiometre">
            <img src="images/potentiometre.png" alt="">
          </div>

          <div class="lcd">
            <img src="images/lcd.png" alt="">
          </div>

        </div>
      </div>

      <img class="schema" id="schema08" src="images/temp_lcd.svg" alt="">

      <ol>
        <li>Le capteur de température a un sens&nbsp;: <br/>son côté plat face à vous, branchez la patte de gauche dans le 5V, celle de droite dans le GND, et celle du milieu à la broche A0 de l'Arduino.</li>
        <li>Ensuite, le branchement de l'écran LCD&nbsp;: <br/>en partant de la gauche, les deux premières broches de l'écran doivent être reliées au GND et au 5V. <br/>La troisième broche doit être reliée à la patte du milieu d'un potentiomètre (connecté au 5V et au GND de son côté), cela nous permet de régler le contraste de l'écran. <br/>La quatrième broche est reliée à la broche digitale 12 de l'Arduino. <br/>La cinquième va dans le GND. <br/>La sixième se connecte à la broche 11 de <br/>l'Arduino. <br/>Les onzième à quatorzième broche de l'écran sont à relier respectivement aux broches digitales 5 à 2 de l'Arduino. <br/>La quinzième broche est connectée au 5V au travers d'une résistance de 220 Ω, et la seizième broche doit être raccordée au GROUND.</li>
      </ol>

      <h4>Le code</h4>
      <p>Dans le script on doit tout d'abord appeler la librairie <span class="code">LiquidCrystal</span> pour communiquer avec l'écran LCD, puis initialiser les broches que nous utiliserons pour l'envoi d'informations. Nous déclarons également <br/>la broche du capteur et initialisons la valeur de la température à 0.</p>
      <p class="expl_code">Dans le <span class="code">setup()</span> on a simplement besoin de définir le mode de l'écran (16 caractères par ligne, 2 lignes) et de déclarer la broche du capteur comme <span class="code">INPUT</span>.</p>
      <p class="expl_code" id="p04">On lit la valeur du capteur de température, valant entre 0 et 1023, qu'on divise par 1024 et multiplie par la tension du circuit (5V), puis on retire 0.5 et multiplie par 100 pour avoir une température en degrés Celsius.<br/>La valeur que nous envoyons à l'écran LCD doit être une chaîne de caractères, c'est pourquoi nous créons la <span class="code"> String phrase</span> à laquelle nous passons et convertissons en texte la valeur <span class="code">celsius</span>. Puis nous envoyons la phrase à l'écran via <span class="code">lcd.print()</span>, en rafraîchissant toutes les 10 milli-secondes.</p>

      <pre class="prenb pre01">
        <span class="type">#include</span> &lt;LiquidCrystal.h&gt;

        <span class="type">LiquidCrystal</span> lcd(12, 11, 5, 4, 3, 2);

        <span class="type">const int</span> sensorPin = A0;
        <span class="type">int</span> temperature = 0;
      </pre>

      <pre id="pre13">
        <span class="type">void</span> <span class="fonction">setup()</span> {
          lcd.<span class="fonction">begin</span>(16, 2);
          <span class="type">Serial</span>.<span class="fonction">begin</span>(9600);
          <span class="fonction">pinMode</span>(sensorPin, INPUT);
        }
      </pre>

      <pre>
        <span class="type">void</span> <span class="fonction">loop()</span> {
          temperature = <span class="fonction">analogRead</span>(sensorPin);
          float voltage = (temperature/1024.0)*5.0;
          float celsius = (voltage - .5) * 100;
          <span class="type">String</span> phrase;
          phrase += "Il fait ";
          phrase += <span class="type">String</span>(celsius);
          phrase += "\xB0";
          phrase += "C";
          lcd.<span class="fonction">print</span>(phrase);
          <span class="fonction">delay</span>(10);
          lcd.<span class="fonction">clear()</span>;
          <span class="type">Serial</span>.println(phrase);
        }
      </pre>


      <img src="images/01.jpg" class="img_full_page" id="img_fp01" alt="">


      <div class="projet" id="pj28">
        <div class="bloc1">
          <h3>Shield moteur <br/>+ photo-<br/>résistance</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro">Pour commencer avec les shields, la toute première étape est de comprendre que les shields sont des ajouts à votre Arduino, mais ils ne constituent pas des cartes programmables seules. Vous devez donc brancher votre shield sur votre Arduino, venir le mettre dessus (les broches d'un shield viennent s'encastrer parfaitement dans celles de l'Arduino).</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="width:35mm">
          <div class="moteurcc">
            <img src="images/moteurcc.png" alt="">
          </div>
          <div class="photoresistance">
            <img src="images/photoresistance.png" alt="">
          </div>
          <div class="moteurcc">
            <img src="images/moteurcc.png" alt="">
          </div>


        </div>
      </div>

      <img class="schema" id="schema06" src="images/shield1.svg" alt="">

      <ol>
        <li>Une fois le shield installé sur l'Arduino, nous pouvons commencer le montage. Le shield moteur possède sa propre source d'alimentation indépendante de celle de l'Arduino, <br/>on peut donc brancher une pile de 9V dans les broches VIN et GND du shield sans craindre de griller l'Arduino en-dessous.</li>
        <li>Si vous prenez le temps d'observer le shield, vous pouvez lire différentes informations sur ses broches&nbsp;: certaines sont marquées «&nbsp;Servo&nbsp;», d'autres «&nbsp;M1&nbsp;», «&nbsp;M2&nbsp;», etc. En effet le shield peut contrôler les trois grands types de moteurs&nbsp;: servo, courant continu et moteur pas-à-pas. Pour notre projet nous utiliserons deux moteurs à courant continu, branchés chacun sur l'une des entrées numérotée «&nbsp;M1&nbsp;» et «&nbsp;M2&nbsp;». Ces entrées comportent à la fois une alimentation et un GND, vous n'avez qu'à mettre un câble dans l'une des broches et l'autre dans la seconde.</li>
        <li>Enfin connectez la photorésistance entre la broche 5V (qui est directement liée celle du 5V de l'Arduino) et la pin A0.</li>
      </ol>

      <h4>Le code</h4>
      <p>Ce modèle de shield moteur est fabriqué par Adafruit et requiert l'appel à la librairie <span class="code">Adafruit_MotorShield</span> en plus de la librairie <span class="code">Wire</span> (car le shield communique avec l'Arduino via le protocole I2C). Nous devons ensuite déclarer un objet <span class="code">Adafruit_Motor<br/>Shield</span> que nous nommons <span class="code">AFMS</span> pour pouvoir communiquer avec le shield. <br/>La librairie <span class="code">Adafruit_MotorShield</span> inclut nativement les différents types de moteurs&nbsp;; étant donné que nous avons deux moteurs à courant continu, nous devons déclarer deux objets <span class="code">Adafruit_DCMotor</span> associés à la fonction <span class="code">AFMS.getMotor()</span>, dont l'argument est le port sur lequel est branché le moteur. Sur notre circuit ils sont respectivement sur les ports M1 et M2, d'où les arguments 1 et 2 ici présents. Puis nous initialisons la pin de la photorésistance sur l'A0.</p>



      <pre class="prenb pre01">
        <span class="type">#include</span> &lt;Wire.h&gt;
        <span class="type">#include</span> &lt;Adafruit_MotorShield.h&gt;

        <span class="type">Adafruit_MotorShield</span> AFMS =
        <span class="type">Adafruit_MotorShield()</span>;

        <span class="type">Adafruit_DCMotor</span> *myMotor1 =
        AFMS.<span class="fonction">getMotor</span>(1);
        <span class="type">Adafruit_DCMotor</span> *myMotor2 =
        AFMS.<span class="fonction">getMotor</span>(2);

        <span class="type">int</span> photo = A0;
      </pre>

      <p>Dans le <span class="code">setup()</span> nous faisons démarrer le shield (<span class="code">AFMS.begin();</span>). Puis nous initialisons les moteurs en les faisant simplement tourner puis s'arrêter une première fois à la vitesse de 150.</p>
      <p class="expl_code" id="p02">Pour le reste, nous utilisons la photorésistance comme régulateur de la vitesse des moteurs. En effet en lisant perpétuellement cette valeur et en la passant aux moteurs via la fonction <span class="code">setSpeed()</span>, nous indexons <br/>la vitesse des moteurs sur la luminosité perçue par le capteur. Nous différencions ensuite l'action des deux moteurs en faisant tourner le premier à l'endroit et le second à l'envers.</p>

      <pre class="prenb">
        <span class="type">void</span> <span class="fonction">setup()</span> {
          <span class="fonction">pinMode</span>(bouton, INPUT);
          <span class="type">Serial</span>.begin(9600);

          AFMS.<span class="fonction">begin()</span>;

          myMotor1-><span class="fonction">setSpeed</span>(150);
          myMotor1-><span class="fonction">run</span>(FORWARD);
          myMotor1-><span class="fonction">run</span>(RELEASE);

          myMotor2-><span class="fonction">setSpeed</span>(150);
          myMotor2-><span class="fonction">run</span>(FORWARD);
          myMotor2-><span class="fonction">run</span>(RELEASE);
        }
      </pre>


      <pre>
        <span class="type">void</span> <span class="fonction">loop()</span> {
          <span class="type">int</span> speed = <span class="fonction">analogRead</span>(photo);

          <span class="type">Serial</span>.<span class="fonction">println</span>(speed);

          myMotor1-><span class="fonction">setSpeed</span>(speed);
          myMotor1-><span class="fonction">run</span>(FORWARD);

          myMotor2-><span class="fonction">setSpeed</span>(speed);
          myMotor2-><span class="fonction">run</span>(BACKWARD);
        }
      </pre>


      <div class="page_blanche">

      </div>

      <div class="projet" id="pj29">
        <div class="bloc1">
          <h3>Shields <br/>moteur <br/>imbriqués</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro">La plupart des shields Arduino sont imbriquables. Dans le cas de shields moteur, l'imbrication permet de contrôler un nombre plus important de moteurs depuis une seule carte Arduino.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="width:35mm">
          <div class="stepper">
            <img src="images/stepper.png" alt="">
          </div>
          <div class="moteurcc">
            <img src="images/moteurcc.png" alt="">
          </div>
          <div class="moteurcc">
            <img src="images/moteurcc.png" alt="">
          </div>


        </div>
      </div>

      <img class="schema" id="schema07" src="images/shield2.svg" alt="">

      <ol>
        <li>Sur le shield du haut, branchez la pile de 9V aux bornes VIN et GND, et le moteur pas-à-pas sur les ports M1 et M2. Attention à bien respecter la polarité (les câbles noirs sur le «&nbsp;-&nbsp;», les rouges sur le «&nbsp;+&nbsp;»).</li>
        <li>Sur le shield à l'étage en-dessous, branchez un moteur à courant continu sur le port M1, <br/>et un autre sur le port M2. </li>
        <li>Une fois que les deux shields sont bien empilés l'un sur l'autre et sur l'Arduino, le montage est complet.</li>
      </ol>

      <h4>Le code</h4>
      <p>On commence le script par importer les librairies <span class="code">Wire</span> et <span class="code">Adafruit_MotorShield</span> qui permettront à l'Arduino et aux shields de bien communiquer. Ensuite, comme les deux shields communiquent avec l'Arduino par le protocole I2C, nous devons attribuer une adresse différente à chacun des shields, pour que l'Arduino sache à quel appareil il doit envoyer de l'information. Le shield du bas est donc nommé <span class="code">AFMSbot</span> et a pour adresse <span class="code">0x60</span>, celui du haut est appelé par <span class="code">AFMStop</span> et a pour adresse <span class="code">0x61</span>.<br/>Maintenant que nous avons différencié les deux shields, nous pouvons agir avec chacun séparément. On déclare deux moteurs CC sur le shield du bas, connectés aux ports M1 et M2. Pour le shield du haut, on déclare un objet <span class="code">Adafruit_Stepper<br/>Motor</span> à l'aide de la fonction <span class="code">AFMStop.<br/>getStepper(200, 2)</span>.</p>




      <pre class="prenb pre01">
        <span class="type">#include</span> &lt;Wire.h&gt;
        <span class="type">#include</span> &lt;Adafruit_MotorShield.h&gt;

        <span class="type">Adafruit_MotorShield</span> AFMSbot =
        <span class="type">Adafruit_MotorShield(0x60)</span>;
        <span class="type">Adafruit_MotorShield</span> AFMStop =
        <span class="type">Adafruit_MotorShield(0x61)</span>;

        <span class="type">Adafruit_DCMotor</span> *myMotor1 = AFMSbot.<span class="fonction">getMotor</span>(1);
        <span class="type">Adafruit_DCMotor</span> *myMotor2 = AFMSbot.<span class="fonction">getMotor</span>(2);

        <span class="type">Adafruit_StepperMotor</span> *myStepper =
        AFMStop.<span class="fonction">getStepper</span>(200, 2);
      </pre>

      <p>Dans la fonction <span class="code">setup()</span>, on fait démarrer les deux shields, puis on initialise les deux moteurs à courant continu en définissant la vitesse de chacun et en les activant brièvement.</p>
      <p class="expl_code" id="p03">La fonction <span class="code">loop()</span> fait tourner les deux moteurs CC, chacun dans un sens. Quant au moteur pas-à-pas, on le fait tourner selon différentes phases, avec différents pas. Chargez la boucle sur l'Arduino et observez comment les différentes combinaisons font tourner le moteur pas-à-pas.</p>

      <pre class="prenb">
        <span class="type">void</span> <span class="fonction">setup()</span> {
          AFMSbot.<span class="fonction">begin()</span>;
          AFMStop.<span class="fonction">begin()</span>;

          myMotor1-><span class="fonction">setSpeed</span>(50);
          myMotor1-><span class="fonction">run</span>(FORWARD);
          myMotor1-><span class="fonction">run</span>(RELEASE);

          myMotor2-><span class="fonction">setSpeed</span>(150);
          myMotor2-><span class="fonction">run</span>(FORWARD);
          myMotor2-><span class="fonction">run</span>(RELEASE);
        }
      </pre>

      <pre>
        <span class="type">void</span> <span class="fonction">loop()</span> {
          myMotor1-><span class="fonction">setSpeed</span>(50);
          myMotor1-><span class="fonction">run</span>(FORWARD);

          myMotor2-><span class="fonction">setSpeed</span>(50);
          myMotor2-><span class="fonction">run</span>(BACKWARD);

          myStepper-><span class="fonction">step</span>(100, FORWARD, SINGLE);
          myStepper-><span class="fonction">step</span>(100, BACKWARD, SINGLE);

          myStepper-><span class="fonction">step</span>(100, FORWARD, DOUBLE);
          myStepper-><span class="fonction">step</span>(100, BACKWARD, DOUBLE);

          myStepper-><span class="fonction">step</span>(100, FORWARD, INTERLEAVE);
          myStepper-><span class="fonction">step</span>(100, BACKWARD, INTERLEAVE);

          myStepper-><span class="fonction">step</span>(50, FORWARD, MICROSTEP);
          myStepper-><span class="fonction">step</span>(50, BACKWARD, MICROSTEP);
        }
      </pre>


      <div class="page_blanche">

      </div>

      <div class="projet" id="pj30">
        <div class="bloc1">
          <h3>Datalogging <br/>shield</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro" style="width:65.25mm;">Le datalogging shield offre la possibilité d'enregistrer sur une carte SD les valeurs lues par des capteurs reliés à un Arduino. Nous allons ici mener un petit projet de statistiques météo en sauvegardant au format CSV les valeurs de température, de taux d'humidité et de luminosité perçus par un capteur DHT et une photorésistance.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage">
          <div class="dht">
            <img src="images/dht.png" alt="">
          </div>
          <div class="photoresistance">
            <img src="images/photoresistance.png" alt="">
          </div>


        </div>
      </div>

      <img class="schema" src="images/datalogger_meteo.svg" alt="">

      <ol>
        <li>Un capteur DHT est un composant qui combine un capteur de température précis et un capteur d'humidité. Le modèle que nous utilisons est un DHT22, il possède 4 pattes. <br/>La première est à connecter au 5V, la deuxième est celle qui transfère l'information et est à relier à la broche digitale 7 de l'Arduino. La quatrième patte est à brancher au GROUND.</li>
        <li>La photorésistance elle est simplement à brancher entre le 5V et la broche A0.</li>
      </ol>

      <h4>Le code</h4>
      <p>Nous devons faire appel à de nombreuses librairies pour ce projet. Tout d'abord <span class="code">SPI</span> et <span class="code">Wire</span> qui serviront à la communication I2C entre l'Arduino et le shield. Ensuite la librairie <span class="code">SD</span> pour gérer l'écriture sur la carte SD. Les librairies <span class="code">Time</span>, <span class="code">RTClib</span> et <span class="code">RTC_DS3231</span> nous serviront à mettre l'Arduino à l'heure afin d'horodater les données dans le fichier créé. Enfin nous appelons la librairie <span class="code">DHT</span> pour interagir avec ce capteur. <br/><span class="code">LOG_INTERVAL</span> détermine l'intervalle en milli-secondes entre chaque lecture&nbsp;; quant à la constante <span class="code">ECHO_TO_SERIAL</span>, ici initialisée à 1, nous l'utilisons comme une valeur booléenne qui nous permet d'activer ou non la copie des données dans le moniteur série. <br/>Ensuite nous initialisons les pins des capteurs. Le type de capteur doit être déclaré (<span class="code">DHTTYPE</span>), et un objet <span class="code">DHT</span> prenant pour arguments la pin du capteur et son type est créé. On créé également un objet <span class="code">RTC_DS3231</span> qui nous servira pour l'horodatage. La variable <span class="code">chipSelect</span> est nécessaire au bon fonctionnement du datalogging shield, il s'agit de la broche qu'utilise le port de la carte SD du shield pour communiquer avec l'Arduino. Par défaut cette pin est la 10.</p>




      <pre class="prenb pre01">
        <span class="type">#include</span> &lt;SPI.h&gt;
        <span class="type">#include</span> &lt;Wire.h&gt;
        <span class="type">#include</span> &lt;SD.h&gt;
        <span class="type">#include</span> &lt;Time.h&gt;
        <span class="type">#include</span> "RTClib.h"
        <span class="type">#include</span> &lt;DS1307RTC.h&gt;
        <span class="type">#include</span> &lt;DHT.h&gt;

        <span class="type">#define</span> LOG_INTERVAL  5000
        <span class="type">#define</span> ECHO_TO_SERIAL   1

        <span class="type">#define</span> DHTPIN 7
        <span class="type">#define</span> DHTTYPE DHT22
        <span class="type">#define</span> LIGHTPIN A0

        <span class="type">DHT</span> dht(DHTPIN, DHTTYPE);
        <span class="type">RTC_DS3231</span> rtc;

        <span class="type">const int</span> chipSelect = 10;
        <span class="type">float</span> humReading;
        <span class="type">float</span> tempReading;
        <span class="type">int</span> light;
      </pre>

      <p>On commence par initialiser la pin de la photorésistance et par démarrer le capteur DHT. Ensuite, on laisse 3 secondes (3000 milli-secondes) pour que la carte SD s'initialise. On vérifie également que la RTC a démarré, et si celle-ci s'est déreglée (<span class="code">if (rtc.lostPower()){}</span>), on peut la réinitialiser à partir d'une date et d'une heure rentrées manuellement à l'aide de la fonction <span class="code">rtc.adjust()</span>.</p>


      <pre class="prenb">
        <span class="type">void</span> <span class="fonction">setup()</span> {
          <span class="type">Serial</span>.<span class="fonction">begin</span>(9600);
          <span class="fonction">pinMode</span>(LIGHTPIN, INPUT);
          dht.<span class="fonction">begin()</span>;

          <span class="fonction">delay</span>(3000);

          <span class="type">Serial</span>.<span class="fonction">print</span>("Initializing SD card...");

          <span class="type">if</span>(!SD.<span class="fonction">begin</span>(chipSelect)) {
            <span class="type">Serial</span>.<span class="fonction">println</span>("Card failed,
            or not present");
            <span class="type">while</span>(1);
          }
          <span class="type">Serial</span>.<span class="fonction">println</span>("card initialized.");

          <span class="type">if</span>(! rtc.<span class="fonction">begin()</span>) {
            <span class="type">Serial</span>.<span class="fonction">println</span>("Couldn't find RTC");
            <span class="type">while</span>(1);
          }

          <span class="type">if</span>(rtc.<span class="fonction">lostPower()</span>) {
            <span class="type">Serial</span>.<span class="fonction">println</span>("RTC lost power,
            lets set the time!");
            rtc.<span class="fonction">adjust</span>(<span class="fonction">DateTime</span>(2020, 04, 11,
            00, 48, 30));
          }
        }
      </pre>

      <p>
        Il est à présent temps de passer à l'action dans la <span class="code">loop()</span>. Nous voulons horodater selon l'heure actuelle, donc nous initialisons la RTC au bon format et à l'heure UTC avec la fonction <span class="code">rtc.now()</span>. Juste après, on dit à la boucle <span class="code">loop()</span> d'attendre la valeur définie dans <span class="code">LOG_INTERVAL</span> avant chaque tour. Nous commençons par enregistrer les valeurs lues par le capteur DHT dans deux variables. On obtient la température avec <span class="code">dht.read<br/>Temperature()</span> et le taux d'humidité avec <span class="code">dht.readHumidity()</span>. Pour la luminosité, on lit la valeur analogique du capteur avant de la transposer vers une valeur comprise entre 0 et 100, car nous voulons en faire un pourcentage.<br/>Une fois les valeurs récupérées, on peut les passer à la carte SD. Pour cela on crée un objet <span class="code">File</span> que l'on initialise dans la ligne <span class="code">File logfile = SD.open("meteo.csv", FILE_WRITE);</span>. À partir du moment où ce fichier est bien créé, donc s'il existe, on lui transfère les valeurs avec la fonction <span class="code">logfile.print()</span>. Nous envoyons d'abord l'horodatage au format «&nbsp;AAAA/MM/JJ HH:MM&nbsp;». Nous écrivons un fichier CSV, les valeurs doivent donc être séparées par des virgules. C'est pourquoi nous écrivons dans le fichier des virgules entre l'horodatage et chacune des trois valeurs&nbsp;; de cette façon ces 4 données apparaîtront dans des cellules différentes dans le fichier CSV final.
      </p>

      <pre class="prenb">
        <span class="type">void</span> <span class="fonction">loop()</span> {
          rtc.<span class="fonction">adjust(<span class="fonction">DateTime</span></span>(F(__DATE__),
          F(__TIME__)));
          <span class="type">DateTime</span> now = rtc.<span class="fonction">now()</span>;

          <span class="fonction">delay</span>(LOG_INTERVAL);

          humReading = dht.<span class="fonction">readHumidity()</span>;
          tempReading = dht.<span class="fonction">readTemperature()</span>;
          light = <span class="fonction">analogRead</span>(A0);
          int lightVal = <span class="fonction">map</span>(light, 0, 1023,
          0, 93);

          <span class="type">File</span> logfile = SD.<span class="fonction">open</span>("meteo.csv",
          FILE_WRITE);

          <span class="type">if</span>(logfile) {
            logfile.<span class="fonction">print</span>(now.<span class="fonction">year()</span>, DEC);
            logfile.<span class="fonction">print</span>("/");
            logfile.<span class="fonction">print</span>(now.<span class="fonction">month()</span>, DEC);
            logfile.<span class="fonction">print</span>("/");
            logfile.<span class="fonction">print</span>(now.<span class="fonction">day()</span>, DEC);
            logfile.<span class="fonction">print</span>(" ");
            logfile.<span class="fonction">print</span>(now.<span class="fonction">hour()</span>, DEC);
            logfile.<span class="fonction">print</span>(":");
            logfile.<span class="fonction">print</span>(now.<span class="fonction">minute()</span>, DEC);
            logfile.<span class="fonction">print</span>(", ");
            logfile.<span class="fonction">print</span>(tempReading);
            logfile.<span class="fonction">print</span>(", ");
            logfile.<span class="fonction">print</span>(humReading);
            logfile.<span class="fonction">print</span>(", ");
            logfile.<span class="fonction">print</span>(lightVal);
            logfile.<span class="fonction">print</span>("\n ");
            logfile.<span class="fonction">close()</span>;
        </pre>

        <p class="expl_nn">Pour créer une nouvelle ligne dans le fichier à chaque tour de la <span class="code">loop()</span>, on envoie à chaque fois au fichier CSV le caractère «&nbsp;\n&nbsp;» (retour à la ligne). Si le fichier CSV n'a pas correctement été créé on retourne simplement un message d'erreur.<br/>Notez que toutes les instruction comprises entre les lignes <span class="code">#if ECHO_TO_SERIAL</span> et <span class="code">#endif</span> peuvent être désactivées si la valeur de <span class="code">ECHO_TO_SERIAL</span> est passée à 0. <br/><br/>Quand on a laissé tourner le script suffisamment longtemps pour avoir un volume de données satisfaisant, on peut récupérer le fichier CSV sur la carte SD, l'ouvrir avec un tableur et manipuler les données.</p>
        <pre class="prenb">
            <span class="type">#if</span> ECHO_TO_SERIAL
              <span class="type">Serial</span>.<span class="fonction">print</span>(now.<span class="fonction">year()</span>);
              <span class="type">Serial</span>.<span class="fonction">print</span>("/");
              <span class="type">Serial</span>.<span class="fonction">print</span>(now.<span class="fonction">month()</span>);
              <span class="type">Serial</span>.<span class="fonction">print</span>("/");
              <span class="type">Serial</span>.<span class="fonction">print</span>(now.<span class="fonction">day()</span>);
              <span class="type">Serial</span>.<span class="fonction">print</span>(" ");
              <span class="type">Serial</span>.<span class="fonction">print</span>(now.<span class="fonction">hour()</span>);
              <span class="type">Serial</span>.<span class="fonction">print</span>(":");
              <span class="type">Serial</span>.<span class="fonction">print</span>(now.<span class="fonction">minute()</span>);
              <span class="type">Serial</span>.<span class="fonction">print</span>(", ");
              <span class="type">Serial</span>.<span class="fonction">print</span>(tempReading);
              <span class="type">Serial</span>.<span class="fonction">print</span>(", ");
              <span class="type">Serial</span>.<span class="fonction">println</span>(humReading);
              <span class="type">Serial</span>.<span class="fonction">print</span>(", ");
              <span class="type">Serial</span>.<span class="fonction">println</span>(lightVal);
            <span class="type">#endif</span>
          } <span class="type">else</span> {
            <span class="type">Serial</span>.<span class="fonction">println</span>("error opening file");
          }
        }
      </pre>

      <img class="img_full_page" src="images/meteo_csv.png" alt="">


      <div class="projet" id="pj31">
        <div class="bloc1">
          <h3>Arduino + <br/>Processing&nbsp;: <br/>transmission <br/>par le port <br/>série</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <img src="images/Processing_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro" style="width:86mm">Les projets Arduino et Processing sont très proches car ils sont issus des mêmes créateurs. Processing est une interface de programmation permettant de créer des visuels génératifs, qui se connecte facilement avec Arduino. Si Arduino gère les interactions avec le monde réel via des capteurs, Processing peut mettre en image ces interactions.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="width:20mm">
          <div class="potentiometre">
            <img src="images/potentiometre.png" alt="">
          </div>


        </div>
      </div>

      <img class="schema" src="images/arduino_to_processing.svg" alt="">

      <ol>
        <li>Faisons un petit circuit pour comprendre <br/>comment Processing et Arduino peuvent communiquer de la manière la plus simple possible. Branchez simplement un potentiomètre à la pin A0 de l'Arduino, au 5V et au GROUND.</li>
      </ol>

      <h4 style="width:80mm">Le code Arduino</h4>
      <p class="expl_nn">Ce script lit la valeur envoyée par le potentiomètre et la passe au moniteur série. <br/>C'est tout pour ce que l'Arduino a à faire dans ce projet, pour la suite on passe à Processing.</p>


      <pre class="prenb pre01">
        <span class="type">int</span> pot = A0;
        <span class="type">int</span> valeur = 0;

        <span class="type">void</span> <span class="fonction">setup()</span> {
          <span class="type">Serial</span>.<span class="fonction">begin</span>(9600);
          <span class="fonction">pinMode</span>(pot, INPUT);
        }

        <span class="type">void</span> <span class="fonction">loop()</span> {
          valeur = <span class="fonction">analogRead</span>(pot);
          <span class="type">Serial</span>.<span class="fonction">println</span>(valeur);
          <span class="fonction">delay</span>(100);
        }
      </pre>

      <h4 style="width:80mm">Le code Processing</h4>
      <p>Nous voici dans l'IDE Processing. <br/>La programmation en Processing est basée sur le langage Java. Nous commençons par appeler une librairie, <span class="code">processing.serial</span>, afin d'utiliser le port série. On initialise quelques variables&nbsp;: <span class="code">lf</span> est le nombre de caractères par ligne que Processing devra lire dans le port série, <span class="code">myString</span> la chaîne de caractères qui stockera la valeur lue dans le port série (la valeur numérique récupérée dans le port série est une chaîne de caractères), <span class="code">myPort</span> le port série, et <span class="code">num</span> la valeur envoyée par Arduino dans le port série reconvertie en chiffre.</p>
      <p class="expl_code">
        Processing a également une fonction <span class="code">setup()</span>, qui a le même rôle que la fonction du même nom dans Arduino. La fonction <span class="code">size()</span> initialise la taille de la fenêtre. <br/>On démarre le port série à un baudrate de 9600 (le même que le port série démarré avec le script Arduino), puis on vide une première fois le port série avec <span class="code">myPort.<br/>clean()</span>. Les fonctions <span class="code">colorMode()</span> et <span class="code">background()</span> déterminent le profil colorimétrique et la couleur de fond de la fenêtre.
      </p>

      <pre class="prenb pre01">
        <span class="type">import</span> processing.serial.*;

        <span class="type">int</span> lf = 10;
        <span class="type">String</span> myString = null;
        <span class="type">Serial</span> myPort;
        <span class="type">float</span> num;
      </pre>

      <pre id="pre14">
        <span class="type">void</span> <span class="fonction">setup()</span> {
          <span class="fonction">size</span>(600, 400);
          myPort = new <span class="type">Serial</span>(this,
          <span class="type">Serial</span>.<span class="fonction">list()</span>[0], 9600);
          myPort.<span class="fonction">clear()</span>;
          <span class="fonction">colorMode</span>(RGB, 100);
          <span class="fonction">background</span>(0, 0, 0);
        }
        </pre>

        <p>La fonction <span class="code">draw()</span> de Processing est équivalente à la fonction <span class="code">loop()</span> d'Arduino. <br/>Ce que nous y faisons c'est, tant que le port série précédemment déclaré est disponible, stocker la valeur qu'on y trouve dans <span class="code">myString</span>. Ainsi la valeur de <span class="code">myString</span> qui était initialement égale à <span class="code">null</span> change, et si cette condition est vraie (<span class="code">if (myString != null){}</span>), alors on reconvertit la valeur contenue dans <span class="code">myString</span> en nombre avec la fonction <span class="code">float(myString)</span> et on dessine dans la fenêtre Processing trois cercles, un cyan, un magenta, un jaune. Les diamètres de ces cercles varient en fonction de la valeur envoyée par le potentiomètre branché sur l'Arduino puisque le troisième argument des fonctions <span class="code">circle()</span> est <span class="code">num</span>, <span class="code">num/2</span> et <span class="code">num/3</span>&nbsp;; nous faisons donc dépendre les diamètres des cercles de la valeur lue en continu dans le port série.</p>
        <pre class="prenb">
        <span class="type">void</span> <span class="fonction">draw()</span> {
          <span class="type">while</span>(myPort.<span class="fonction">available()</span> > 0) {
            myString = myPort.<span class="fonction">readStringUntil</span>(lf);
            <span class="type">if</span>(myString != null) {
              <span class="fonction">num = float</span>(myString);
              <span class="fonction">println</span>(num);
              <span class="fonction">fill</span>(255, 100, 0);
              <span class="fonction">circle</span>(100, 100, num);
              <span class="fonction">fill</span>(0, 255, 100);
              <span class="fonction">circle</span>(500, 300, num/2);
              <span class="fonction">fill</span>(100, 0, 255);
              <span class="fonction">circle</span>(300, 200, num/3);
            }
          }
          myPort.<span class="fonction">clear()</span>;
        }
      </pre>

      <img src="images/ard_proc.png" class="img_full_page" alt="">

      <div class="projet" id="pj32">
        <div class="bloc1">
          <h3>Message OSC</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <img src="images/Processing_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro" style="width:76mm">L'OSC (Open Sound Control) est un modèle de transmission de données entre ordinateurs qui se compose d'une adresse, d'une chaîne de caractères de type et d'arguments. Processing possède une librairie OSC qui permet de lire et d'envoyer des messages OSC. Nous allons connecter Processing et Arduino afin de faire s'illuminer une LED chaque fois qu'un message OSC avec un argument donné est envoyé depuis Processing.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage" style="width:30mm">
          <div class="led">
            <img src="images/led_rouge.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>


        </div>
      </div>

      <img class="schema" src="images/osc_message.svg" alt="">

      <ol>
        <li>Pour le montage Arduino, branchez simplement une LED sur la pin digitale 13 de votre carte.</li>
      </ol>

      <h4 style="width:80mm">Le code Arduino</h4>
      <p class="expl_nn">Dans le code Arduino nous initialisons la LED et un port série, mais à la différence de la manière dont nous avons utilisé le port série jusqu'à maintenant, nous n'allons ici pas y écrire de l'information mais y lire des données envoyées par Processing. Nous pouvons faire cela à l'aide de la fonction <span class="code">Serial.read()</span>. À noter que nous lisons les données du port série en byte, et ce afin de convertir directement la valeur numérique lue dans le port en byte, qui est une unité valable pour l'alimentation de la LED. Si le port série est disponible (<span class="code">if (Serial.<br/>available()) {}</span>), nous lisons ce qui y est écrit et faisons clignoter la LED avec une intensité égale à la valeur stockée dans <span class="code">val</span>.</p>


      <pre class="prenb pre01">
        <span class="type">int</span> ledPin = 13;

        <span class="type">void</span> <span class="fonction">setup()</span>{
          <span class="type">Serial</span>.<span class="fonction">begin</span>(9600);
          <span class="fonction">pinMode</span>(ledPin, OUTPUT);
        }

        <span class="type">void</span> <span class="fonction">loop()</span>{
          <span class="type">byte</span> val;

          <span class="type">if</span>(<span class="type">Serial</span>.<span class="fonction">available()</span>) {
            val = <span class="type">Serial</span>.<span class="fonction">read()</span>;
            <span class="fonction">analogWrite</span>(ledPin, val);
            <span class="fonction">delay</span>(1000);
            <span class="fonction">analogWrite</span>(ledPin, 0);
            <span class="fonction">delay</span>(1000);
          }
        }
      </pre>

      <h4 style="width:80mm">Le code Processing</h4>
      <p>Dans Processing, en plus de la librairie <span class="code">processing.serial</span> qui gère la communication avec le port série, nous devons ici importer les librairies <span class="code">oscP5</span> et <span class="code">netP5</span> qui gèreront respectivement le format de message OSC et les adresses NET (nécessaires à l'envoi de messages OSC). Nous déclarons ensuite tous les objets dont nous allons avoir besoin&nbsp;: <span class="code">OscP5</span> pour le message OSC en soi, <span class="code">NetAddress</span> pour stocker les adresses d'envoi et de destination, un <span class="code">Serial</span> pour y envoyer les valeurs numériques à destination d'Arduino.</p>
      <p class="expl_code">
        Dans le <span class="code">setup()</span>, nous initialisons l'objet <span class="code">oscP5</span> à un baudrate de 12000. La NetAddress <span class="code">myRemoteLocation</span> contient l'adresse IP à laquelle vous voulez envoyer des messages, elle doit se situer sur le même baudrate que l'<span class="code">OscP5</span>. La communication série sur ce baudrate sera propre aux messages OSC via Processing&nbsp;; pour l'interaction avec Arduino on initialise un autre port série à 9600 bauds.
      </p>

      <pre class="prenb pre01">
        <span class="type">import</span> oscP5.*;
        <span class="type">import</span> netP5.*;
        <span class="type">import</span> processing.serial.*;

        <span class="type">OscP5</span> oscP5;
        <span class="type">NetAddress</span> myRemoteLocation;
        <span class="type">Serial</span> myPort;
        <span class="type">int</span> lf = 10;
        <span class="type">String</span> myString = null;
        <span class="type">float</span> num;
      </pre>

      <pre id="pre15">
        <span class="type">void</span> <span class="fonction">setup()</span> {
          <span class="fonction">size</span>(400, 400);
          oscP5 = new <span class="type">OscP5</span>(this, 12000);
          myRemoteLocation =
          new <span class="type">NetAddress</span>("....", 12000);
          myPort = new <span class="type">Serial</span>(this,
          <span class="type">Serial</span>.<span class="fonction">list()</span>[0], 9600);
          myPort.<span class="fonction">clear()</span>;
        }
        </pre>

        <p>Voici le corps du script Processing. À partir du moment où notre port série <span class="code">myPort</span> à 9600 bauds est disponible, nous lisons ce qui s'y passe et dessinons dans la fenêtre Processing un carré dont les dimensions sont proportionnelles à la valeur lue dans le port série. Comme vous pouvez le constater, la boucle <span class="code">draw()</span> ne gère pas l'envoi de messages OSC. Nous voulons dans ce projet qu'un message OSC soit envoyé quand on clique dans la fenêtre Processing, pour parvenir à cela nous devons créer une fonction supplémentaire dans le script.</p>
        <p class="expl_code">Nous avons créé notre propre fonction <span class="code">mousePressed()</span> qui, comme son nom l'indique gère l'évènement «&nbsp;click&nbsp;» dans la fenêtre Processing. Celle-ci crée un nouveau message OSC dont l'argument est «&nbsp;ledON&nbsp;», auquel on ajoute une valeur de 255. Enfin, avec la fonction <span class="code">oscP5.send()</span> on envoie le message à l'adresse stockée dans la variable <span class="code">myRemoteLocation</span>. Voilà pour l'envoi du message OSC. <br/>On inclut dans le script une fonction gérant l'action des messages OSC, <span class="code">oscEvent()</span>, afin de vérifier que tout est correct.</p>

        <pre class="prenb">
        <span class="type">void</span> <span class="fonction">draw()</span> {
          if (myPort.<span class="fonction">available()</span> > 0) {
            myString = myPort.<span class="fonction">read()</span>;
            <span class="fonction">rect</span>(0, 0, val, val);
          }
        }
      </pre>
      <pre id="pre16">
        <span class="type">void</span> <span class="fonction">mousePressed()</span> {
          <span class="type">OscMessage</span> myMessage =
          new <span class="type">OscMessage</span>("/ledON");
          myMessage1.<span class="fonction">add</span>(255);
          oscP5.<span class="fonction">send</span>(myMessage, myRemoteLocation);
        }

        <span class="type">void</span> <span class="fonction">oscEvent</span>(<span class="type">OscMessage</span> theOscMessage) {
          <span class="fonction">print</span>("### received an osc message.");
          <span class="fonction">print</span>(" addrpattern: "+theOscMessage.addrPattern());
          <span class="fonction">println</span>(" typetag: "+theOscMessage.typetag());
          <span class="type">if</span>(theOscMessage.<span class="fonction">checkTypetag</span>("i")) {
            println(" typetag: "
            +theOscMessage.<span class="fonction">get</span>(0).<span class="fonction">intValue()</span>);
          }
        }
      </pre>


      <div class="page_blanche">

      </div>

      <div class="projet" id="pj33">
        <div class="bloc1">
          <h3>Firmata</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <img src="images/Processing_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro">Firmata est un protocole de communication entre Arduino et Processing. Il permet de rendre l'Arduino «&nbsp;esclave&nbsp;» de Processing, c'est-à-dire que nous pourrons interagir avec des capteurs et lui donner des ordres depuis l'IDE Processing.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage">
          <div class="bouton">
            <img src="images/bouton.png" alt="">
          </div>
          <div class="bouton">
            <img src="images/bouton.png" alt="">
          </div>
          <div class="temperature">
            <img src="images/temperature.png" alt="">
          </div>
          <div class="photoresistance">
            <img src="images/photoresistance.png" alt="">
          </div>

          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>
          <div class="potentiometre">
            <img src="images/potentiometre.png" alt="">
          </div>


        </div>
      </div>

      <img class="schema" style="margin-left:4mm;" src="images/arduino_firmata1.svg" alt="">

      <ol>
        <li>Dans ce projet, nous allons contrôler cinq composants connectés à l'Arduino depuis Processing. Tout d'abord deux interrupteurs, l'un relié au 5V et à la pin 9, l'autre relié au 5V et à la pin 10.</li>
        <li>On place un potentiomètre sur le circuit, qui doit être branché sur ses extrémités au 5V et au GND, sur sa patte du milieu à l'A0.</li>
        <li>Ensuite un capteur de température, à brancher au 5V à gauche (quand son côté plat est face à vous), au GND à droite et à l'A1 sur sa patte du milieu.</li>
        <li>Pour terminer une photorésistance, connectée au 5V à travers une résistance de 10k Ω et à la broche A2 de l'Arduino.</li>
      </ol>

      <h4 style="width:80mm">Le code Arduino</h4>
      <p class="expl_nn">Pour ce qui est du code à téléverser sur la carte Arduino, Firmata est un protocole pré-existant que nous n'avons pas à réécrire. Tout ce que nous avons à faire dans ce projet du côté de l'Arduino est d'y téléverser le protocole Firmata. Pour ce faire, dans l'IDE Arduino, allez dans <span class="code">Fichier</span> > <span class="code">Exemples</span> > <span class="code">Firmata</span> > <span class="code">StandardFirmata</span>. Une fois ce code ouvert, téléversez-le sur votre Arduino. Et c'est tout pour Arduino.
      <br/><br/>Le téléversement de ce code sur l'Arduino rend la carte entièrement contrôlable depuis Processing, c'est là que nous allons scripter les actions demandées à l'Arduino.</p>


      <img class="img_tuto" src="images/firmata_exemple.png" alt="">

      <h4 style="width:80mm;">Le code Processing</h4>
      <p>Dans Processing, on importe <span class="code">processing.<br/>serial</span> pour pouvoir utiliser le port série et <span class="code">cc.arduino</span>, la librairie qui nous permet de contrôler l'Arduino fonctionnant sous le protocole Firmata. On crée donc un objet <span class="code">Arduino</span> pour avoir accès à ses méthodes. Ensuite, comme on le ferait dans l'IDE Arduino, on initialise les variables qui vont stocker les pins de chaque composant ainsi que les valeurs à lire. À noter que pour les composants connectés aux broches analogiques de l'Arduino (le potentiomètre, le capteur de température et la photorésistance) on les déclare à ce stade seulement par leur numéro&nbsp;: <span class="code">0</span>, <span class="code">1</span> et <span class="code">2</span>, là où dans l'IDE Arduino on aurait déclaré <span class="code">A0</span>, <span class="code">A1</span> et <span class="code">A2</span>.</p>
      <p class="expl_code">
        Au démarrage du script on initialise l'objet <span class="code">Arduino</span> à un baudrate de 57600. Ensuite, comme on le ferait dans la fonction <span class="code">setup()</span> d'Arduino, on déclare le mode des pins. <br/>La seule différence est que l'on doit ajouter le préfixe <span class="code">arduino</span> aux fonctions. Ici comme on veut récupérer les valeurs des capteurs et l'état des interrupteurs, toutes les pins sont des <span class="code">INPUT</span>.
      </p>

      <pre class="prenb pre01">
        <span class="type">import</span> processing.serial.*;
        <span class="type">import</span> cc.arduino.*;

        <span class="type">Arduino</span> arduino;

        <span class="type">color</span> back = <span class="fonction">color</span>(64, 218, 255);

        <span class="type">int</span> pot = 0;
        <span class="type">int</span> temp = 1;
        <span class="type">int</span> photo = 2;
        <span class="type">int</span> button1 = 9;
        <span class="type">int</span> button2 = 10;
        <span class="type">int</span> read_pot;
        <span class="type">int</span> read_temp;
        <span class="type">int</span> read_photo;
        <span class="type">int</span> read_button1;
        <span class="type">int</span> read_button2;
      </pre>

      <pre id="pre17">
        <span class="type">void</span> <span class="fonction">setup()</span> {
          <span class="fonction">size</span>(800, 600);
          arduino = new <span class="type">Arduino</span>(this,
          <span class="type">Arduino</span>.<span class="fonction">list()</span>[0], 57600);
          arduino.<span class="fonction">pinMode</span>(pot, <span class="type">Arduino.INPUT</span>);
          arduino.<span class="fonction">pinMode</span>(temp, <span class="type">Arduino.INPUT</span>);
          arduino.<span class="fonction">pinMode</span>(photo, <span class="type">Arduino.INPUT</span>);
          arduino.<span class="fonction">pinMode</span>(button1, <span class="type">Arduino.INPUT</span>);
          arduino.<span class="fonction">pinMode</span>(button2, <span class="type">Arduino.INPUT</span>);
          <span class="fonction">background</span>(back);
        }
        </pre>

        <p>Dans le corps du script on lit en continu les valeurs de nos capteurs et interrupteurs. <br/>À partir de ces valeurs, on va déclencher des actions dans la fenêtre Processing.<br/>
        Les valeurs données par le potentiomètre et le capteur de température sont ré-échelonnées à l'aide de la fonction <span class="code">map()</span> pour correspondre respectivement à la largeur et à la hauteur maximale de l'écran. La fonction <span class="code">ellipse()</span> de Processing permet de dessiner des cercles ou des ellipses dans la fenêtre en prenant pour arguments la position en X du centre, sa position en Y, son diamètre en X et son diamètre en Y. <br/>En appelant cette fonction avec pour paramètres <span class="code">ellipse(value_pot, value_temp, read_photo, read_photo);</span>, nous dessinons un cercle dans la fenêtre Processing dont la position en X est déterminée par la valeur du potentiomètre, la position en Y par la valeur du capteur de température, et le diamètre par la luminosité captée par la photorésistance.<br/>Puis à l'aide de deux boucles conditionnelles nous vérifions si les interrupteurs sont pressés. Si c'est le cas pour le premier, le fond de la fenêtre devient noir. Si c'est le second bouton qui est pressé, alors le fond prend une couleur déterminée au hasard par <span class="code">random(0,255)</span>.</p>

        <pre class="prenb">
        <span class="type">void</span> <span class="fonction">draw()</span> {
          read_pot = arduino.<span class="fonction">analogRead</span>(pot);
          read_temp = arduino.<span class="fonction">analogRead</span>(temp);
          read_photo = arduino.<span class="fonction">analogRead</span>(photo);
          read_button1 = arduino.<span class="fonction">digitalRead</span>(button1);
          read_button2 = arduino.<span class="fonction">digitalRead</span>(button2);

          <span class="type">float</span> value_pot = <span class="fonction">map</span>(read_pot, 0, 680, 0, width);
          <span class="type">float</span> value_temp = <span class="fonction">map</span>(read_temp, 0,
          600, 0, height);
          <span class="fonction">ellipse</span>(value_pot, value_temp,
          read_photo, read_photo);

          <span class="type">if</span>(read_button1 == 1) {
            <span class="fonction">background</span>(0, 0, 0);
          }
          <span class="type">if</span>(read_button2 == 1) {
            <span class="type">color</span> fond = <span class="fonction">color</span>(<span class="fonction">random</span>(0,255),
            <span class="fonction">random</span>(0,255), <span class="fonction">random</span>(0,255));
            <span class="fonction">fill</span>(fond);
          }
        }
      </pre>


      <div class="page_blanche">

      </div>

      <div class="projet" id="pj34">
        <div class="bloc1">
          <h3>Contrôler un <br/>servo et une <br/>LED depuis <br/>une page web</h3>
          <div class="cadre">
            <div class="num">

            </div>
          </div>
        </div>

        <div class="logo">
          <img src="images/arduino_Logo.png" alt="">
          <div class="blanc_logo">

          </div>
        </div>

        <div class="bloc_intro">
          <p class="intro">Une carte Arduino peut héberger un serveur web pour peu qu'elle possède une carte Wifi. Sur une Arduino Uno on peut mettre un shield Wifi pour lui ajouter cette fonctionnalité, ou bien utiliser une carte Arduino qui possède une carte Wifi intégrée, comme  une ESP8266 que nous allons utiliser dans ce projet.</p>
          <div class="blanc_intro">
          </div>
        </div>
        <div class="remplissage">
          <div class="led">
            <img src="images/led_rouge.png" alt="">
          </div>
          <div class="resistance">
            <img src="images/resistance_220.png" alt="">
          </div>

          <div class="servo">
            <img src="images/servo.png" alt="">
          </div>

        </div>
      </div>

      <img class="schema" id="schema09" src="images/server_controle1.svg" alt="">

      <ol>
        <li>Le montage consiste d'abord à brancher une LED à la pin 12 de l'ESP8266 et au GND à travers une résistance de 220 Ω.</li>
        <li>Ensuite connectez un servo moteur au 5V, <br/>au GND et à la pin 2.</li>
      </ol>

      <h4>Le code</h4>
      <p>Avant de commencer le script, on doit ajouter la carte ESP8266 à la configuration de l'IDE Arduino car celle-ci ne fait pas partie des cartes nativement implémentées. Pour cela, allez dans <span class="code">Fichier</span> > <span class="code">Préférences</span>. Dans le champ «&nbsp;URL de gestionnaire de cartes supplémentaires&nbsp;», ajoutez&nbsp;: <span class="code">http://arduino.esp8266.com/stable/</span> <br/>
        <span class="code">package_esp8266com_index.json</span>.</p>


      <img class="img_tuto" src="images/ard_prefs.png" alt="">

      <p>On aura besoin de trois librairies&nbsp;: <span class="code">Servo</span> pour le moteur, <span class="code">ESP8266WiFi</span> pour gérer la connexion au Wifi et <span class="code">ESP8266WebServer</span> pour faire tourner le serveur local qui hébergera la page web depuis laquelle nous contrôlerons la LED et le moteur. Dans les variables <span class="code">ssid</span> et <span class="code">password</span> remplacez les astérisques par le SSID et le mot de passe de votre réseau Wifi. La ligne <span class="code">ESP8266<br/>WebServer server (80);</span> définit le port du serveur local comme étant le 80 (c'est-à-dire «&nbsp;localhost&nbsp;»). On initialise un objet de type <span class="code">char</span> pour stocker la chaîne de caractères qu'on enverra au serveur.</p>
      <p class="expl_code">La fonction <span class="code">handleRoot()</span> gère la page affichée par le serveur (ce qui est à sa racine, sa «&nbsp;root&nbsp;»). On lui envoie sous forme de chaîne de caractères le contenu HTML de la page. Dans les balises <span class="code">&lt;script&gt;</span> se trouve le code Javascript qui gère l'envoi des requêtes HTTP qui vont allumer et éteindre la LED et faire bouger le moteur. En cliquant sur les éléments HTML ciblés par le Javascript on déclenchera l'envoi d'une requête HTTP par action.</p>

      <pre class="prenb">
        <span class="type">#include</span> &lt;Servo.h&gt;

        <span class="type">#include</span> &lt;ESP8266WiFi.h&gt;
        <span class="type">#include</span> &lt;ESP8266WebServer.h&gt;

        <span class="type">int</span> led1 = 12;
        <span class="type">Servo</span> myServo;
        <span class="type">String</span> val;

        <span class="type">const char*</span> ssid = "****";
        <span class="type">const char*</span> password = "****";

        <span class="type">ESP8266WebServer</span> server (80);

        <span class="type">char</span> htmlResponse[3000];
      </pre>



        <pre id="pre18">
        <span class="type">void</span> <span class="fonction">handleRoot()</span> {
          <span class="fonction">snprintf</span>( htmlResponse, 3000,
          "&lt;!DOCTYPE html&gt;\
          &lt;html lang=\"en\"&gt;\
          &lt;head&gt;\
          &lt;meta charset=\"utf-8\"&gt;\
          &lt;meta name=\"viewport\"\
          content=\"width=device-width,\
          initial-scale=1\"&gt;\
          &lt;/head&gt;\
          &lt;body&gt;\
          &lt;style&gt;\
            body{font-family:Monospace;\
              color:white;background-color:navy;}\
            h1{font-size: 5vw;}\
            button{font-family:Monospace;\
              color:white;background-color:navy;\
        </pre>
        <pre class="prefp" style="margin-left: 0mm;">
              border:2px solid white;\
              font-size: 3vw; margin: 2vw;}\
            button:hover{color: navy;\
              background-color: white;}\
            input{font-family:Monospace;\
              color:white;background-color:navy;\
              border:2px solid white;\
              font-size: 3vw; margin: 2vw;\
              width:30vw;height:20vh}\
          &lt;/style&gt;\
          &lt;div style='width:45vw;height:100vh;\
            display:inline-block;\
            border-right:2px solid white;\
            margin-left: 2vw;'>\
            &lt;h1&gt;Contrôle de la LED&lt;/h1&gt;\
            &lt;button type='button' name='ledon'\
            id='ledon' size=2&gt; Led ON\
            &lt;button type='button' name='ledoff'\
            id='ledoff' size=2&gt; Led OFF\
          &lt;/div&gt;\
          &lt;div class='block' style='left: 50vw;\
          display:inline-block;top:0vh;\
          height:100vh;position:absolute;'&gt;\
            &lt;h1&gt;Contrôle du moteur&lt;/h1&gt;\
            &lt;input type='text' name='servo'\
            id='servo' size=2 autofocus&gt;\
            &lt;div&gt; &lt;br&gt;\
              &lt;button id=\"save_button\"&gt;\
              Envoyer&lt;/button&gt;\
            &lt;/div&gt;\
          &lt;/div&gt;\
          &lt;script src=\"https://ajax
          .googleapis.com/ajax/libs/jquery/\
          1.11.3/jquery.min.js\"&gt;\
          &lt;/script&gt;\
        </pre>
        <pre class="prefp">
          &lt;script&gt;\
            var ledon;\
            var ledoff;\
            var servo;\
            $('#save_button').click(function(e){\
              e.preventDefault();\
              servo = $('#servo').val();\
              $.get('/save?servo=' + servo,\
              function(data){\
                console.log(data);\
              });\
            });\

            $('#ledon').click(function(){\
              ledon = 'ledon';\
              $.get('/save?ledon=' + ledon,\
              function(data){\
                console.log(data);\
              });\
            });\
            $('#ledoff').click(function(){\
              ledoff = 'ledoff';\
              $.get('/save?ledoff=' + ledoff,\
              function(data){\
                console.log(data);\
              });\
            });\
          &lt;/script&gt;\
          &lt;/body&gt;\
          &lt;/html&gt;");

          server.<span class="fonction">send</span>( 200, "text/html",
          htmlResponse );
        }
      </pre>

      <p>La fonction <span class="code">handleSave()</span> gère les requêtes HTTP envoyées au serveur. Nous venons de voir que la page envoie toute seule des requêtes HTTP pour interagir avec la LED et le moteur. Pour savoir avec quel composant on souhaite faire interagir le serveur, on a donné à ces requêtes des arguments différents&nbsp;: «&nbsp;ledon&nbsp;» quand on veut allumer la LED, «&nbsp;ledoff&nbsp;» quand on veut l'éteindre et «&nbsp;servo&nbsp;» quand on veut passer un angle au moteur. Dans cette fonction on vérifie donc la valeur de l'argument de la requête HTTP. Si celui-ci est égal à «&nbsp;ledon&nbsp;», on envoie du courant dans la LED, sinon elle reste éteinte. Si l'argument vaut «&nbsp;ledoff&nbsp;» on éteint la LED. Dans le cas où l'argument est «&nbsp;servo&nbsp;», on envoie la valeur convertie en chiffre au servo moteur qui se déplacera alors à l'angle donné.</p>

       <pre class="prenb">
        <span class="type">void</span> <span class="fonction">handleSave()</span> {
           <span class="type">if</span>(server.<span class="fonction">arg</span>("ledon")!= ""){
             <span class="type">Serial</span>.<span class="fonction">println</span>(server.<span class="fonction">arg</span>("ledon"));
             <span class="fonction">digitalWrite</span>(led1, HIGH);
           } <span class="type">else</span> {
             <span class="fonction">digitalWrite</span>(led1, LOW);
           }

           <span class="type">if</span>(server.<span class="fonction">arg</span>("ledoff")!= ""){
             <span class="type">Serial</span>.<span class="fonction">println</span>(server.<span class="fonction">arg</span>("ledoff"));
             <span class="fonction">digitalWrite</span>(led1, LOW);
           }

           <span class="type">if</span>(server.<span class="fonction">arg</span>("servo")!= ""){
             <span class="type">Serial</span>.<span class="fonction">println</span>(server.<span class="fonction">arg</span>("servo"));
             myServo.<span class="fonction">write</span>(
             (server.<span class="fonction">arg</span>("servo")).<span class="fonction">toInt()</span>);
           }
         }
       </pre>

       <p>La fonction <span class="code">setup()</span> n'intervient que maintenant. Après avoir déclaré nos composants on démarre un moniteur série à 115200 bauds. On fait démarrer la connexion au Wifi avec la fonction <span class="code">WiFi.begin()</span>. Une fois la connexion établie on obtient une adresse IP dans le moniteur série. Le serveur lance alors la fonction <span class="code">handleRoot()</span> qui va charger la page HTML. Il s'apprête également à lancer la fonction <span class="code">handleSave()</span> au cas où les requêtes HTTP contenant les arguments recherchés lui parviennent. Une fois cela fait, le serveur démarre. Pour visualiser la page générée il suffit d'entrer l'adresse IP qui vient de vous être attribuée dans un navigateur.</p>
       <p id="p05" class="expl_code" >Dans la <span class="code">loop()</span> on appelle la fonction <span class="code">server.handleClient()</span> qui gère les connexions à la page.</p>

       <pre class="prenb">
        <span class="type">void</span> <span class="fonction">setup()</span> {
          <span class="fonction">pinMode</span>(led1, OUTPUT);
          myServo.<span class="fonction">attach</span>(2);

          <span class="type">Serial</span>.<span class="fonction">begin</span>(115200);
          <span class="fonction">delay</span>(10);

          <span class="type">Serial</span>.<span class="fonction">print</span>("Connecting to ");
          <span class="type">Serial</span>.<span class="fonction">println</span>(ssid);

          <span class="type">WiFi</span>.<span class="fonction">begin</span>(ssid, password);

          <span class="type">while</span>(<span class="type">WiFi</span>.<span class="fonction">status()</span> != WL_CONNECTED) {
            <span class="fonction">delay</span>(500);
            <span class="type">Serial</span>.<span class="fonction">print</span>(".");
          }

          <span class="type">Serial</span>.<span class="fonction">println</span>("");
          <span class="type">Serial</span>.<span class="fonction">println</span>("WiFi connected");
          <span class="type">Serial</span>.<span class="fonction">println</span>("IP address: ");
          <span class="type">Serial</span>.<span class="fonction">println</span>(<span class="type">WiFi</span>.<span class="fonction">localIP()</span>);

          server.<span class="fonction">on</span>( "/", handleRoot );
          server.<span class="fonction">on</span>("/save", handleSave);

          server.<span class="fonction">begin()</span>;
          <span class="type">Serial</span>.<span class="fonction">println</span>( "HTTP server started" );
        }
       </pre>

       <pre>
         <span class="type">void</span> <span class="fonction">loop()</span> {
           server.<span class="fonction">handleClient()</span>;
         }
       </pre>


       <p class="expl_nn">Rendez vous sur la page, cliquez sur les deux boutons dans le bloc «&nbsp;Contrôle de la LED&nbsp;» et observez comment réagit votre LED reliée à l'ESP8266. Amusez-vous également à envoyer différentes valeurs d'angle au servo moteur.</p>

        <img src="images/server1.png" class="img_full_page" alt="">


        <div class="page_blanche">

        </div>

        <div class="projet" id="pj35">
          <div class="bloc1">
            <h3>Serveur <br/>web météo</h3>
            <div class="cadre">
              <div class="num">

              </div>
            </div>
          </div>

          <div class="logo">
            <img src="images/arduino_Logo.png" alt="">
            <div class="blanc_logo">

            </div>
          </div>

          <div class="bloc_intro">
            <p class="intro">Nous allons dans ce projet créer un serveur sur l'ESP8266 qui nous permettra de lire sur une page web la température, le taux d'humidité et la luminosité captés en en temps réel.</p>
            <div class="blanc_intro">
            </div>
          </div>
          <div class="remplissage">
            <div class="photoresistance">
              <img src="images/photoresistance.png" alt="">
            </div>
            <div class="resistance">
              <img src="images/resistance_220.png" alt="">
            </div>

            <div class="dht">
              <img src="images/dht.png" alt="">
            </div>

          </div>
        </div>

        <img class="schema" id="schema15" src="images/server_controle2.svg" alt="">

        <ol>
          <li>Reliez la photorésistance à la broche analogique de l'ESP8266 (celle-ci varie en fonction du modèle de carte, consultez la datasheet de la carte ESP8266 que vous utilisez pour savoir où elle se trouve) et au 5V à travers une résistance de 10k Ω.</li>
          <li>Pour le capteur DHT22, branchez la patte de gauche dans le 5V, la deuxième patte à la broche 12 de l'ESP8266, et la patte de droite au GND.</li>
        </ol>

        <h4>Le code</h4>

        <p>On débute ce script comme pour le projet précédent&nbsp;: on importe les librairies propres à l'ESP8266 pour qu'il gère la connexion au Wifi et le serveur web. Il faut ici également importer la librairie <span class="code">DHT</span> pour ce capteur, puis on déclare sa pin et son type. <br/>On déclare la pin de la photorésistance, <br/>puis on initialise les codes Wifi et le serveur <span class="code">ESP8266WebServer</span> sur le port 80, enfin on crée déjà la chaîne de caractères <span class="code">html<br/>Response</span> qui contiendra le corps de la <br/>page web.</p>

        <pre class="prenb pre01">
        <span class="type">#include</span> &lt;ESP8266WiFi.h&gt;
        <span class="type">#include</span> &lt;ESP8266WebServer.h&gt;

        <span class="type">#include</span> &lt;DHT.h&gt;

        <span class="type">#define</span> DHTPIN 12
        <span class="type">#define</span> DHTTYPE DHT22
        <span class="type">DHT</span> dht(DHTPIN, DHTTYPE);

        <span class="type">int</span> lightPin = A0;

        <span class="type">const char*</span> ssid = "****";
        <span class="type">const char*</span> password = "****";

        <span class="type">ESP8266WebServer</span> server (80);

        <span class="type">char</span> htmlResponse[3000];
        </pre>

        <p>On fait tenir dans la fonction <span class="code">handleRoot</span> ce qui va être envoyé à la racine du serveur, la page web. Le contenu est écrit en HTML, avec du CSS placé dans les balises <span class="code">&lt;style&gt;</span> et du Javascript pour gérer la mise à jour des données. Nous voulons que notre serveur affiche les valeurs lues par nos capteurs en temps réel, ce qui implique une mise à jour très fréquente de la page. Cette mise à jour doit se faire aussi bien du côté du serveur (l'ESP8266 qui lit les capteurs) que du côté client (vous qui vous connectez au serveur). Avec le Javascript écrit dans le HTML on gère la mise à jour de la page web côté client. Nous y avons écrit trois fonctions, <span class="code">getTemp()</span>, <span class="code">getHum()</span> et <span class="code">getLight()</span>, une par valeur, dont les rôles sont de continuellement envoyer des requêtes HTTP au serveur pour lui demander ce que valent au moment précis de la requête les valeurs. Pour ce faire, chaque fonction envoie un argument dans sa requête HTTP («&nbsp;temperature&nbsp;», «&nbsp;humidite&nbsp;» ou «&nbsp;luminosite&nbsp;») auquel le serveur réagira en conséquence pour chaque requête. Pour que l'affichage des valeurs sur la page web se mette à jour en continu, on sélectionne en Javascript les balises HTML qui les contiennent à l'aide de la fonction <span class="code">document.getElementById()</span>, <br/>et définit leurs contenus par les valeurs des capteurs que le serveur vient d'envoyer.</p>

        <pre class="prenb">
        <span class="type">void</span> <span class="fonction">handleRoot()</span> {
          <span class="fonction">snprintf</span>( htmlResponse, 3000,
          "&lt;!DOCTYPE html&gt;\
          &lt;html&gt;\
            &lt;head&gt;\
              &lt;meta charset='UTF-8'&gt;\
            &lt;/head&gt;\
            &lt;style&gt;\
              body {\
                margin: 0;\
              }\
              .card{\
                background: white;\
                padding: 0px;\
                color: navy;\
                box-shadow: 0px 2px 18px -4px\
                rgba(0,0,0,0.75);\
                font-family: monospace;\
                font-size: 5vw;\
                width: 100vw;\
              }\
              .card &gt; div {\
                width: 100vw !important;\
                border-top: 1px solid navy;\
                margin: 0;\
                display:flex;\
                flex-direction: row;\
              }\
              .card &gt; div &gt; p {\
                padding: 2vw;\
                text-align: left;\
                border-right: 1px solid navy;\
                margin: 0;\
                background-color:white;\
                width: auto;\
              }\
          </pre>
          <pre class="prefp" style="margin-left: 0mm;height:200mm;">
              h1{\
                font-size: 5vw;\
                padding: 2vw;\
                text-align: left;\
                font-family: monospace;\
                margin: 0;\
                color: navy;\
              }\
              .titre{\
                border-right: 1px dashed navy;\
                width:49vw;\
                color:mediumseagreen;\
              }\
            &lt;/style&gt;\
            &lt;body&gt;\
              &lt;h1&gt;Météo Arduino&lt;/h1&gt;\
              &lt;div class='card'&gt;\
                &lt;div id='t'&gt;\
                  &lt;p class='titre'&gt;\
                    Température (°C)&lt;/p&gt;\
                    &lt;p id='temp'&gt;0&lt;/p&gt;\
                    &lt;/div&gt;\
                    &lt;div id='h'&gt;\
                  &lt;p class='titre'&gt;\
                    Humidité (pourcent)\
                  &lt;/p&gt;\
                  &lt;p id='hum'>0&lt;/p&gt;\
                &lt;/div&gt;\
                &lt;div id='l'&gt;\
                  &lt;p class='titre'&gt;\
                    Luminosité (pourcent)\
                  &lt;/p&gt;\
                  &lt;p id='lum'&gt;0&lt;/p&gt;\
                &lt;/div&gt;\
              &lt;/div&gt;\
          </pre>
          <pre class="prefp">
            &lt;script&gt;\
              let t = document.getElementById('t');\
              let h = document.getElementById('h');\
              let l = document.getElementById('l');\
              setInterval(function() {\
                getTemp();\
                getHum();\
                getLight();\
              }, 5000); \
              function getTemp() {\
                var xhttp = new XMLHttpRequest();\
                xhttp.onreadystatechange = function() {\
                  if(this.readyState == 4\
                  && this.status == 200) {\
                    document.getElementById('temp')
                    .innerHTML = this.responseText;\
                    if(Number(this.responseText)<= 17){\
                      t.style.backgroundColor =\
                      'azure';\
                    } else if(Number(this.responseText)\
                    > 17 && Number(this.responseText)\
                    <= 24){\
                      t.style.backgroundColor =\
                      'lightgreen';\
                    } else {\
                      t.style.backgroundColor =\
                      'tomato';\
                    };\
                  };\
                };\
                xhttp.open('GET',
                'temperature', true);\
                xhttp.send();\
              };\
        </pre>
        <pre class="prefp" style="margin-left: 0mm;">
              function getHum() {\
                var xhttp =
                new XMLHttpRequest();\
                xhttp.onreadystatechange = function() {\
                  if(this.readyState == 4\
                  && this.status == 200) {\
                    document.getElementById('hum')
                    .innerHTML = this.responseText;\
                    if(Number(this.responseText)> 60) {\
                      h.style.backgroundColor =\
                      'aquamarine';\
                    } else {\
                      h.style.backgroundColor =
                      'khaki';\
                    }\
                  };\
                };\
                xhttp.open('GET', 'humidite', true);\
                xhttp.send();\
              };\
              function getLight() {\
                var xhttp = new XMLHttpRequest();\
                xhttp.onreadystatechange = function() {\
                  if(this.readyState == 4\
                  && this.status == 200) {\
                    document.getElementById('lum')
                    .innerHTML = this.responseText;\
                  };\
                };\
                xhttp.open('GET', 'luminosite', true);\
                xhttp.send();\
              };\
              &lt;/script&gt;\
            &lt;/body&gt;\
          &lt;/html&gt;" );
        </pre>
        <pre class="prefp">
          server.<span class="fonction">send</span>( 200, "text/html",
          htmlResponse );
        }
        </pre>

        <p>Côté serveur, ce sont les fonctions <span class="code">send<br/>Temp()</span>, <span class="code">sendHum()</span> et <span class="code">sendLight()</span> qui seront en charge de constituer les réponses aux requêtes HTTP envoyées depuis le côté client. Chacune de ces fonctions lit la valeur qu'on veut récupérer (la température et l'humidité sur le DHT, la luminosité sur la photorésistance) et répond à la requête qui lui correspond en passant la valeur qui vient d'être lue.</p>

         <pre class="prenb">
        <span class="type">void</span> <span class="fonction">sendTemp()</span> {
          <span class="type">int</span> t = dht.<span class="fonction">readTemperature()</span>;
          <span class="type">String</span> tempValue = <span class="fonction">String</span>(t);
          server.<span class="fonction">send</span>(200, "text/plane", tempValue);
        }

        <span class="type">void</span> <span class="fonction">sendHum()</span> {
          <span class="type">int</span> h = dht.<span class="fonction">readHumidity()</span>;
          <span class="type">String</span> humValue = <span class="fonction">String</span>(h);
          server.<span class="fonction">send</span>(200, "text/plane", humValue);
        }

        <span class="type">void</span> <span class="fonction">sendLight()</span> {
          <span class="type">int</span> l = <span class="fonction">analogRead</span>(lightPin);
          <span class="type">int</span> lv = <span class="fonction">map</span>(l, 0, 1023, 0, 100);
          <span class="type">String</span> lightValue = <span class="fonction">String</span>(lv);
          server.<span class="fonction">send</span>(200, "text/plane", lightValue);
        }
         </pre>

         <p>Au démarrage du script, on initialise et on fait démarrer les capteurs et on lance la connexion au Wifi. <br/>Chose essentielle pour le bon fonctionnement de notre serveur en temps réel, on définit ses routes&nbsp;: avec <span class="code">server.on ( "/", handleRoot );</span> on dit au serveur de lancer la fonction <span class="code">handleRoot()</span> à sa racine (ce qui chargera le contenu de la page web), avec <span class="code">server.on ("/temperature", sendTemp );</span>, <span class="code">server.on ("/humidite", sendHum );</span> et <span class="code">server.on ("/luminosite", sendLight );</span> on dit au serveur de lancer respectivement les fonctions <span class="code">sendTemp()</span>, <span class="code">sendHum()</span> et <span class="code">sendLight()</span> lorsque les arguments «&nbsp;/temperature&nbsp;», «&nbsp;/humidite&nbsp;» et «&nbsp;/luminosite&nbsp;» lui parviennent. Une fois tout ceci initialisé, on peut démarrer le serveur avec <span class="code">server.begin()</span>.</p>
         <p class="expl_code" id="p06">On ne demande à la fonction <span class="code">loop()</span> que de gérer les connexions de clients au serveur.</p>

         <pre class="prenb">
        <span class="type">void</span> <span class="fonction">setup()</span> {
          <span class="fonction">pinMode</span>(lightPin, INPUT);
          <span class="type">Serial</span>.<span class="fonction">begin</span>(115200);
          <span class="fonction">delay</span>(10);

          dht.<span class="fonction">begin()</span>;

          <span class="type">Serial</span>.<span class="fonction">print</span>("Connecting to ");
          <span class="type">Serial</span>.<span class="fonction">println</span>(ssid);

          <span class="type">WiFi</span>.<span class="fonction">begin</span>(ssid, password);

          <span class="type">while</span>(<span class="type">WiFi</span>.<span class="fonction">status()</span> != WL_CONNECTED) {
            <span class="fonction">delay</span>(500);
            <span class="type">Serial</span>.<span class="fonction">print</span>(".");
          }

          <span class="type">Serial</span>.<span class="fonction">println</span>("WiFi connected");
          <span class="type">Serial</span>.<span class="fonction">println</span>("IP address: ");
          <span class="type">Serial</span>.<span class="fonction">println</span>(WiFi.localIP());

          <span class="type">server</span>.<span class="fonction">on</span>( "/", handleRoot );
          <span class="type">server</span>.<span class="fonction">on</span>("/temperature", sendTemp );
          <span class="type">server</span>.<span class="fonction">on</span>("/humidite", sendHum );
          <span class="type">server</span>.<span class="fonction">on</span>("/luminosite", sendLight );

          server.<span class="fonction">begin()</span>;
          <span class="type">Serial</span>.<span class="fonction">println</span>( "HTTP server started" );
        }
         </pre>

         <pre>
           <span class="type">void</span> <span class="fonction">loop()</span> {
             server.<span class="fonction">handleClient()</span>;
           }
         </pre>

          <img src="images/server2.png" class="img_full_page" id="img_fp02" alt="">



        <div class="projet" id="pj37">
          <div class="bloc1">
            <h3>Adafruit <br/>Flora + <br/>NeoPixels</h3>
            <div class="cadre">
              <div class="num">

              </div>
            </div>
          </div>

          <div class="logo">
            <img src="images/arduino_Logo.png" alt="">
            <div class="blanc_logo">

            </div>
          </div>

          <div class="bloc_intro">
            <p class="intro">La carte Flora, du fabricant Adafruit, est une carte à micro-contrôleur dont les broches sont percées de telle sorte qu'on peut coudre la carte sur du textile avec du fil conducteur. On va lui relier une bande de NeoPixels (ou un ruban LED) que l'on va faire s'éclairer selon différents schémas.</p>
            <div class="blanc_intro">
            </div>
          </div>
          <div class="remplissage">
            <div class="neopixel">
              <img src="images/neopixel.png" alt="">
            </div>
            <div class="neopixel">
              <img src="images/neopixel.png" alt="">
            </div>
            <div class="neopixel">
              <img src="images/neopixel.png" alt="">
            </div>
            <div class="neopixel">
              <img src="images/neopixel.png" alt="">
            </div>
            <div class="neopixel">
              <img src="images/neopixel.png" alt="">
            </div>
            <div class="neopixel">
              <img src="images/neopixel.png" alt="">
            </div>
            <div class="neopixel">
              <img src="images/neopixel.png" alt="">
            </div>
            <div class="neopixel">
              <img src="images/neopixel.png" alt="">
            </div>

          </div>
        </div>

        <img class="schema" id="schema17" src="images/flora_neopixel.svg" alt="">

        <ol>
          <li>Il faut faire attention à bien monter la bande NeoPixel dans le bon sens&nbsp;: à partir de la pin 3.3V du Flora, formez une ligne avec toutes les bornes «&nbsp;+&nbsp;» des NeoPixels, de même avec toutes les bornes «&nbsp;-&nbsp;» en partant de la pin GND. Enfin il faut connecter en ligne toutes les bornes marquées d'une flèche (faîtes attention à ce que tous les NeoPixels aillent dans le même sens&nbsp;: toutes vers le haut ou toutes vers le bas) à la pin 10 du Flora.</li>
        </ol>

        <h4>Le code</h4>

        <p>Avant de commencer le script, on doit ajouter la carte Adafruit Flora à la configuration de l'IDE Arduino car celle-ci ne fait pas partie des cartes nativement implémentées. Pour cela, allez dans <span class="code">Fichier</span> > <span class="code">Préfé-rences</span>. Dans le champ «&nbsp;URL de gestionnaire de cartes supplémentaires&nbsp;» ajoutez&nbsp;: <span class="code">https://adafruit.github.io/arduino-<br/>board-index/package_adafruit_index<br/>.json</span></p>


        <img class="img_tuto" src="images/ard_prefs2.png" alt="">

        <p>On importe la librairie <span class="code">Adafruit_NeoPixel</span> et initialise la bande de NeoPixels sur la pin 10. On déclare ici 8 NeopIxels dans l'objet <span class="code">Adafruit_NeoPixel</span> car c'est le nombre que nous utilisons pour ce projet, mais vous pourriez modifier le projet pour avoir un nombre plus important de NeoPixels. Ensuite dans le <span class="code">setup()</span> on démarre la bande.</p>
        <p class="expl_code" id="p10">Dans la <span class="code">loop()</span> on fait tourner en boucle une fonction <span class="code">rainbow()</span> qui, comme son nom l'indique, fera s'éclairer nos NeoPixels selon le spectre coloré dans son entier.</p>

        <pre class="prenb">
        <span class="type">#include</span> &lt;Adafruit_NeoPixel.h&gt;

        <span class="type">#define</span> PIN 10

        <span class="type">Adafruit_NeoPixel</span> strip =
        <span class="type">Adafruit_NeoPixel</span>(8, PIN,
        NEO_GRB + NEO_KHZ800);

        <span class="type">void</span> <span class="fonction">setup()</span> {
          strip.<span class="fonction">begin()</span>;
          strip.<span class="fonction">show()</span>;
        }
        </pre>

        <pre>
        <span class="type">void</span> <span class="fonction">loop()</span> {
          <span class="fonction">rainbow</span>(20);
        }
        </pre>

        <p>Voici la fonction <span class="code">rainbow()</span> à laquelle nous faisons appel dans la <span class="code">loop()</span>. Cette fonction prend pour paramètre le temps pendant lequel nous voulons que le cycle de couleurs soit réalisé. Ce que fait la fonction, c'est envoyer les valeurs des couleurs aux Neo-Pixels dans le temps donné. <br/>La fonction <span class="code">rainbow()</span> fait elle-même appel à la fonction <span class="code">Wheel()</span> qui calcule les valeurs des couleurs en bytes que doivent prendre les NeoPixels pour parcourir l'ensemble du spectre coloré.</p>


        <pre class="prenb">
        <span class="type">void</span> <span class="fonction">rainbow</span>(<span class="type">uint8_t</span> wait) {
          <span class="type">uint16_t</span> i, j;

          <span class="type">for</span>(j=0; j&lt;256; j++) {
            <span class="type">for</span>(i=0; i&lt;strip.<span class="fonction">numPixels()</span>; i++) {
              strip.<span class="fonction">setPixelColor</span>(i,
              Wheel((i+j) & 255));
            }
            strip.<span class="fonction">show()</span>;
            <span class="fonction">delay</span>(wait);
          }
        }

        <span class="type">uint32_t</span> Wheel(<span class="type">byte</span> WheelPos) {
          WheelPos = 255 - WheelPos;
          <span class="type">if</span>(WheelPos < 85) {
            <span class="type">return</span> strip.<span class="fonction">Color</span>(255 - WheelPos * 3,
            0, WheelPos * 3);
          }
          <span class="type">if</span>(WheelPos < 170) {
            WheelPos -= 85;
            <span class="type">return</span> strip.<span class="fonction">Color</span>(0, WheelPos * 3,
            255 - WheelPos * 3);
          }
          WheelPos -= 170;
          <span class="type">return</span> strip.<span class="fonction">Color</span>(WheelPos * 3,
          255 - WheelPos * 3, 0);
        }
         </pre>

         <img src="images/07.JPG" class="img_full_page" id="img_fp01" alt="">


         <div class="projet" id="pj38">
           <div class="bloc1">
             <h3>Adafruit <br/>Flora + <br/>module GPS</h3>
             <div class="cadre">
               <div class="num">

               </div>
             </div>
           </div>

           <div class="logo">
             <img src="images/arduino_Logo.png" alt="">
             <div class="blanc_logo">

             </div>
           </div>

           <div class="bloc_intro">
             <p class="intro">Le fabricant Adafruit propose également un module GPS portable et cousable. Nous allons l'associer au Flora pour réaliser un projet dans lequel une bande de NeoPixels s'allume d'une façon particulière quand on se trouve à des coordonnées GPS que l'on va définir.</p>
             <div class="blanc_intro">
             </div>
           </div>
           <div class="remplissage">
             <div class="gps">
               <img src="images/gps.png" alt="">
             </div>
             <div class="neopixel">
               <img src="images/neopixel.png" alt="">
             </div>
             <div class="neopixel">
               <img src="images/neopixel.png" alt="">
             </div>
             <div class="neopixel">
               <img src="images/neopixel.png" alt="">
             </div>
             <div class="neopixel">
               <img src="images/neopixel.png" alt="">
             </div>
             <div class="neopixel">
               <img src="images/neopixel.png" alt="">
             </div>
             <div class="neopixel">
               <img src="images/neopixel.png" alt="">
             </div>

           </div>
         </div>

         <img class="schema" id="schema18" src="images/flora_gps.svg" alt="">

         <ol>
           <li>Le module GPS se monte de façon simple sur le Flora&nbsp;: connectez les ports 3.3V de chacun ensemble, de même pour les ports GND, branchez le port RX du Flora sur le TX du module GPS, et le TX du Flora sur le RX du GPS.</li>
           <li> Ensuite branchez 6 NeoPixels en bande à un autre port 3.3V et un autre GND du Flora, et au port 10 pour la ligne du milieu.</li>
         </ol>

         <h4>Le code</h4>
         <p>On aura besoin pour ce projet des librairies <span class="code">Adafruit_GPS</span> et <span class="code">Adafruit_NeoPixel</span>. <br/>Le module GPS requiert qu'on initialise un port série pour lui seul, c'est pourquoi on crée la constante <span class="code">Serial1</span> et qu'on l'associe à l'objet <span class="code">Adafruit_GPS</span>. Ensuite on initialise la pin 10 et on la déclare dans l'objet <span class="code">Adafruit_NeoPixel</span>, composé de 6 NeoPixels rattachés à la pin 10 du Flora. <br/>La valeur contenue dans <span class="code">timer</span> nous servira de délai plus tard. Enfin on crée déjà les variables <span class="code">latitude</span> et <span class="code">longitude</span> qui stockeront ces données.</p>


         <pre class="prenb pre01">
        <span class="type">#include</span> &lt;Adafruit_GPS.h&gt;
        <span class="type">#include</span> &lt;Adafruit_NeoPixel.h&gt;

        <span class="type">#define</span> GPSSerial Serial1

        <span class="type">Adafruit_GPS</span> GPS(&GPSSerial);

        <span class="type">#define</span> GPSECHO false
        <span class="type">#define</span> PIN 10

        <span class="type">Adafruit_NeoPixel</span> strip =
        <span class="type">Adafruit_NeoPixel</span>(6, PIN,
        NEO_GRB + NEO_KHZ800);

        <span class="type">uint32_t</span> timer = millis();

        <span class="type">float</span> latitude;
        <span class="type">float</span> longitude;
         </pre>



         <p>Dans le <span class="code">setup()</span> on commence par démarrer et configurer la bande de NeoPixels. <br/>Puis on initialise un port série à 115200 bauds, celui-ci pour afficher les données et déboguer. Juste en-dessous c'est celui du GPS que nous initialisons, à 9600 bauds. <br/>Le reste de la fonction fait démarrer le module GPS et envoie des informations dans le moniteur série afin que nous puissions vérifier que tout est correct. La ligne <span class="code">GPS.sendCommand(PMTK_SET_NMEA_ OUTPUT_RMCGGA);</span> envoie les données de base du GPS (NMEA) ainsi que les coordonnées repérées. La ligne <span class="code">GPS.sendCommand<br/>(PMTK_SET_NMEA _UPDATE_1HZ);</span> détermine la fréquence d'envoi des données (ici 1Hz). La ligne <span class="code">GPS.sendCommand(PGCMD_ ANTENNA);</span> envoie des données sur l'état de l'antenne du module GPS. Enfin la ligne <span class="code">GPSSerial.println(PMTK_Q_RELEASE);</span> affiche dans le moniteur série le firmware utilisé par le module.</p>


         <pre class="prenb">
        <span class="type">void</span> <span class="fonction">setup()</span> {
          strip.<span class="fonction">begin()</span>;
          strip.<span class="fonction">setBrightness</span>(50);
          strip.<span class="fonction">show()</span>;

          <span class="type">Serial</span>.<span class="fonction">begin</span>(115200);

          GPS.<span class="fonction">begin</span>(9600);

          GPS.<span class="fonction">sendCommand</span>(PMTK_SET_NMEA
          _OUTPUT_RMCGGA);
          GPS.<span class="fonction">sendCommand</span>(PMTK_SET_NMEA
          _UPDATE_1HZ);
          GPS.<span class="fonction">sendCommand</span>(PGCMD_ANTENNA);

          <span class="fonction">delay</span>(1000);

          GPSSerial.<span class="fonction">println</span>(PMTK_Q_RELEASE);
        }
         </pre>

        <p>Dans la <span class="code">loop()</span> on lit ce que dit le GPS. <br/>On réinitialise le <span class="code">timer</span> pour le remettre à 0 toutes les 2000 milli-secondes (2 secondes), et à cet intervalle nous récupérons les valeurs de latitude et longitude et les enregistrons dans leurs variables (nous affichons également ces valeurs dans le moniteur série dès lors que le GPS reconnaît sa position avec <span class="code">if (GPS.fix) {}</span>). Grâce à ces valeurs récupérées dans les variables <span class="code">latitude</span> et <span class="code">longitude</span>, nous pouvons faire opérer une boucle conditionnelle sur ces données. Les coordonnées GPS que nous comparons avec celles que le GPS envoie sont celles de Cityfab 2. Ce que nous voulons, c'est que si nous nous trouvons bien à une latitude et à une longitude correspondant à celles du fablab, une fonction impliquant les NeoPixels se déclenche. Si c'est le cas, la fonction <span class="code">rainbowCycle()</span> se lance, sinon les NeoPixels restent éteints.</p>

        <pre class="prenb">
        <span class="type">void</span> <span class="fonction">loop()</span> {
          <span class="type">char</span> c = GPS.<span class="fonction">read()</span>;

          <span class="type">if</span>(GPSECHO)
            <span class="type">if</span>(c) <span class="type">Serial</span>.<span class="fonction">print(c)</span>;

          <span class="type">if</span>(GPS.<span class="fonction">newNMEAreceived()</span>) {
            <span class="type">if</span>(!GPS.<span class="fonction">parse</span>(GPS.<span class="fonction">lastNMEA()</span>))
              <span class="type">return</span>;
          }

          <span class="type">if</span>(timer > <span class="fonction">millis()</span>) timer = <span class="fonction">millis()</span>;

          <span class="type">if</span>(<span class="fonction">millis()</span> - timer > 2000) {
            timer = <span class="fonction">millis()</span>;
            <span class="type">if</span>(GPS.fix) {
              <span class="type">Serial</span>.<span class="fonction">println</span>("Location: ");
              <span class="type">Serial</span>.<span class="fonction">println</span>(GPS.latitude, 1);
              <span class="type">Serial</span>.<span class="fonction">println</span>(GPS.longitude, 1);
            }
            latitude = GPS.latitude;
            longitude = GPS.longitude;
            <span class="type">if</span>((latitude > 5052.2 && latitude < 5052.5)
            && (longitude > 424.8 && longitude < 425.1)){
              <span class="fonction">rainbowCycle</span>(20);
            } <span class="type">else</span> {
              <span class="fonction">colorWipe</span>(strip.Color(0, 0, 0));
            }
          }
        }
        </pre>

        <p>Voici les fonctions qui interagissent avec la bande de NeoPixels. <br/>La première, <span class="code">colorWipe()</span> donne simplement la même couleur à chacun des Neo-Pixels de la bande. La deuxième, <span class="code">rainbow<br/>Cycle()</span> fait apparaître sur chaque NeoPixel, avec un intervalle entre chacun de telle sorte que les couleurs apparaîssent en décalé, l'ensemble des couleurs de l'arc-en-ciel. La fonction <span class="code">Wheel()</span> quant à elle décompose le spectre coloré et convertit les valeurs de rouge, de vert et de bleu de chaque couleur du spectre en bytes que les NeoPixels comprennent.</p>

        <pre class="prenb">
        <span class="type">void</span> <span class="fonction">colorWipe</span>(<span class="type">uint32_t</span> c) {
          <span class="type">for</span>(<span class="type">uint16_t</span> i=0;i&lt;strip.<span class="fonction">numPixels()</span>; i++) {
            strip.<span class="fonction">setPixelColor</span>(i, c);
            strip.<span class="fonction">show()</span>;
          }
        }

        <span class="type">void</span> <span class="fonction">rainbowCycle</span>(<span class="type">uint8_t</span> wait) {
          <span class="type">uint16_t</span> i, j;
          <span class="type">for</span>(j=0; j&lt;256; j++) {
            <span class="type">for</span>(i=0; i< strip.<span class="fonction">numPixels()</span>; i++) {
              strip.<span class="fonction">setPixelColor</span>(i,Wheel(((
              i*256 / strip.<span class="fonction">numPixels()</span>) + j) & 255));
            }
            strip.<span class="fonction">show()</span>;
            <span class="fonction">delay</span>(wait);
          }
        }

        <span class="type">uint32_t</span> <span class="fonction">Wheel</span>(<span class="type">byte</span> WheelPos) {
          WheelPos = 255 - WheelPos;
          <span class="type">if</span>(WheelPos < 85) {
            <span class="type">return</span> strip.Color(255 - WheelPos * 3,
            0, WheelPos * 3);
          } <span class="type">else if</span>(WheelPos < 170) {
            WheelPos -= 85;
            <span class="type">return</span> strip.Color(0, WheelPos * 3,
            255 - WheelPos * 3);
          } <span class="type">else</span> {
            WheelPos -= 170;
            <span class="type">return</span> strip.Color(WheelPos * 3,
            255 - WheelPos * 3, 0);
          }
        }
        </pre>

          <div class="partie_gauche">

          </div>
          <div class="partie_droite">
            <h2 id="pt06">Raspberry Pi</h2>
          </div>

          <div class="page_blanche">

          </div>

          <div class="projet" id="pj39">
            <div class="bloc1">
              <h3>Installer <br/>Raspberry Pi <br/>OS (Raspbian)</h3>
              <div class="cadre">
                <div class="num">

                </div>
              </div>
            </div>

            <div class="logo">
              <img src="images/rpi_logo.png" alt="">
              <div class="blanc_logo">

              </div>
            </div>

            <div class="bloc_intro">
              <p class="intro">Raspberry Pi OS (anciennement Raspbian) est une distribution Linux spécialement conçue pour les Raspberry Pi. Bâtie sous l'architecture Linux, elle nous permettra d'utiliser le Raspberry Pi comme n'importe quel ordinateur de bureau si on le branche à un écran, un clavier et une souris, mais aussi de le contrôler à distance en utilisant la ligne de commande.</p>
              <div class="blanc_intro">
              </div>
            </div>
            <div class="remplissage" style="width: 30mm;background-image:url(images/shell.png);background-position:0% 0%;background-size:66mm 120mm;">


            </div>
          </div>

          <h4 style="width:70mm;">Les lignes<br/> de commande</h4>

          <p>Pour commencer nous devons télécharger la dernière version de Raspberry Pi OS, disponible sur le site officiel de la Raspberry Pi Foundation. Une fois décompressé et extrait, le fichier téléchargé doit avoir pour extension «&nbsp;.img&nbsp;» car il s'agit d'une image Linux.</p>
          <p class="expl_sh">L'étape suivante est de flasher l'image Linux sur la carte SD. Il existe différentes façons de faire cela</p>
          <h5>Flasher avec Balena Etcher</h5>
          <p class="expl_liste" style="page-break-after:always;margin-bottom:70mm;">La première façon de flasher une carte SD est d'utiliser Balena Etcher, à télécharger sur le site web du projet. Ce logiciel vous permet de flasher simplement votre carte&nbsp;: sélectionnez l'image à flasher, le périphérique sur lequel flasher, et lancez le flashage.</p>
          <h5 style="page-break-before:always;margin-top:0mm;">Flasher en ligne de commande</h5>
          <p class="expl_liste">Il est également possible de flasher une carte SD en utilisant la ligne de commande de votre ordinateur. Après avoir ouvert un terminal, entrez la commande&nbsp;:</p>
          <pre class="command">

  lsblk
          </pre>
          <p class="expl_liste">Insérez la carte SD dans votre ordinateur et relancez la commande <span class="code">lsblk</span>. Un nouvel élément doit être apparu, il s'agit de la carte SD. Vous obtenez alors sa référence (par exemple «&nbsp;/dev/mmcblk0&nbsp;»).<br/> Pour flasher la carte, entrez la commande suivante en remplaçant le contenu de <span class="code">if=</span> par l'image Raspberry Pi OS précédemment téléchargée, et celui de <span class="code">of=</span> par l'adresse de la carte SD.</p>
          <pre class="command">

  <span class="type">dd</span> <span class="fonction">bs</span>=4M <span class="fonction">if</span>=image_linux.img <span class="fonction">of</span>=/dev/carte_sd\
  <span class="fonction">status</span>=progress <span class="fonction">conv</span>=fsync
          </pre>


          <div class="page_blanche">

          </div>



          <div class="projet" id="pj41">
            <div class="bloc1">
              <h3>Configurer <br/>la connexion <br/>à distance</h3>
              <div class="cadre">
                <div class="num">

                </div>
              </div>
            </div>

            <div class="logo">
              <img src="images/rpi_logo.png" alt="">
              <div class="blanc_logo">

              </div>
            </div>

            <div class="bloc_intro">
              <p class="intro">Autoriser la connexion à distance sur le Raspberry Pi nous permettra de nous y connecter en SSH et de le contrôler depuis n'importe quel ordinateur connecté au même réseau. Pour réaliser cette configuration, il faut naviguer dans la carte SD flashée avec Raspberry Pi OS sur un ordinateur.</p>
              <div class="blanc_intro">
              </div>
            </div>
            <div class="remplissage" style="width: 30mm;background-image:url(images/shell.png);background-position:0% 0%;background-size:66mm 120mm;">

            </div>
          </div>

          <h4 style="width:70mm;">Les lignes<br/> de commande</h4>

          <p>Avant de démarrer le Raspberry Pi, il faut que son système d'exploitation accepte une connexion distante via le protocole SSH («&nbsp;Secure Shell&nbsp;», protocole de connexion sécurisé d'un ordinateur vers un autre). <br/>Pour cela, il faut ajouter un fichier vide à la racine de la partition BOOT sur la carte SD en entrant la commande suivante&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> touch ssh
          </pre>
          <p class="expl_nn">La commande <span class="code">sudo</span> va vous demander d'entrer votre mot de passe. Faîtes-le et vous êtes connecté en tant que super-utilisateur.</p>

          <p class="expl_sh">Si vous souhaitez que votre Raspberry Pi se connecte automatiquement à un réseau Wifi lorsqu'il démarre, il faut préalablement créer un fichier de configuration à la racine de cette même partition BOOT avec la commande&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> nano wpa_supplicant.conf
          </pre>
          <p class="expl_nn">Vous vous retrouvez alors dans un éditeur de texte en ligne de commande. Copiez-y le code suivant, en prenant soin de remplacer les entrées <span class="code">ssid</span> et <span class="code">psk</span> par le nom de votre réseau et son mot de passe.</p>
          <pre class="command">

  ctrl_interface=DIR=/var/run/\
  wpa_supplicant GROUP=netdev
  update_config=1
  country=BE

  network={
    ssid="réseau wifi"
    psk="mot de passe wifi"
    key_mgmt=WPA-PSK
  }
          </pre>
          <p class="expl_nn">Une fois ce code copié dans le fichier, sauvegardez et quittez l'éditeur en pressant <span class="code">CTRL</span>+<span class="code">X</span> puis <span class="code">Entrée</span>. Pour information, ce fichier de configuration sera déplacé dans le répertoire <span class="code">/etc/wpa_supplicant/</span> de Raspberry Pi OS au démarrage.</p>


          <p class="expl_sh">Par défaut le nom d'un Raspberry Pi est tout simplement «&nbsp;raspberrypi&nbsp;», mais on peut le changer pour des raisons de commodité, ce nom étant celui avec lequel le Raspberry Pi se connecte au réseau. </p>
          <br/><br/>
          <h5>Changer le nom du Raspberry Pi<br/>sous Linux</h5>
          <p class="expl_liste">Sous Linux on peut faire cette modification avant le démarrage en allant dans la partition ROOTFS. Entrez la commande suivante pour vous déplacer dans le bon dossier.</p>
          <pre class="command">

  <span class="type">cd</span> /media/utilisateur/root/etc/
          </pre>

          <p class="expl_liste">On doit ensuite modifier le fichier qui gère les hôtes du Raspberry Pi. Pour cela il faut entrer dans le terminal&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> nano hosts
          </pre>

          <p class="expl_liste">Dans ce fichier, modifiez la ligne <span class="code">127.0.1.1       raspberrypi</span>&nbsp;: remplacez «&nbsp;raspberrypi&nbsp;» par le nom que vous préférez donner à votre Raspberry. Sauvegardez et quittez avec <span class="code">CTRL</span>+<span class="code">X</span>. <br/>Puis on doit modifier le nom du Raspberry Pi dans un deuxième fichier&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> nano hostname
          </pre>

          <p class="expl_liste">Dans ce fichier remplacez «&nbsp;raspberrypi&nbsp;» par le nom précédemment donné au RPI. Sauvegardez et quittez avec <span class="code">CTRL</span>+<span class="code">X</span>.</p>

          <h5>Changer le nom du Raspberry Pi<br/>sous Windows ou Mac</h5>
          <p class="expl_liste">Sous Windows ou Mac il vous faudra vous connecter une première fois au Raspberry Pi avant de pouvoir modifier son nom. Pour cela démarrez le Raspberry et tapez dans un terminal&nbsp;:</p>
          <pre class="command">

  <span class="type">ssh</span> pi@raspberrypi.local
          </pre>

          <p class="expl_liste">Le nom d'utilisateur par défaut est «&nbsp;pi&nbsp;» et le mot de passe «&nbsp;raspberry&nbsp;». Si le système demande une confirmation avant de faire la connexion, confirmer en entrant <span class="code">y</span>.<br/>Une fois connecté appliquez la même marche à suivre que celle expliquée sous Linux pour les deux fichiers à modifier. <br/>Pour que vos changements soient pris en compte redémarrez le Raspberry Pi en tapant la commande&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> reboot now
          </pre>

          <div class="page_blanche">

          </div>


          <div class="projet" id="pj40">
            <div class="bloc1">
              <h3>Premier <br/>démarrage du <br/>Raspberry Pi</h3>
              <div class="cadre">
                <div class="num">

                </div>
              </div>
            </div>

            <div class="logo">
              <img src="images/rpi_logo.png" alt="">
              <div class="blanc_logo">

              </div>
            </div>

            <div class="bloc_intro">
              <p class="intro">Il faut entrer quelques commandes dans le Raspberry Pi fraîchement flashé et démarré afin d'assurer son fonctionnement optimal.</p>
              <div class="blanc_intro">
              </div>
            </div>
            <div class="remplissage" style="width: 30mm;background-image:url(images/shell.png);background-position:0% 0%;background-size:66mm 120mm;">


            </div>
          </div>

          <h4 style="width:70mm;">Les lignes<br/> de commande</h4>

          <p>Tout d'abord pour vous connecter à un Raspberry Pi, entrez dans un terminal la commande ci-dessous. Si vous avez changé le nom de votre Raspberry Pi, modifiez dans cette commande «&nbsp;raspberry&nbsp;» par le nom de votre RPI. Sinon, le nom d'utilisateur par défaut est «&nbsp;pi&nbsp;» et le mot de passe «&nbsp;raspberry&nbsp;». Si le système demande une confirmation avant de faire la connexion, acceptez en entrant <span class="code">y</span>.</p>
          <pre class="command">

  <span class="type">ssh</span> pi@raspberrypi.local
          </pre>
          <p class="expl_sh">Si vous souhaitez changer le mot de passe de votre Raspberry Pi, entrez la commande <span class="code">passwd</span> et suivez les instructions.</p>
          <p class="expl_sh">La première chose à faire une fois que vous êtes connecté en SSH au Raspberry Pi est de mettre à jour ses logiciels. On commence par mettre à jour la base de données locale de logiciels disponibles&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> apt-get update
          </pre>
          <p class="expl_sh">Puis on met à jour les logiciels déjà installés sur le Raspberry Pi&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> apt-get upgrade
          </pre>
          <p class="expl_sh">On peut aussi mettre à jour la version de Raspberry Pi OS&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> apt-get dist-upgrade
          </pre>


          <div class="page_blanche">

          </div>


          <div class="page_blanche">

          </div>

          <div class="projet" id="pj42">
            <div class="bloc1">
              <h3>Configurer <br/>le partage <br/>de dossiers <br/>(Samba)</h3>
              <div class="cadre">
                <div class="num">

                </div>
              </div>
            </div>

            <div class="logo">
              <img src="images/rpi_logo.png" alt="">
              <div class="blanc_logo">

              </div>
            </div>

            <div class="bloc_intro">
              <p class="intro" style="width:65.25mm;">Samba est un programme qui permet de partager les dossiers du Raspberry Pi sur le réseau et d'y accéder depuis d'autres ordinateurs. C'est très utile si l'on travaille sur le Raspberry Pi à distance, car on peut modifier les fichiers présents dessus depuis son propre ordinateur.</p>
              <div class="blanc_intro">
              </div>
            </div>
            <div class="remplissage" style="width: 30mm;background-image:url(images/shell.png);background-position:0% 0%;background-size:66mm 120mm;">
            </div>
          </div>

          <h4 style="width:70mm;">Les lignes<br/> de commande</h4>

          <p>Pour installer Samba, tapez cette commande dans un terminal&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> apt-get install samba\
  samba-common-bin
          </pre>

          <p class="expl_sh">Ouvrez le fichier de configuration de Samba avec la commande&nbsp;:</p>

          <pre class="command">

  <span class="type">sudo</span> nano /etc/samba/smb.conf
          </pre>
          <p class="expl_nn">Dans ce fichier changez la ligne <span class="code">wins support = no</span> en <span class="code">wins support = yes</span>. Ajoutez le code suivant à la fin du fichier.</p>
          <pre class="command">

  [pihome]
    comment=home pi
    path=/home/pi
    browseable=Yes
    writeable=Yes
    only guest=no
    create mask=0775
    directory mask=0775
    public=no
          </pre>
          <p class="expl_nn">La configuration que nous faisons ci-dessus rend l'ensemble des dossiers du Raspberry Pi accessibles via Samba (<span class="code">/home/pi</span> étant le dossier racine). Si vous souhaitez ne partager qu'un seul dossier il faut entrer dans le fichier une configuration du type&nbsp;:</p>
          <pre class="command">

  [monDossierPartage]
    path=/home/pi/monDossierPartage
    browseable=Yes
    writeable=Yes
    create mask=0777
    directory mask=0777
    public=no
          </pre>

          <p class="expl_sh">Une fois la configuration voulue faite, sauvez et quittez l'éditeur de texte en pressant <span class="code">CTRL</span>+<span class="code">X</span>. Enfin ajoutez l'utilisateur «&nbsp;pi&nbsp;» à la configuration de Samba (le nom d'utilisateur vous sera demandé quand vous essaierez de vous connecter aux dossiers du Raspberry depuis un autre ordinateur) et renseignez son mot de passe.</p>
          <pre class="command">
  <span class="type">sudo</span> smbpasswd -a pi
          </pre>

          <p class="expl_nn">Redémarrez le daemon de Samba pour que vos modifications soient prises en compte&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> systemctl restart smbd
          </pre>


          <div class="page_blanche">

          </div>

          <div class="projet" id="pj43">
            <div class="bloc1">
              <h3>Lancer une <br/>vidéo à <br/>distance</h3>
              <div class="cadre">
                <div class="num">

                </div>
              </div>
            </div>

            <div class="logo">
              <img src="images/rpi_logo.png" alt="">
              <div class="blanc_logo">

              </div>
            </div>

            <div class="bloc_intro">
              <p class="intro">Une fois connecté en SSH au Raspberry Pi, vous pouvez contrôler ses actions à distance soit à l'aide scripts Python, soit en ligne de commande.</p>
              <div class="blanc_intro">
              </div>
            </div>
            <div class="remplissage" style="width: 30mm;background-image:url(images/shell.png);background-position:0% 0%;background-size:66mm 120mm;">

            </div>
          </div>

          <h4 style="width:70mm;">Les lignes<br/> de commande</h4>

          <p>Pour lancer une vidéo, déplacez-vous dans le dossier où se trouve la vidéo que vous souhaitez lire à l'aide de la commande <span class="code">cd</span> et entrez dans le terminal&nbsp;:</p>
          <pre class="command">

  <span class="type">omxplayer</span> mavideo.mp4
          </pre>

          <p class="expl_sh">Omxplayer est le lecteur vidéo installé par défaut sur les Raspberry Pi. Il présente l'avantage de pouvoir être lancé sans avoir nécessairement de session de bureau ouverte avec Raspberry Pi OS. Pour lancer la vidéo en boucle et sans affichage de ses statuts, la commande est la suivante&nbsp;:</p>

          <pre class="command">

  <span class="type">omxplayer</span> --loop --no-osd mavideo.mp4
          </pre>

          <p class="expl_nn">Omxplayer présente tout un ensemble d'autres options que l'on peut retrouver dans la documentation officielle de la Raspberry Pi Foundation.</p>


          <div class="projet" id="pj44">
            <div class="bloc1">
              <h3>Créer un <br/>point d'accès <br/>wifi</h3>
              <div class="cadre">
                <div class="num">

                </div>
              </div>
            </div>

            <div class="logo">
              <img src="images/rpi_logo.png" alt="">
              <div class="blanc_logo">

              </div>
            </div>

            <div class="bloc_intro">
              <p class="intro">En convertissant un Raspberry Pi en point d'accès wifi, on le fait partager sa connexion Internet à n'importe quel appareil qui se connecterait à son réseau et on peut afficher son propre contenu dans le navigateur de l'appareil connecté. Pour cela, il faut dédier l'interface wifi du Raspberry à la diffusion du réseau.</p>
              <div class="blanc_intro">
              </div>
            </div>
            <div class="remplissage" style="width: 30mm;background-image:url(images/shell.png);background-position:0% 0%;background-size:66mm 120mm;">

            </div>
          </div>

          <h4 style="width:70mm;">Les lignes<br/> de commande</h4>

          <p>On commence par installer deux services, <span class="code">hostapd</span> et <span class="code">dnsmasq</span>. Le premier servira à configurer le point d'accès wifi et le second à distribuer des adresses IP aux appareils connectés (via le protocole DHCP).</p>
          <pre class="command">

  <span class="type">sudo</span> apt-get install dnsmasq hostapd
          </pre>

          <p class="expl_sh">Puis on éteint les deux services pour les configurer&nbsp;:</p>

          <pre class="command">

  <span class="type">sudo</span> systemctl stop dnsmasq
  <span class="type">sudo</span> systemctl stop hostapd
          </pre>

          <p class="expl_sh">On doit configurer l'interface <span class="code">wlan0</span> pour lui attribuer une adresse IP fixe et l'empêcher de se connecter à un réseau wifi via <span class="code">wpa_supplicant</span>&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> nano /etc/dhcpcd.conf
          </pre>

          <p class="expl_sh">Dans le fichier ajouter&nbsp;:</p>
          <pre class="command">

  interface wlan0
    static ip_address=10.10.0.1/24
    nohook wpa_supplicant
          </pre>

          <p class="expl_sh"><span class="code">10.10.0.1</span> correspond à l'adresse IP de l'interface qui agira comme serveur DHCP. Sauvez et quittez en pressant <span class="code">CTRL</span>+<span class="code">X</span>. Puis supprimez le fichier de configuration par défaut de <span class="code">dnsmasq</span>&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> <span class="fonction">mv</span> /etc/dnsmasq.conf /etc/dnsmasq.conf.orig
          </pre>

          <p class="expl_sh">Créez un nouveau fichier de configuration <br/>de <span class="code">dnsmasq</span>&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> nano /etc/dnsmasq.conf
          </pre>

          <p class="expl_nn">Ajoutez-y les lignes suivantes, qui spécifient que l'interface wifi embarquée sur le Raspberry pourra distribuer des adresses IP à ses clients dans l'intervalle entre <span class="code">10.10.0.2</span> et <span class="code">10.10.0.20</span>.</p>
          <pre class="command">

  interface=wlan0
    dhcp-range=10.10.0.2,10.10.0.20,\
    255.255.255.0,24h
          </pre>

          <p class="expl_sh">Créez un fichier de configuration pour le point d'accès wifi (<span class="code">hostapd</span>)&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> nano /etc/hostapd/hostapd.conf
          </pre>

          <p class="expl_nn">Insérez-y le contenu suivant (en adaptant le nom du point d'accès et le mot de passe)&nbsp;:</p>
          <pre class="command">

  interface=wlan0
  driver=nl80211
  ssid=leNomDuPointDAcces
  hw_mode=g
  channel=7
  wmm_enabled=0
  macaddr_acl=0
  auth_algs=1
  ignore_broadcast_ssid=0
  wpa=2
  wpa_passphrase=LeMotDePasse
  wpa_key_mgmt=WPA-PSK
  wpa_pairwise=TKIP
  rsn_pairwise=CCMP
          </pre>

          <p class="expl_sh" style="margin-top:4mm;">On doit ensuite préciser à <span class="code">hostapd</span> que le fichier a été créé. Pour cela entrez la commande&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> nano /etc/default/hostapd
          </pre>

          <p class="expl_nn">Dans ce fichier, trouvez la ligne <span class="code">#DAEMON_<br/>CONF=""</span> et remplacez-la par&nbsp;: <span class="code">DAEMON_<br/>CONF="/etc/hostapd/hostapd.conf"</span>.<br/> Une fois cela fait, on peut redémarrer les deux services.</p>
          <pre class="command">

  <span class="type">sudo</span> service hostapd start
  <span class="type">sudo</span> service dnsmasq start
          </pre>

          <p class="expl_sh">Pour que les appareils clients puissent accéder à Internet via le point d'accès créé, <br/>il faut que l'interface réseau soit connectée à Internet et partage sa connexion avec l'interface <span class="code">wlan0</span> (qui sert au point d'accès wifi). Pour cela, on utilise un système de traductions d'adresses, le NAT («&nbsp;Network Address Translation&nbsp;»). Concrètement, lorsque le client enverra une requête vers le Raspberry sur l'interface <span class="code">wlan0</span>, cette dernière transmettra cette requête sur <span class="code">wlan1</span> qui l'enverra à l'adresse désignée sur Internet en utilisant sa propre adresse IP. L'appareil à cette adresse enverra sa réponse sur <span class="code">wlan1</span> qui la retransmettra sur <span class="code">wlan0</span>.
            <br/>Pour réaliser cette action il faut modifier le fichier <span class="code">/etc/systcl.conf</span> pour permettre le «&nbsp;port forwarding&nbsp;» entre les interfaces. Tapez dans le terminal&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> nano /etc/sysctl.conf
          </pre>

          <p class="expl_sh">Dans ce fichier, trouvez la ligne <span class="code">#net.ipv4<br/>.ip_forward=1</span> et remplacez-la par <span class="code">net.<br/>ipv4.ip_forward=1</span>.<br/> Pour finir exécutez la commande suivante&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> sh -c\
  <span class="fonction">"echo 1 > /proc/sys/net/ipv4/ip_forward"</span>
          </pre>

          <p class="expl_sh">Une fois l'interface réseau du Raspberry Pi configurée, celui-ci est accessible à tous les appareils se connectant sur son réseau&nbsp;; <br/>il peut donc faire office de serveur local. Pour faire cela de manière très simple, on installe Nginx&nbsp;:</p>
          <pre class="command">

  <span class="type">sudo</span> apt-get install nginx
          </pre>

          <p class="expl_nn">Nginx gère un serveur local accessible sur le réseau à la racine du Raspberry Pi (tapez dans la barre de recherche de votre navigateur «&nbsp;raspberrypi.local&nbsp;» si vous n'avez pas changé le nom du RPI, sinon «&nbsp;nomDuRaspberry.local&nbsp;»). Pour modifier la page d'accueil par défaut de votre serveur local il vous faut créer un fichier HTML à la racine du serveur. Pour cela entrez dans le terminal&nbsp;:</p>
          <pre class="command">

  nano /var/www/html/index.html
          </pre>

          <p class="expl_nn">Sauvez et quittez avec <span class="code">CTRL</span>+<span class="code">X</span> quand vous avez fini vos modifications.</p>


          <div class="page_blanche">

          </div>

          <div class="projet" id="pj45">
            <div class="bloc1">
              <h3>Faire <br/>clignoter <br/>une LED <br/>en Python</h3>
              <div class="cadre">
                <div class="num">

                </div>
              </div>
            </div>

            <div class="logo">
              <img src="images/rpi_logo.png" alt="">
              <img src="images/python.png" alt="">
              <div class="blanc_logo">

              </div>
            </div>

            <div class="bloc_intro">
              <p class="intro" style="width:76mm">Un Raspberry Pi est pourvu de broches GPIO qui nous permettent d'y brancher des composants électroniques. De la même façon que le ferait une carte Arduino, le Raspberry Pi est capable de lire et d'envoyer des signaux électriques à des composants branchés à ses broches GPIO.</p>
              <div class="blanc_intro">
              </div>
            </div>
            <div class="remplissage" style="width:30mm;">
              <div class="led">
                <img src="images/led_rouge.png" alt="">
              </div>
              <div class="resistance">
                <img src="images/resistance_220.png" alt="">
              </div>

            </div>
          </div>

          <img class="schema" id="schema10" src="images/rpi_led.svg" alt="">

          <ol>
            <li>Il existe deux façons de cartographier les broches GPIO d'un Raspberry Pi&nbsp;: BCM et BOARD. Le résultat sera le même mais selon la méthode choisie on ne référence pas les broches avec la même numérotation. En mode BOARD, les broches sont numérotées selon leur disposition physique sur la carte si on la lit de gauche à droite et de haut en bas. En mode BCM, les broches sont numérotées selon la «&nbsp;Broadcom SOC channel&nbsp;», il faut se référer à un schéma du Raspberry Pi pour connaître leur disposition.</li>
            <li>Dans ce premier circuit on va utiliser les broches en mode BCM. Branchez la LED d'un côté à l'une des broches 5V du Raspberry, <br/>et l'autre à l'une des broches GROUND par l'intermédiaire d'une résistance de 220 Ω.</li>
          </ol>

          <h4>Le code</h4>

          <p>Python est un langage de programmation très puissant qui peut interagir avec les Raspberry Pi. Il fonctionne par l'importation de modules, de différents morceaux de code que l'on peut combiner. <br/><br/>Les deux premières lignes du script font appel aux deux modules dont nous allons avoir besoin ici&nbsp;: <span class="code">RPi.GPIO</span> (pour interagir avec les broches GPIO) et <span class="code">time</span> pour pouvoir exprimer des délais temporels.</p>
          <p class="expl_code">Ensuite, de façon similaire à ce que nous ferions en Arduino, nous initialisons les broches et leurs modes. <span class="code">GPIO.setmode(GPIO.BCM)</span> nous sert à dire au Raspberry Pi qu'il doit prendre en compte le numérotage des broches en mode BCM. <span class="code">GPIO.setwarnings(False)</span> sert à empêcher le script d'afficher des avertissements dans le terminal. On déclare la variable <span class="code">led</span> sur la broche 4 (en mode BCM toujours), puis on initialise le mode de la broche avec <span class="code">GPIO.<br/>setup(led,GPIO.OUT)</span> qui prend comme arguments le numéro de la broche et son mode (ici <span class="code">OUT</span>).</p>

          <pre class="prenb pre01">
        <span class="type">import</span> <span class="fonction">RPi.GPIO</span> <span class="type">as</span> GPIO
        <span class="type">import</span> time
          </pre>

          <pre id="pre20">
        GPIO.<span class="fonction">setmode</span>(GPIO.BCM)
        GPIO.<span class="fonction">setwarnings</span>(<span class="type">False</span>)

        led = 4

        GPIO.<span class="fonction">setup</span>(led,GPIO.OUT)
          </pre>

          <p>Le reste du script est une boucle qui répètera le code 5 fois. <span class="code">for i in range(5):</span> signifie que la boucle va se répéter jusqu'à ce que <span class="code">i</span> vale 5 (il vaut initialement 0). 5 fois donc, on va afficher dans le terminal <span class="code">"led ON"</span>, puis envoyer un signal électrique à la broche de la LED avec <span class="code">GPIO.output<br/>(led,1)</span>, et ce pendant 2 secondes car la ligne suivante est&nbsp;: <span class="code">time.sleep(2)</span>, ce qui implique que l'action demandée à la ligne précédente va rester active pendant ce délai. Puis on fait le code inverse&nbsp;: on affiche <span class="code">"led OFF"</span> dans le terminal, on n'envoie plus de signal électrique vers la LED (<span class="code">GPIO.output(led,0)</span>), et ce pendant 2 secondes également. <br/>Une fois toutes les actions de la boucle réalisées, on repasse par chacune des étapes 4 autres fois.</p>

          <pre class="prenb">
        <span class="type">for</span> i <span class="type">in</span> <span class="fonction">range</span>(5):
            <span class="fonction">print</span> "LED on"
            GPIO.<span class="fonction">output</span>(led,1)
            time.<span class="fonction">sleep</span>(2)
            <span class="fonction">print</span> "LED off"
            GPIO.<span class="fonction">output</span>(led,0)
            time.<span class="fonction">sleep</span>(2)
          </pre>


          <div class="page_blanche">

          </div>

          <div class="projet" id="pj47">
            <div class="bloc1">
              <h3>Contrôler un <br/>servo moteur <br/>en Python</h3>
              <div class="cadre">
                <div class="num">

                </div>
              </div>
            </div>

            <div class="logo">
              <img src="images/rpi_logo.png" alt="">
              <img src="images/python.png" alt="">
              <div class="blanc_logo">

              </div>
            </div>

            <div class="bloc_intro">
              <p class="intro" style="width:80mm;">Les broches GPIO d'un Raspberry Pi sont digitales&nbsp;; elles ne peuvent lire et recevoir que des signaux électriques valant 0 ou 1. Cependant il existe un moyen d'obtenir un éventail de valeurs comprises entre la tension minimale et la maximale en jouant sur la fréquence d'un courant&nbsp;: <br/>le PWM (Pulse Width Modulation). Cela nous permet par exemple de contrôler un servo moteur en lui envoyant différents angles.</p>
              <div class="blanc_intro">
              </div>
            </div>
            <div class="remplissage" style="width:26mm;">
              <div class="servo">
                <img src="images/servo.png" alt="">
              </div>

            </div>
          </div>

          <img class="schema" id="schema12" src="images/rpi_servo.svg" alt="">

          <ol>
            <li>Le circuit est simple&nbsp;: branchez le câble rouge du servo à une broche 5V du Raspberry, son câble noir à une broche GROUND, et son câble central à la broche 3 (en mode BOARD).</li>
          </ol>

          <h4>Le code</h4>

          <p>On commence par faire appel aux deux modules dont on va avoir besoin&nbsp;: <span class="code">RPi.GPIO</span> (pour interagir avec les broches GPIO) et la fonction <span class="code">sleep</span> du module <span class="code">time</span> pour pouvoir exprimer des délais temporels. <br/>Ensuite on détermine le mode des broches sur BOARD&nbsp;: <span class="code">GPIO.setmode(GPIO.BOARD)</span>, et on initialise la broche à laquelle est reliée le servo moteur avec <span class="code">GPIO.setup(03, GPIO.OUT)</span>. Cette broche doit fonctionner en mode PWM pour pouvoir envoyer un angle précis au moteur. On fait cela avec la ligne <span class="code">pwm=GPIO.PWM(03, 50))</span>, le premier argument étant la broche et le second la fréquence du signal. Il faut ensuite démarrer la broche en mode PWM  à la fréquence 0 avec la ligne <span class="code">pwm.start(0)</span>.</p>

          <pre class="prenb pre01">
        <span class="type">import</span> <span class="fonction">RPi.GPIO</span> <span class="type">as</span> GPIO
        <span class="type">from</span> time <span class="type">import</span> sleep

        GPIO.<span class="fonction">setmode</span>(GPIO.BOARD)
        GPIO.<span class="fonction">setup</span>(03, GPIO.OUT)
        pwm=GPIO.<span class="fonction">PWM</span>(03, 50)
        pwm.<span class="fonction">start</span>(0)
          </pre>

          <p>La fonction <span class="code">setAngle()</span> va gérer l'envoi de l'angle souhaité au servo moteur. <br/>Elle module l'intensité du courant passé au moteur pour qu'il se déplace comme on le souhaite. Cette fonction prend un argument, <span class="code">angle</span>, qu'on lui passe quand on l'appelle. <br/>La variable <span class="code">duty</span> convertit la valeur d'<span class="code">angle</span> en une fréquence modulée. Puis on envoie du courant dans la broche du servo (<span class="code">GPIO.<br/>output(03, True)</span>), et juste après on module la fréquence de ce courant avec la valeur qui vient d'être calculée (<span class="code">pwm. ChangeDutyCycle(duty)</span>), et cette action prend 1 seconde. <br/>Après cette seconde, on stoppe l'envoi de courant dans le servo (<span class="code">GPIO.output(03, False)</span>) et on remet sa fréquence à 0 (<span class="code">pwm.ChangeDutyCycle(0)</span>). De cette façon on fait bouger le servo moteur selon l'angle passé à la fonction.</p>
          <p class="expl_code">Nous demandons à l'utilisateur de taper la valeur de l'angle dans le terminal quand il lance le script. La ligne <span class="code">question = int<br/>(input("Angle : "))</span> récupère dans la variable <span class="code">question</span> l'angle tapé par l'utilisateur et le convertit en nombre entier. Puis on appelle la fonction <span class="code">setAngle()</span> en lui passant comme argument <span class="code">question</span>.</p>

          <pre class="prenb">
        <span class="type">def</span> <span class="fonction">SetAngle</span>(angle):
            duty = angle / 18 + 2
            GPIO.<span class="fonction">output</span>(03, <span class="type">True</span>)
            pwm.<span class="fonction">ChangeDutyCycle</span>(duty)
            <span class="fonction">sleep</span>(1)
            GPIO.<span class="fonction">output</span>(03, <span class="type">False</span>)
            pwm.<span class="fonction">ChangeDutyCycle</span>(0)
          </pre>
          <pre id="pre22">
        question = <span class="fonction">int</span>(<span class="fonction">input</span>("Angle : "))
        <span class="fonction">SetAngle</span>(question)

        pwm.<span class="fonction">stop()</span>

        GPIO.<span class="fonction">cleanup()</span>
          </pre>


          <div class="page_blanche">

          </div>

          <div class="projet" id="pj48">
            <div class="bloc1">
              <h3>Contrôler <br/>un moteur <br/>à courant <br/>continu</h3>
              <div class="cadre">
                <div class="num">

                </div>
              </div>
            </div>

            <div class="logo">
              <img src="images/rpi_logo.png" alt="">
              <img src="images/python.png" alt="">
              <div class="blanc_logo">

              </div>
            </div>

            <div class="bloc_intro">
              <p class="intro" style="width:76mm;">Il est possible de contrôler un moteur depuis un Raspberry Pi, mais si on alimente ce moteur avec plus de 5 Volts, on doit séparer le circuit en deux parties, une pour chaque tension, afin de protéger le Raspberry Pi d'un retour de tension qui pourrait le griller. On va à cet effet utiliser un circuit intégré L293D pour faire le lien entre le Raspberry et le moteur.</p>
              <div class="blanc_intro">
              </div>
            </div>
            <div class="remplissage" style="width:30mm;">
              <div class="l293d">
                <img src="images/l293d.png" alt="">
              </div>
              <div class="moteurcc">
                <img src="images/moteurcc.png" alt="">
              </div>

            </div>
          </div>

          <img class="schema" id="schema13" src="images/rpi_moteurcc.svg" alt="">

          <ol>
            <li>Commençons par la breadboard&nbsp;: d'un côté alimentez-la avec le 5V du Raspberry Pi, <br/>de l'autre avec une pile de 9V.</li>
            <li>Placez le CI de façon à ce que son encoche pointe vers le haut. Sa première broche à droite va dans le 5V. À gauche, la première broche est reliée à la broche 22 (en mode BOARD) du Raspberry, la deuxième à la 18 et<br/> la septième à la 16. <br/>Le moteur se connecte d'un côté à la troisième broche gauche du CI, de l'autre à la sixième broche gauche. La huitième broche à gauche va dans le 9V. Des deux côtés du circuit intégré, les quatrième et cinquième broches sont à connecter au GROUND. Enfin on relie ensemble les GROUND des deux côtés de la breadboard.</li>
          </ol>

          <h4>Le code</h4>

          <p>On commence par importer les modules <span class="code">RPi.GPIO</span> pour interagir avec les broches du Raspberry Pi et <span class="code">sleep</span> de <span class="code">time</span> afin de faire appel à des délais. On initialise ensuite les broches en mode BOARD et on déclare les broches du circuit intégré L293D avec lesquelles le Raspberry Pi va communiquer, qu'on initialise en <span class="code">GPIO.OUT</span>.</p>
          <p class="expl_code" id="p07">On va jouer avec les portes logiques du L293D pour faire tourner le moteur. <br/>La broche <span class="code">Motor1E</span> alimente le CI, on doit donc lui envoyer du courant (<span class="code">GPIO.output (Motor1E,GPIO.HIGH)</span>). Les broches <span class="code">Motor1A</span> et <span class="code">Motor1B</span> sont reliées aux deux côtés du moteur. Étant donné que le courant doit entrer d'un côté du moteur et ressortir de l'autre pour l'activer, ces deux broches doivent être dans des états différents. C'est pourquoi on a <span class="code">GPIO.output (Motor1A, GPIO.HIGH)</span> et <span class="code">GPIO.output (Motor1B, GPIO.LOW)</span> simultanément. <br/>Avec ces trois lignes le moteur tourne dans le sens horaire pendant 10 secondes.</p>

          <pre class="prenb pre01">
        <span class="type">import</span> <span class="fonction">RPi.GPIO</span> <span class="type">as</span> GPIO
        <span class="type">from</span> time <span class="type">import</span> sleep

        GPIO.<span class="fonction">setmode</span>(GPIO.BOARD)

        Motor1A = 16
        Motor1B = 18
        Motor1E = 22

        GPIO.<span class="fonction">setup</span>(Motor1A,GPIO.OUT)
        GPIO.<span class="fonction">setup</span>(Motor1B,GPIO.OUT)
        GPIO.<span class="fonction">setup</span>(Motor1E,GPIO.OUT)
          </pre>

          <pre>
        <span class="fonction">print</span>("Turning motor onwards")

        GPIO.<span class="fonction">output</span>(Motor1A,GPIO.HIGH)
        GPIO.<span class="fonction">output</span>(Motor1B,GPIO.LOW)
        GPIO.<span class="fonction">output</span>(Motor1E,GPIO.HIGH)

        <span class="fonction">sleep</span>(10)
          </pre>

          <p>Pour faire tourner le moteur dans le sens anti-horaire, il faut inverser l'envoi de courant dans les broches <span class="code">Motor1A</span> et <span class="code">Motor1B</span>. Le sens du courant n'est pas inversé, c'est simplement une autre porte logique du CI qui est activée, le courant emprunte un autre chemin à travers le composant&nbsp;: dans notre cas il en résulte <br/>l'inversion du sens de rotation du moteur.</p>
          <p class="expl_code">Pour arrêter la rotation du moteur, il suffit de cesser d'envoyer du courant dans la broche <span class="code">Motor1E</span> puisque c'est elle qui active tout le circuit intégré (et par voie de fait les composants qui y sont connectés). <br/>On termine le script en nettoyant les broches GPIO.</p>

          <pre class="prenb">
        <span class="fonction">print</span>("Going backwards")

        GPIO.<span class="fonction">output</span>(Motor1A,GPIO.LOW)
        GPIO.<span class="fonction">output</span>(Motor1B,GPIO.HIGH)
        GPIO.<span class="fonction">output</span>(Motor1E,GPIO.HIGH)

        <span class="fonction">sleep</span>(10)
          </pre>
          <pre id="pre23">
        <span class="fonction">print</span>("Stopping motor")

        GPIO.<span class="fonction">output</span>(Motor1E,GPIO.LOW)

        GPIO.<span class="fonction">cleanup</span>()
          </pre>


          <div class="page_blanche">

          </div>

          <div class="projet" id="pj49">
            <div class="bloc1">
              <h3>Page web <br/>de contrôle <br/>de composants</h3>
              <div class="cadre">
                <div class="num">

                </div>
              </div>
            </div>

            <div class="logo">
              <img src="images/rpi_logo.png" alt="">
              <img src="images/python.png" alt="">
              <div class="blanc_logo">

              </div>
            </div>

            <div class="bloc_intro">
              <p class="intro">Un Raspberry Pi étant un ordinateur (et pas simplement un micro-contrôleur), il peut exécuter plusieurs tâches à la fois. On peut par exemple faire tourner dessus des applications. Nous allons réaliser une appli Python avec laquelle nous contrôlerons deux moteurs, une LED et un piezo buzzer depuis une page web.</p>
              <div class="blanc_intro">
              </div>
            </div>
            <div class="remplissage">

              <div class="moteurcc">
                <img src="images/moteurcc.png" alt="">
              </div>
              <div class="led">
                <img src="images/led_rouge.png" alt="">
              </div>
              <div class="l293d">
                <img src="images/l293d.png" alt="">
              </div>
              <div class="resistance">
                <img src="images/resistance_220.png" alt="">
              </div>
              <div class="servo">
                <img src="images/servo.png" alt="">
              </div>
              <div class="piezo">
                <img src="images/piezo.png" alt="">
              </div>

            </div>
          </div>

          <img class="schema" id="schema14" src="images/rpi_flask_moteurs.svg" alt="">

          <ol>
            <li>Tout d'abord il faut alimenter la breadboard d'un côté avec le 5V du Raspberry Pi, de l'autre avec une pile de 9V.</li>
            <li>Placez le CI de façon à ce que son encoche pointe vers le haut. Sa première broche à droite va dans le 5V. À gauche, la première broche est reliée à la broche 22 (en mode BOARD) du Raspberry, la deuxième à la 18 et <br/>la septième à la 16. <br/>Le moteur à courant continu se connecte d'un côté à la troisième broche gauche du CI, <br/>de l'autre à la sixième broche gauche. <br/>La huitième broche à gauche va dans le 9V. <br/>Des deux côtés du circuit intégré, les quatrième et cinquième broches sont à connecter au GROUND. Enfin on relie ensemble les GROUND des deux côtés de la breadboard.</li>
            <li>Branchez ensuite le servo moteur au 5V, <br/>au GROUND et à la broche 12 du Raspberry, <br/>en mode BOARD.</li>
            <li>Le piezo buzzer lui doit être connecté à la broche 13 et au GROUND.</li>
            <li>Quant à la LED, son anode doit être reliée à la broche 15 du Raspberry Pi et sa cathode doit rejoindre le GROUND à travers une résistance de 220 Ω.</li>
          </ol>

          <h4>app.py</h4>

          <p>On utilise le framework Flask pour créer <br/>une application web en Python. Le script «&nbsp;app.py&nbsp;» assure son fonctionnement. <br/>On importe <span class="code">flask</span>, et ses fonctions <span class="code">Flask</span>, <span class="code">render_template</span> et <span class="code">jsonify</span>. Ensuite on importe le module <span class="code">servo</span> qui est en fait un autre script de l'appli, qui nous sert à faire bouger le servo moteur. Puis <span class="code">RPi.GPIO</span> pour interagir avec les broches GPIO du Raspberry Pi, et <span class="code">random</span> et <span class="code">time</span>.</p>
          <p class="expl_code">On déclare chacune des broches utilisées en précisant son numéro (ici en mode <span class="code">GPIO. BOARD</span>) et son mode. La broche 12 à laquelle est connectée le servo moteur est déclarée une seconde fois en mode <span class="code">PWM</span> et stockée dans la variable <span class="code">pwm</span> car nous avons besoin de ce mode qui fait varier la fréquence du courant pour ce moteur.<br/> Ensuite, on déclare l'objet <span class="code">Flask</span> dans la variable <span class="code">app</span>, ce qui nous permettra de faire tourner l'application. On déclare ensuite toutes les variables qui vont nous servir à comparer l'état des composants&nbsp;: <span class="code">last_ valid_value</span> pour l'angle du servo, <span class="code">led_ state</span> pour la LED, <span class="code">piezo_state</span> pour le piezo buzzer et <span class="code">motor_dir</span> pour stocker la direction du moteur à courant continu.</p>

          <pre class="prenb pre01">
        <span class="type">from</span> flask <span class="type">import</span> Flask, render_template, jsonify
        <span class="type">from</span> servo <span class="type">import</span> *
        <span class="type">import</span> <span class="fonction">RPi.GPIO</span> <span class="type">as</span> GPIO
        <span class="type">import</span> random
        <span class="type">from</span> time <span class="type">import</span> sleep
          </pre>

          <pre id="pre24">
        GPIO.<span class="fonction">setmode</span>(GPIO.BOARD)
        GPIO.<span class="fonction">setup</span>(12, GPIO.OUT)
        GPIO.<span class="fonction">setup</span>(15, GPIO.OUT)
        GPIO.<span class="fonction">setup</span>(11, GPIO.IN)
        GPIO.<span class="fonction">setup</span>(13, GPIO.OUT)
        GPIO.<span class="fonction">setup</span>(16, GPIO.OUT)
        GPIO.<span class="fonction">setup</span>(18, GPIO.OUT)
        GPIO.<span class="fonction">setup</span>(22, GPIO.OUT)
        pwm = GPIO.<span class="fonction">PWM</span>(12, 50)
        pwm.<span class="fonction">start</span>(0)

        app = <span class="fonction">Flask</span>(__name__)

        last_valid_value = value
        led_state = 0
        piezo_state = 0
        motor_dir = ""
          </pre>

          <p>Le reste du script gère les routes de l'application, c'est-à-dire les URL internes. <br/>Pour chacune il faut créer une fonction qui va renvoyer (<span class="code">return</span>) quelque chose&nbsp;: <br/>un template HTML (la fonction <span class="code">index()</span> renvoie le template de la page d'accueil avec <span class="code">return render_template('index.<br/>html', value=value)</span>) ou une valeur (les fonctions <span class="code">led_on()</span>, <span class="code">led_off()</span>, <span class="code">motor_o()</span>, <span class="code">motor_b()</span>, <span class="code">down()</span>, <span class="code">up()</span>, <span class="code">piezo()</span> et <span class="code">get_value()</span> renvoient toutes des valeurs qui correspondent au changement d'état du composant qu'elles contrôlent). <br/>Cette appli n'est composée que d'une seule page HTML mais pourtant elle fait appel à bien plus de routes. C'est parce que nous nous servons de requêtes HTTP pour recueillir les ordres d'agir sur les composants&nbsp;; or les requêtes HTTP prennent des paramètres qui sont des URL, de cette façon l'appli saura reconnaître le paramètre passé à la requête HTTP qu'elle reçoit, et déclencher la route en conséquence. Par exemple lorsque la route <span class="code">/piezo</span> est active, la ligne de code <span class="code">GPIO.output(13, piezo_state)</span> est exécutée et le piezo se met à sonner.</p>

          <pre class="prenb">
        <span class="type">@app</span>.<span class="fonction">route</span>('/')
        <span class="type">def</span> <span class="fonction">index</span>():
            <span class="type">return</span> <span class="fonction">render_template</span>('index.html',\
            value=value)

        <span class="type">@app</span>.<span class="fonction">route</span>('/led_on/')
        <span class="type">def</span> <span class="fonction">led_on</span>():
            <span class="type">global</span> led_state
            led_state += 1
            GPIO.<span class="fonction">output</span>(15, led_state)
            <span class="type">return</span> <span class="fonction">jsonify</span>(led_state)

        <span class="type">@app</span>.<span class="fonction">route</span>('/led_off/')
        <span class="type">def</span> <span class="fonction">led_off</span>():
            <span class="type">global</span> led_state
            led_state -= 1
            GPIO.<span class="fonction">output</span>(15, led_state)
            <span class="type">return</span> <span class="fonction">jsonify</span>(led_state)

        <span class="type">@app</span>.<span class="fonction">route</span>('/motor_o/')
        <span class="type">def</span> <span class="fonction">motor_o</span>():
            <span class="type">global</span> motor_dir
            motor_dir = "onwards"
            GPIO.<span class="fonction">output</span>(16, GPIO.HIGH)
            GPIO.<span class="fonction">output</span>(18, GPIO.LOW)
            GPIO.<span class="fonction">output</span>(22, GPIO.HIGH)
            <span class="fonction">sleep</span>(2)
            GPIO.<span class="fonction">output</span>(22, GPIO.LOW)
            <span class="type">return</span> <span class="fonction">jsonify</span>(motor_dir)

         </pre>
         <pre class="prefp">
            <span class="type">@app</span>.<span class="fonction">route</span>('/motor_b/')
            <span class="type">def</span> <span class="fonction">motor_b</span>():
                 <span class="type">global</span> motor_dir
                 motor_dir = "backwards"
                 GPIO.<span class="fonction">output</span>(16, GPIO.LOW)
                 GPIO.<span class="fonction">output</span>(18, GPIO.HIGH)
                 GPIO.<span class="fonction">output</span>(22, GPIO.HIGH)
                 <span class="fonction">sleep</span>(2)
                 GPIO.<span class="fonction">output</span>(22, GPIO.LOW)
                 <span class="type">return</span> <span class="fonction">jsonify</span>(motor_dir)

            <span class="type">@app</span>.<span class="fonction">route</span>('/down/')
            <span class="type">def</span> <span class="fonction">down</span>():
                 <span class="type">global</span> last_valid_value
                 last_valid_value -= 5
                 <span class="type">while</span> last_valid_value < 0:
                     last_valid_value += 180
                 <span class="fonction">setAngle</span>(last_valid_value)
                 <span class="type">return</span> <span class="fonction">jsonify</span>(last_valid_value)

            <span class="type">@app</span>.<span class="fonction">route</span>('/up/')
            <span class="type">def</span> <span class="fonction">up</span>():
                <span class="type">global</span> last_valid_value
                last_valid_value += 5
                last_valid_value %= 180
                <span class="fonction">setAngle</span>(last_valid_value)
                <span class="type">return</span> <span class="fonction">jsonify</span>(last_valid_value)

            <span class="type">@app</span>.<span class="fonction">route</span>('/piezo/')
            <span class="type">def</span> <span class="fonction">piezo</span>():
                GPIO.<span class="fonction">output</span>(13, piezo_state)
                <span class="fonction">sleep</span>(1)
                <span class="type">return</span> <span class="fonction">jsonify</span>(piezo_state)

          </pre>
          <pre class="prefp">
        <span class="type">@app</span>.<span class="fonction">route</span>('/get_value/')
        <span class="type">def</span> <span class="fonction">get_value()</span>:
            <span class="type">return</span> <span class="fonction">jsonify</span>(last_valid_value)

        <span class="type">if</span> __name__ == '__main__':
            app.<span class="fonction">run</span>(debug=<span class="type">True</span>, host='0.0.0.0')
          </pre>

          <h4>servo.py</h4>

          <p>Ce script gère les mouvements du servo moteur en convertissant un angle compris entre 0 et 180 en une fréquence comprise entre 2 et 12 (correspondant au «&nbsp;duty cycle&nbsp;» du mode PWM). La fonction <span class="code">setAngle()</span> envoie du courant dans la broche du servo puis module sa fréquence en fonction de l'angle choisi pour faire se positionner le moteur selon cet angle (<span class="code">pwm.ChangeDutyCycle(angle / 18 + 2)</span>), puis l'envoi de courant dans la broche est stoppé et le mode PWM également. <br/>Ce script est appelé en tant que module dans <span class="code">app.py</span> afin d'éviter d'avoir à y faire le calcul de l'angle.</p>

          <pre class="prenb pre01">
        <span class="type">import</span> <span class="fonction">RPi.GPIO</span> <span class="type">as</span> GPIO
        <span class="type">from</span> time <span class="type">import</span> sleep

        GPIO.<span class="fonction">setmode</span>(GPIO.BOARD)
        GPIO.<span class="fonction">setup</span>(12, GPIO.OUT)

        pwm = GPIO.<span class="fonction">PWM</span>(12, 50)
        pwm.<span class="fonction">start</span>(0)

        <span class="type">def</span> <span class="fonction">setAngle</span>(angle):
          GPIO.<span class="fonction">output</span>(12, <span class="type">True</span>)
          pwm.<span class="fonction">ChangeDutyCycle</span>(angle / 18 + 2)
          <span class="fonction">sleep</span>(1)
          GPIO.<span class="fonction">output</span>(12, <span class="type">False</span>)
          pwm.<span class="fonction">ChangeDutyCycle</span>(0)

        pwm.<span class="fonction">stop</span>()
        GPIO.<span class="fonction">cleanup</span>()
          </pre>

          <h4>index.html</h4>
          <p>Le template HTML contient tous les éléments (boutons, champs de texte) via lesquels nous allons contrôler les composants. Chacun est identifié par un <span class="code">id</span>, ce qui nous permettra de les sélectionner individuellement en Javascript. On notera ce <span class="code">&lt;span id="servo_value"&gt;&#123;{value}}&lt;/span&gt;</span>, où <span class="code">&#123;{value}}</span> est une variable Python passé au template directement depuis <span class="code">app.py</span>&nbsp;; en effet cette valeur est mise à jour chaque fois que la route <span class="code">/get_value</span> est active, elle est sauvée dans <span class="code">last_valid_value</span> et passée comme argument à la fonction <span class="code">render_template</span>. <br/>Par ailleurs on remarque que les éléments portent des événements <span class="code">onclick=""</span>. <br/>Ceux-ci nous permettront de déclencher des fonctions en Javascript quand chacun des éléments sera cliqué.</p>

          <pre class="prenb pre01">
        &#123;% block main %}
          &lt;div <span class="type">id</span>="sv"&gt;
            &lt;p <span class="type">id</span>="servo"&gt; L'angle du servo est de :
            &lt;span <span class="type">id</span>="servo_value"&gt;&#123;{value}}&lt;/span&gt;&lt;/p&gt;
            &lt;div <span class="type">id</span>="buttons"&gt;
              &lt;button <span class="type">type</span>="button" <span class="type">name</span>="button"
              <span class="fonction">onclick</span>="up()"&gt;SERVO UP&lt;/button&gt;
              &lt;button <span class="type">type</span>="button" <span class="type">name</span>="button"
              <span class="fonction">onclick</span>="down()"&gt;SERVO DOWN&lt;/button&gt;
          &lt;/div&gt;&lt;/div&gt;

          &lt;div <span class="type">id</span>="led"&gt;
            &lt;p <span class="type">id</span>="txt_led"&gt;La DEL est éteinte&lt;/p&gt;
            &lt;button <span class="type">type</span>="button" <span class="type">name</span>="button"
            <span class="fonction">onclick</span>="led_on()"&gt;LED &lt;br/&gt;ON&lt;/button&gt;
            &lt;button <span class="type">type</span>="button" <span class="type">name</span>="button"
            <span class="fonction">onclick</span>="led_off()"&gt;LED OFF&lt;/button&gt;
          &lt;/div&gt;

          &lt;div <span class="type">id</span>="piezo"&gt;
            &lt;button <span class="type">type</span>="button" <span class="type">name</span>="button"
            <span class="fonction">onclick</span>="piezo()"&gt;PIEZO PLAY&lt;/button&gt;
          &lt;/div&gt;

          &lt;div <span class="type">id</span>="moteur"&gt;
            &lt;button <span class="type">type</span>="button" <span class="type">name</span>="button"
              <span class="fonction">onclick</span>="motor_o()"&gt;DC MOTOR ONWARDS
            &lt;/button&gt;
            &lt;button <span class="type">type</span>="button" <span class="type">name</span>="button"
              <span class="fonction">onclick</span>="motor_b()"&gt;DC MOTOR BACKWARDS
            &lt;/button&gt;
          &lt;/div&gt;
        &#123;% endblock %}
          </pre>

          <h4>style.css</h4>

          <p>Le fichier CSS modifie l'apparence des éléments HTML. L'attribut <span class="code">@font-face</span> permet d'utiliser une police de caractères personnalisée. N'hésitez pas à modifier ce fichier pour créer vos propres styles.</p>

          <pre class="prenb pre01">
        <span class="type">body</span> {
          color: orange;
          font-family: 'MetaAccanthis';
          font-size: 4vw;
          padding: 0vw;
          line-height: 120%;
          margin: 0vw;
        }

        <span class="type">a</span> {
          text-decoration: none;
          color: inherit;
        }

        <span class="type">p</span> {
          padding: 1vw;
          margin: 0;
        }

        <span class="type">button</span> {
          color: white;
          font-family: 'MetaAccanthis';
          font-size: 3vw;
          background-color: mediumseagreen;
          border: none;
          padding: 0.5vw;
          width: 25vw;
          text-align: center;
        }

        <span class="type">button</span><span class="fonction">:hover</span> {
          background-color: orange;
          cursor: pointer;
        }

        </pre>
        <pre class="prefp">
            #main {
              display: grid;
              grid-template-columns: <span class="fonction">repeat</span>(4,25vw[col-start]);
              grid-template-rows: <span class="fonction">repeat</span>(4,25vh[col-start]);
            }

            #menu {
              display: flex;
              flex-direction: row;
              justify-content: space-between;
              flex-wrap: wrap;
              height: auto;
            }

            #sv {
              grid-column: 1 / span 2;
              grid-row: 1 / span 2;
              border: 3px solid orange;
            }

            #buttons, #led, #piezo, #moteur {
              display: flex;
              flex-direction: row;
            }

            #buttons > * {
              height: 26.4vh;
            }

            #led {
              grid-column: 3 / span 2;
              grid-row: 1 / span 2;
              border: 3px solid orange;
              border-left: 0px solid white;
            }
        </pre>
        <pre class="prefp">

        #piezo {
          grid-column: 1 / span 2;
          grid-row: 3 / span 2;
        }

        #moteur {
          grid-column: 3 / span 2;
          grid-row: 3 / span 2;
          border: 3px solid orange;
          border-top: 0px solid white;
        }

        #moteur > * {
          width: 25vw !important;
        }

        <span class="type">@font-face</span> {
          font-family: 'MetaAccanthis';
          src:
          <span class="fonction">url</span>(font/metaaccanthis_regular-webfont.eot),
          <span class="fonction">url</span>(font/metaaccanthis_regular-webfont.svg),
          <span class="fonction">url</span>(font/metaaccanthis_regular-webfont.ttf),
          <span class="fonction">url</span>(font/metaaccanthis_regular-webfont.woff),
          <span class="fonction">url</span>(font/metaaccanthis_regular-webfont.woff2);
        }
          </pre>

          <h4>script.js</h4>

          <p>Le fichier Javascript de notre application contient les fonctions qui se déclenchent quand l'un des boutons est cliqué sur la page HTML. On retrouve d'ailleurs dans le nom des fonctions Javascript les noms des fonctions Python dans <span class="code">app.py</span> (cela n'est pas obligatoire mais facilite grandement la compréhension du code). Ce que font ces fonctions, c'est d'envoyer des requêtes HTTP à la racine du serveur à l'aide de la fonction <span class="code">fetch</span>. Celle-ci prend comme argument l'adresse du serveur où doit être adressée la requête. Par exemple la fonction <span class="code">fetch ("http://cityfab2.local:5000/up/");</span> envoie une requête à l'URL <span class="code">http:// cityfab2.local:5000/up/;</span>, ce qui correspond à la route <span class="code">/up</span> définie dans <span class="code">app.py</span>, et ainsi déclenche du côté serveur la fonction liée à cette route.</p>

          <pre class="prenb pre01">
        <span class="type">function</span> <span class="fonction">led_on</span>() {
          <span class="fonction">fetch</span>("http://cityfab2.local:5000/led_on/");
          texte_led.innerHTML = "La DEL est allumée";
        }

        <span class="type">function</span> <span class="fonction">led_off</span>() {
          <span class="fonction">fetch</span>("http://cityfab2.local:5000/led_off/");
          texte_led.innerHTML = "La DEL est éteinte";
        }

        <span class="type">function</span> <span class="fonction">motor_o</span>() {
          <span class="fonction">fetch</span>("http://cityfab2.local:5000/motor_o/");
        }

        <span class="type">function</span> <span class="fonction">motor_b</span>() {
          <span class="fonction">fetch</span>("http://cityfab2.local:5000/motor_b/");
        }

        <span class="type">function</span> <span class="fonction">piezo</span>() {
          <span class="fonction">fetch</span>("http://cityfab2.local:5000/piezo/");
        }

        <span class="type">function</span> <span class="fonction">up</span>() {
          <span class="fonction">fetch</span>("http://cityfab2.local:5000/up/");
        }

        <span class="type">function</span> <span class="fonction">down</span>() {
          <span class="fonction">fetch</span>("http://cityfab2.local:5000/down/");
        }
        </pre>

          <p>La fonction <span class="code">display_value</span> est un peu plus complexe. Elle demande au serveur de lui envoyer la valeur de l'angle actuel du servo (stockée dans <span class="code">last_valid_value</span> dans <span class="code">app.py</span>). Puis elle récupère directement la réponse du serveur à cette requête HTTP et la passe à l'élément dont l'<span class="code">id</span> est <span class="code">servo_ value</span>. Puis on fait en sorte que cette fonction s'exécute toutes les 200 milli-secondes avec <span class="code">window.setInterval(display_ value, 200);</span>, une fonction qui fait s'exécuter une autre fonction à un intervalle donné. De cette façon on s'assure que cet élément HTML affiche toujours la valeur de l'angle du servo à jour.</p>

          <pre class="prenb">
        <span class="type">function</span> <span class="fonction">display_value</span>() {
          <span class="fonction">fetch</span>('http://cityfab2.local:5000/get_value/')
          .then((resp) => resp.<span class="fonction">json</span>())
          .then(<span class="fonction">function</span>(data) {
            <span class="type">document</span>.<span class="fonction">getElementById</span>('servo_value')\
            .innerHTML = JSON.<span class="fonction">stringify</span>(data);
          })
        }
        window.<span class="fonction">setInterval</span>( display_value, 200 );
          </pre>

          <p class="expl_nn">Pour que l'application fonctionne, créez un dossier «&nbsp;static&nbsp;» à l'emplacement de l'appli et rangez dans ce dossier <span class="code">style.css</span> et <span class="code">script.js</span>. Créez un deuxième dossier nommé «&nbsp;templates&nbsp;» où vous rangerez <span class="code">index.html</span>. Pour lancer l'application, tapez dans un terminal&nbsp;: </p>

          <pre class="command">
  python3 app.py
          </pre>

          <p class="expl_nn">Le terminal affiche alors un message comme celui-ci&nbsp;: <span class="code">Serving HTTP on 0.0. 0.0 port xxxx (http://0.0.0.0:xxxx/) ...</span>. Ouvrez un navigateur et tapez dans la barre de recherche <span class="code">localhost:xxxx</span> (en renseignant le port donné dans le terminal) pour voir l'application sur un serveur de développement.</p>

          <img src="images/mot01.png" class="img_full_page" alt="">


          <div class="page_blanche">

          </div>

          <div class="projet" id="pj50">
            <div class="bloc1">
              <h3>Tweeter <br/>en ligne <br/>de commande</h3>
              <div class="cadre">
                <div class="num">

                </div>
              </div>
            </div>

            <div class="logo">
              <img src="images/rpi_logo.png" alt="">
              <div class="blanc_logo">

              </div>
            </div>

            <div class="bloc_intro">
              <p class="intro" style="width:65.25mm;">Il existe des modules Python permettant d'agir sur Twitter à partir d'un simple script. Nous allons voir comment faire avec l'un deux, Twython.</p>
              <div class="blanc_intro">
              </div>
            </div>
            <div class="remplissage" style="width: 30mm;background-image:url(images/shell.png);background-position:0% 0%;background-size:66mm 120mm;">

            </div>
          </div>

          <h4>Le code</h4>

          <p>On débute le script Python par la ligne <span class="code">#!/usr/bin/env python</span> afin que le terminal sache bien qu'il doit faire appel à l'interpréteur Python. On importe ensuite deux modules&nbsp;: <span class="code">sys</span>, qui va nous permettre de travailler avec les arguments passés dans le terminal à l'appel de la fonction, et <span class="code">Twython</span>, qui interagit avec l'API Twitter.</p>
          <p class="expl_code">Les valeurs des variables <span class="code">CONSUMER_KEY</span>, <span class="code">CONSUMER_SECRET</span>, <span class="code">ACCESS_KEY</span> et enfin <span class="code">ACCESS_SECRET</span> sont 4 clés que vous obtenez lorsque vous créez un compte développeur auprès de Twitter et créez une API. Gardez-les bien secrets sinon d'autres personnes pourront utiliser votre compte Twitter. On utilise donc ces 4 clés pour crééer l'objet <span class="code">Twython()</span> qui va ainsi pouvoir se connecter au réseau social.</p>
          <p class="expl_code">La dernière ligne du script tweete sur le compte auquel vous venez de vous authentifier à l'aide de la fonction <span class="code">update_status</span>. Son paramètre est <span class="code">status=sys.argv[1]</span>, donc le premier argument passé après le nom du script lorsque vous l'appelez dans un terminal.</p>

          <pre class="prenb pre01">
        #!/usr/bin/env python
        <span class="type">import</span> sys
        <span class="type">from</span> twython <span class="type">import</span> Twython
          </pre>

          <pre id="pre25">
        CONSUMER_KEY = '****'
        CONSUMER_SECRET = '****'
        ACCESS_KEY = '****'
        ACCESS_SECRET = '****'

        api = <span class="fonction">Twython</span>(CONSUMER_KEY,CONSUMER_SECRET,\
        ACCESS_KEY,ACCESS_SECRET)
          </pre>

          <pre id="pre26">
        api.<span class="fonction">update_status</span>(status=sys.argv[1])
          </pre>

          <p class="expl_nn">Pour tweeter, tapez dans un terminal la commande suivante, en prenant soin de changer le message par celui de votre choix&nbsp;:</p>
          <pre class="command">

  send_tweet.py "Ceci est mon tweet"
          </pre>


          <div class="projet" id="pj51">
            <div class="bloc1">
              <h3>Bot Twitter <br/>+ LED</h3>
              <div class="cadre">
                <div class="num">

                </div>
              </div>
            </div>

            <div class="logo">
              <img src="images/rpi_logo.png" alt="">
              <img src="images/python.png" alt="">
              <div class="blanc_logo">

              </div>
            </div>

            <div class="bloc_intro">
              <p class="intro" style="width:65.25mm;">On peut connecter un bot Twitter aux broches GPIO d'un Raspberry Pi, par exemple pour allumer une LED chaque fois qu'un mot-clé apparaît dans un tweet.</p>
              <div class="blanc_intro">
              </div>
            </div>
            <div class="remplissage">
              <div class="led">
                <img src="images/led_rouge.png" alt="">
              </div>
              <div class="resistance">
                <img src="images/resistance_220.png" alt="">
              </div>

            </div>
          </div>

          <img class="schema" style="margin-top: 2mm;" src="images/rpi_led_tag.svg" alt="">

          <ol>
            <li>Branchez une LED verte à la broche 22 du Raspberry Pi et au GROUND via une résistance de 220 Ω.</li>
          </ol>

          <h4>Le code</h4>

          <p>On importe les modules <span class="code">RPi.GPIO</span> pour interagir avec les broches du Raspberry Pi, <span class="code">TwythonStreamer</span> de <span class="code">twython</span> pour créer un stream de tweets. La variable <span class="code">TERMS</span> contient le terme qu'on recherchera dans les tweets. On initialise la broche de la LED dans <span class="code">LED = 22</span>. Copiez les codes secrets de votre API respectivement dans les variables <span class="code">APP_KEY</span>, <span class="code">APP_SECRET</span>, <span class="code">OAUTH_TOKEN</span> et <span class="code">OAUTH_TOKEN_SECRET</span>.</p>
          <p class="expl_code" id="p08"><span class="code">TwythonStreamer</span> est un objet contenant toutes les méthodes nécessaires à la mise en place d'un stream Twitter en temps réel. Nous étendons cette <span class="code">class</span> pour créer la nôtre, <span class="code">BlinkyStreamer</span>, qui va ajouter des méthodes pour la LED au stream. Quand le stream est établi (<span class="code">on_success()</span>), si un certain texte se trouve dans la <span class="code">data</span> renvoyée par le stream, alors on allume et éteint la LED avec <span class="code">GPIO.output(LED, GPIO.HIGH)</span> puis <span class="code">GPIO.output(LED, GPIO.LOW)</span>.</p>

          <pre class="prenb pre01">
        <span class="type">import</span> time
        <span class="type">import</span> <span class="fonction">RPi.GPIO</span> <span class="type">as</span> GPIO
        <span class="type">from</span> twython <span class="type">import</span> TwythonStreamer

        TERMS = '#raspberrypi'

        LED = 22

        APP_KEY = '****'
        APP_SECRET = '****'
        OAUTH_TOKEN = '****'
        OAUTH_TOKEN_SECRET = '****'
          </pre>

          <pre>
        <span class="type">class</span> <span class="fonction">BlinkyStreamer</span>(TwythonStreamer):
            <span class="type">def</span> <span class="fonction">on_success</span>(self, data):
                <span class="type">if</span> 'text' <span class="type">in</span> data:
                    <span class="fonction">print</span> data['text'].<span class="fonction">encode</span>('utf-8')
                    GPIO.<span class="fonction">output</span>(LED, GPIO.HIGH)
                    time.<span class="fonction">sleep</span>(1)
                    GPIO.<span class="fonction">output</span>(LED, GPIO.LOW)
          </pre>

          <p>On initialise ensuite les broches en mode <span class="code">GPIO.BOARD</span> et on éteint la LED. L'assertion <span class="code">try:</span>/<span class="code">except:</span> nous permet de tester du code et de lever une exception au cas où une erreur ou un cas de figure particulier soit rencontré. Ici ce que l'on teste, c'est que notre stream <span class="code">BlinkyStreamer</span> se lance bien (avec les codes secrets de l'API), puis on utilise la fonction <span class="code">stream.statuses.<br/>filter(track=TERMS)</span> pour demander au stream de traquer le terme voulu, celui contenu dans <span class="code">TERMS</span>. À partir de cette fonction, le <span class="code">BlinkyStreamer</span> va faire son travail et allumer la LED si le terme recherché est rencontré. <br/>Nous levons une exception en cas de <span class="code">KeyboardInterrupt</span>, c'est à dire s'il est mis fin au script dans le terminal en y entrant <span class="code">CTRL</span>+<span class="code">C</span>. Dans ce cas, on réinitialise les broches GPIO avec <span class="code">GPIO.cleanup()</span> pour finir proprement le script.</p>

          <pre class="prenb">
        GPIO.<span class="fonction">setmode</span>(GPIO.BOARD)
        GPIO.<span class="fonction">setup</span>(LED, GPIO.OUT)
        GPIO.<span class="fonction">output</span>(LED, GPIO.LOW)

        <span class="type">try</span>:
            stream = <span class="fonction">BlinkyStreamer</span>(APP_KEY, APP_SECRET,\
            OAUTH_TOKEN, OAUTH_TOKEN_SECRET)
            stream.statuses.<span class="fonction">filter</span>(track=TERMS)
        <span class="type">except</span> <span class="fonction">KeyboardInterrupt</span>:
            GPIO.<span class="fonction">cleanup()</span>
         </pre>



         <div class="page_blanche">

         </div>

         <div class="projet" id="pj52">
           <div class="bloc1">
             <h3>Bot Twitter&nbsp;:<br/> retweet et<br/> favori<br/>automatique</h3>
             <div class="cadre">
               <div class="num">

               </div>
             </div>
           </div>

           <div class="logo">
             <img src="images/rpi_logo.png" alt="">
             <img src="images/python.png" alt="">
             <div class="blanc_logo">

             </div>
           </div>

           <div class="bloc_intro">
             <p class="intro">Un autre module qui permet de gérer une API Twitter est Tweepy. Nous allons l'utiliser pour créer un bot qui retweete et met dans ses favoris tout tweet qui contient un mot donné.</p>
             <div class="blanc_intro">
             </div>
           </div>
           <div class="remplissage" style="width: 30mm;background-image:url(images/twitter.png);background-position:45% 36%;">

           </div>
         </div>

         <h4>Le code</h4>

         <p>On importe les modules <span class="code">tweepy</span> et <span class="code">sleep</span> pour gérer les délais d'exécution du script. Copiez les codes secrets de votre API dans les variables <span class="code">consumer_key</span>, <span class="code">consumer_<br/>secret</span>, <span class="code">access_token</span> et <span class="code">access_secret</span>. L'authentification à l'API se fait en trois temps&nbsp;: tout d'abord l'utilisateur s'identifie (<span class="code">auth = tp.OAuthHandler(consumer_key, consumer_secret)</span>), puis il entre ses codes d'accès (<span class="code">auth.set_access_token(access<br/>_token, access_secret)</span>), et crée un objet API (<span class="code">api = tp.API(auth)</span>).</p>
         <p class="expl_code">Les termes que l'on va chercher dans les tweets sont stockés dans <span class="code">tag</span>. Ensuite, la boucle <span class="code">for status in tp.Cursor(api.<br/>search, tag, result_type="mixed", lang="fr").items():</span> va parcourir Twitter à la recherche des mots-clés, et pour chaque tweet qui contient au moins l'un de ces mots (<span class="code">items()</span>), on le retweete et on le met en favori avec <span class="code">tweet.favorite()</span> et <span class="code">tweet.retweet()</span>. S'il y a eu une erreur dans le processus (<span class="code">except tp.TweepError</span>), alors on affiche l'erreur dans le terminal.</p>

         <pre class="prenb pre01">
        <span class="type">import</span> tweepy <span class="type">as</span> tp
        <span class="type">from</span> time <span class="type">import</span> sleep

        consumer_key = '****'
        consumer_secret = '****'
        access_token = '****'
        access_secret = '****'

        auth = tp.<span class="fonction">OAuthHandler</span>(consumer_key,\
        consumer_secret)
        auth.<span class="fonction">set_access_token</span>(access_token,\
        access_secret)
        api = tp.<span class="fonction">API</span>(auth)
         </pre>

         <pre id="pre27">
        tag = ("Cityfab2", "cityfab2",\
        "Cityfab 2", "cityfab 2")

        <span class="type">for</span> status <span class="type">in</span> tp.<span class="fonction">Cursor</span>(api.search, tag,
        result_type="mixed", lang="fr").<span class="fonction">items</span>():
            <span class="type">try</span>:
                tweet.<span class="fonction">favorite</span>()
                tweet.<span class="fonction">retweet</span>()
                <span class="fonction">sleep</span>(60)
            <span class="type">except</span> tp.TweepError as e:
                <span class="fonction">print</span>(e.reason)
         </pre>



         <div class="page_blanche">

         </div>

         <div class="projet" id="pj53">
           <div class="bloc1">
             <h3>Application <br/>bot Twitter <br/>web-to-print</h3>
             <div class="cadre">
               <div class="num">

               </div>
             </div>
           </div>

           <div class="logo">
             <img src="images/rpi_logo.png" alt="">
             <img src="images/python.png" alt="">
             <div class="blanc_logo">

             </div>
           </div>

           <div class="bloc_intro">
             <p class="intro">Ce projet est une application web grâce à laquelle on visualisera sur une page HTML des tweets préalablement enregistrés au format JSON. Il sera aussi possible de générer un PDF mis en page dans le navigateur de ces tweets.</p>
             <div class="blanc_intro">
             </div>
           </div>
           <div class="remplissage" style="background-image:url('images/tb01_titre.png'); background-position: 10% 20%;">

           </div>
         </div>

         <h4>tweets_json.py</h4>

         <p>Il faut commencer ce projet par le script <span class="code">tweets_json.py</span> car c'est lui qui va enregistrer les tweets dans le fichier JSON qu'on va charger dans la page web. Ce script commence par se connecter à l'API Twitter à l'aide des clés secrètes que vous mettrez dans <span class="code">consumer_key</span>, <span class="code">consumer_secret</span>, <span class="code">access_token</span> et <span class="code">access_secret</span>.</p>

         <pre class="prenb pre01">
        <span class="type">import</span> tweepy
        <span class="type">import</span> requests
        <span class="type">import</span> json
        <span class="type">from</span> time <span class="type">import</span> sleep
        <span class="type">import</span> os.path
        <span class="type">import</span> sys

        consumer_key='****'
        consumer_secret='****'
        access_token='****'
        access_token_secret='****'

        auth = tweepy.<span class="fonction">OAuthHandler</span>(consumer_key,\
        consumer_secret)
        auth.<span class="fonction">set_access_token</span>(access_token,\
        access_token_secret)
        api = tweepy.<span class="fonction">API</span>(auth)
         </pre>


         <p>On vérifie si le fichier JSON qui contient les tweets existe déjà avec <span class="code">if os.path.isfile<br/>('tweets.json'):</span> et si c'est le cas l'ouvrir (<span class="code">with open("tweets.json", "r") as <br/>read_file:</span>) et afficher son contenu dans le terminal.<br/> C'est là que la fonction <span class="code">get_my_tweets()</span>, qui va chercher et enregistrer les tweets correspondants, intervient. La boucle <span class="code">while continue_loops == True</span> fait en sorte que la fonction se répète indéfiniment tant que le script est actif. La ligne <span class="code">api.search<br/>(q=query, lang="en", count=1, tweet_<br/>mode="extended", wait_on_rate_limit = True)</span> recherche les tweets comportant le mot-clé stocké dans <span class="code">query</span>. Chaque tweet possède un identifiant unique dont on va se servir pour savoir si on l'a déjà enregistré dans notre fichier JSON&nbsp;: s'il ne figure pas déjà dans le dictionnaire <span class="code">tweet_dict</span> (<span class="code">if not tweet._json[u'id'] in tweet_<br/>dict:</span>), alors on crée une entrée dans <span class="code">tweet_dict</span> pour ce tweet à laquelle on associe le contenu du tweet ainsi que son horodatage. Chaque fois que cela arrive, la valeur de <span class="code">smthnew</span> est passée à <span class="code">True</span>&nbsp;; or à la ligne suivante nous spécifions que si tel est le cas (<span class="code">if smthnew:</span>), alors on convertit <span class="code">tweet_dict</span> au format JSON et on met à jour le fichier JSON.</p>

         <pre class="prenb">
        continue_loops = <span class="type">True</span>
        query = 'raspberry pi'
        tweet_dict = {}

        <span class="type">if</span> os.path.<span class="fonction">isfile</span>('tweets.json'):
            <span class="type">with</span> <span class="fonction">open</span>("tweets.json", "r") <span class="type">as</span> read_file:
                data = json.<span class="fonction">load</span>(read_file)
                <span class="fonction">print</span>( 'json > python',data )
                read_file.<span class="fonction">close</span>()

        <span class="type">def</span> <span class="fonction">get_my_tweets</span>():
            <span class="type">while</span> continue_loops == <span class="type">True</span>:
                tweets = api.<span class="fonction">search</span>(q=query, lang="en",\
                count=1, tweet_mode="extended")
                smthnew = <span class="type">False</span>
                <span class="type">for</span> tweet <span class="type">in</span> tweets:
                    <span class="type">if</span> not tweet._json[u'id'] <span class="type">in</span> tweet_dict:
                        tweet_dict[tweet._json[u'id']]={
                            'content': tweet.full_text,\
                            'timestamp':<span class="fonction">str</span>(tweet.created_at)
                        }
                    smthnew = <span class="type">True</span>
                <span class="type">if</span> smthnew:
                    jdata = json.<span class="fonction">dumps</span>( tweet_dict )
                    <span class="fonction">print</span>('python > json',jdata)
                    <span class="type">with</span> <span class="fonction">open</span>("tweets.json", "w")\
                    <span class="type">as</span> write_file:
                        json.<span class="fonction">dump</span>(tweet_dict, write_file)
                        write_file.<span class="fonction">close</span>()
                <span class="fonction">sleep</span>(1)

        <span class="type">while</span> continue_loops:
            <span class="fonction">sleep</span>( 0.5 )
        </pre>


         <h4>app.py</h4>

         <p>Quand on a un nombre de tweets suffisant pour le projet, on passe au fonctionnement de l'application web. On importe <span class="code">flask</span> car on développe l'appli sous ce framework Python, <span class="code">json</span> pour pouvoir lire le fichier <span class="code">tweets.json</span>, et <span class="code">flask_weasyprint</span>, qui nous permettra de générer automatique-ment un PDF depuis la page web. On crée l'objet <span class="code">Flask</span>, puis on ouvre le fichier JSON avec <span class="code">with open('tweets.json') as json_file</span>, grâce à quoi on enregistre tous les tweets du fichier dans <span class="code">liste</span>.</p>
         <p class="expl_code">La page web qui affiche les tweets sera placée à la racine de l'application&nbsp;: <span class="code">/</span>. <br/>On passe au template HTML la liste des tweets précédemment récupérés à la ligne <span class="code">return render_template('index.html', value=data, list=liste)</span>. On crée une deuxième route, <span class="code">@app.route('/tweets<br/>.pdf')</span>, qui va générer la mise en page des tweets en un document PDF. Dans la fonction <span class="code">tweets_pdf()</span>, en plus de faire un <span class="code">render_template()</span> du template HTML, <br/>la ligne <span class="code">return render_pdf(HTML(string<br/>=html))</span> met en page le contenu d'après les indications de media paginé données dans <span class="code">style.css</span>.</p>

         <pre class="prenb pre01">
        <span class="type">from</span> flask <span class="type">import</span> *
        <span class="type">import</span> json
        <span class="type">from</span> flask_weasyprint <span class="type">import</span> HTML, render_pdf

        app = <span class="fonction">Flask</span>(__name__)

        <span class="type">with</span> <span class="fonction">open</span>('tweets.json') <span class="type">as</span> json_file:
            data = json.<span class="fonction">load</span>(json_file)
            liste = <span class="fonction">list</span>(data)
         </pre>

         <pre id="pre28">
        @app.<span class="fonction">route</span>("/")
        <span class="type">def</span> <span class="fonction">index</span>():
            return <span class="fonction">render_template</span>('index.html',
            value=data, list=liste)

        @app.<span class="fonction">route</span>('/tweets.pdf')
        <span class="type">def</span> <span class="fonction">tweets_pdf</span>():
            html = <span class="fonction">render_template</span>('index.html',\
            value=data, list=liste)
            return <span class="fonction">render_pdf</span>(<span class="fonction">HTML</span>(string=html))

        if __name__ == '__main__':
            app.<span class="fonction">run</span>(debug=<span class="type">True</span>, host='0.0.0.0')
         </pre>

         <h4>index.html</h4>
         <p>On a vu dans <span class="code">app.py</span> qu'on passait au template HTML la liste des tweets extraits du fichier JSON. On traite donc cette liste dans le template Jinja en faisant appel à des boucles&nbsp;: par exemple dans le premier bloc <span class="code">&lt;article&gt;</span> on parcourt la liste de tweets pour récupérer l'attribut <span class="code">timestamp</span> du premier tweet (<span class="code">&#123;%for x in list[0:1]%} &#123;{value[x]['timestamp']}} &#123;%endfor%}</span>) ainsi que du dernier (<span class="code">&#123;%for y in list[:-2<br/>:-1]%} &#123;{value[y]['timestamp']}} &#123;%endfor%}</span>) pour placer ces deux valeurs dans le contenu de la balise <span class="code">&lt;h2&gt;</span>.
         Dans la seconde balise <span class="code">&lt;article&gt;</span> on parcourt l'ensemble des tweets <span class="code">&#123;%for i in value%}</span> et pour chacun on passe ses attributs <span class="code">timestamp</span> et <span class="code">content</span> dans une balise <span class="code">&lt;p&gt;</span>. Ainsi le contenu de la page HTML est généré dynamiquement.</p>

         <pre class="prenb pre01">
        &lt;!doctype html>
        &lt;html>
          &lt;head>
          &#123;% block head %}
            &lt;link <span class="type">rel</span>="stylesheet"
            <span class="type">href</span>="{{url_for('static',filename='style.css')}}">
            &lt;meta <span class="type">charset</span>="utf-8">
            &lt;meta <span class="type">name</span>="viewport" <span class="type">content</span>="initial-scale=1.0">
          &#123;% endblock %}
          &lt;/head>

          &lt;body>
            &lt;div <span class="type">id</span>="main">
              &lt;article>
                &lt;h2> Tweets about "Raspberry PI" from:
                  &lt;div> &#123;%for x in list[0:1]%}
                    &#123;{value[x]['timestamp']}}&#123;%endfor%}
                  &lt;/div> to: &lt;div>&#123;%for y in list[:-2:-1]%}
                    &#123;{value[y]['timestamp']}}&#123;%endfor%}
                  &lt;/div>
                &lt;/h2>
              &lt;/article>

              &lt;a <span class="type">href</span>="&#123;{url_for('hello_pdf')}}">Get PDF&lt;/a>
              &lt;article> &lt;section>
                 &#123;%for i in value%}&lt;p> &lt;span <span class="type">class</span>="time">
                  &#123;{value[i]['timestamp']}}&lt;/span>
                  &#123;{value[i]['content']}}&lt;/p>&#123;%endfor%}
              &lt;/section> &lt;/article>
            &lt;/div>
          &lt;/body>
        &lt;/html>
         </pre>

         <h4>style.css</h4>

         <p>Le fichier CSS modifie l'apparence des éléments HTML. Tout ce qui est contenu dans le media query <span class="code">@media print</span> gère le document paginé. Par exemple <span class="code">@page</span> permet de déterminer le format des pages ainsi que les marges du document.</p>

         <pre class="prenb pre01">
        <span class="type">body</span> {
          margin: 0;
          padding: 2vw;
          font-size: 2vw;
        }

        <span class="type">p</span> {
          font-family: 'Vremena';
          margin-left: 3vw;
          width: 80vw;
        }

        <span class="type">a</span> {
          display: inline-block !important;
          position: fixed;
          top:6vh;
          right:5vw;
          font-family: 'ReHershey';
          font-size: 2vw;
          box-shadow: 7px 7px 23px 0px <span class="fonction">rgba</span>(255,204,0,1);
          border-radius: 50px;
          padding: 1vw;
          background-color: white;
          z-index: 1000;
          text-decoration: none;
          color: black;
        }

        .time {
          font-family: 'ReHershey';
          margin-right: 8vw;
          margin-left: -2vw;
          letter-spacing: 120%;
        }

       </pre>
       <pre class="prefp">
            <span class="type">@font-face</span> {
              font-family: 'ReHershey';
              src: <span class="fonction">url</span>(fonts/rehersheyitalic-webfont.eot),
                <span class="fonction">url</span>(fonts/rehersheyitalic-webfont.svg),
                <span class="fonction">url</span>(fonts/rehersheyitalic-webfont.ttf),
                <span class="fonction">url</span>(fonts/rehersheyitalic-webfont.woff),
                <span class="fonction">url</span>(fonts/rehersheyitalic-webfont.woff2);
            }

            <span class="type">@font-face</span> {
              font-family: 'Vremena';
              src: <span class="fonction">url</span>(fonts/vremenagrotesk-webfont.eot),
                <span class="fonction">url</span>(fonts/vremenagrotesk-webfont.svg),
                <span class="fonction">url</span>(fonts/vremenagrotesk-webfont.ttf),
                <span class="fonction">url</span>(fonts/vremenagrotesk-webfont.woff),
                <span class="fonction">url</span>(fonts/vremenagrotesk-webfont.woff2);
            }

            <span class="type">article</span> {
              page-break-after: always;
            }

            <span class="type">h2</span> {
              string-set: heading <span class="fonction">content()</span>;
              font-family: 'Vremena';
              font-size: 5vw !important;
              font-weight: normal;
              display: none;
            }

            <span class="type">h2></span><span class="type">div</span> {
              font-family: 'ReHershey';
              margin-left: 5vw;
            }
       </pre>
       <pre class="prefp">
        <span class="type">@media</span> print {
          <span class="type">@page</span> {
            size: 210 297mm;
            padding: 8mm;
            margin: 0mm;
            margin-top: 15mm;
          }
          <span class="type">@page</span> <span class="fonction">:first</span> {
            <span class="type">@top-center</span> {
              content: '';
              display: none;}
            <span class="type">@top-right</span> {
              content: '';
              display: none;}
            <span class="type">@top-left</span> {
              content: '';
              display: none;}
            }
          <span class="type">@page</span> <span class="fonction">:right</span> {
            <span class="type">@top-center</span> {
              font-family: 'Vremena';
              font-size: 24pt;
              content: <span class="fonction">counter(page)</span>;
              text-align: right;
              width: 150mm;
              height: 12mm;}
            <span class="type">@top-left</span> {
              font-family: 'Vremena';
              content: <span class="fonction">string(heading)</span>;
              font-size: 10pt;
              vertical-align: middle;
              margin-top: 20mm;
              color: white;}
              margin-left: 2mm;
            }
          }
         </pre>

         <pre class="prefp">
              <span class="type">@page</span> <span class="fonction">:left</span> {
                <span class="type">@top-center</span> {
                  font-family: 'Vremena';
                  font-size: 24pt;
                  content: <span class="fonction">counter(page)</span>;
                  text-align: left;
                  width: 150mm;
                  height: 12mm;}
                <span class="type">@top-right</span> {
                  font-family: 'Vremena';
                  content: <span class="fonction">string(heading)</span>;
                  font-size: 10pt;
                  vertical-align: middle;
                  margin-top: 20mm;
                  color: white;}
                margin-right: 5mm;
              }

              <span class="type">a</span> {
                display: none !important;
              }

              <span class="type">p</span> {
                font-size: 24pt !important;
                margin-top: 0;
                margin-left: 7mm;
                break-inside: avoid;
              }

              .time {
                margin-right: 25mm !important;
              margin-left: -7mm;
            }
         </pre>
         <pre class="prefp">
        <span class="type">h2</span> {
           font-size: 18pt !important;
           margin-top: -18mm;
           margin-left: 8mm;
           display: inline-block !important;
         }

         <span class="type">h2</span>><span class="type">div</span> {
            margin-left: 10mm;
          }
        }
         </pre>


         <p class="expl_nn">Les fichiers <span class="code">app.py</span> et <span class="code">tweets_json.py</span> doivent être placés à la racine du dossier de l'application, <span class="code">index.html</span> doit se trouver dans un dossier nommé «&nbsp;templates&nbsp;» et <span class="code">style.css</span> dans un dossier nommé «&nbsp;static&nbsp;».</p>

         <p class="expl_nn">Pour lancer l'application entrez dans un terminal (une fois Flask et éventuellement les autres modules Python installés sur votre ordinateur) la commande&nbsp;: <span class="code">python3 app.py</span>.</p>

         <img src="images/tb01.png" class="img_full_page" alt="">
         <img src="images/tb02.png" class="img_full_page" alt="">


         <div class="projet" id="pj54">
           <div class="bloc1">
             <h3>Application <br/>bot Twitter <br/>web-to-print <br/>n°2</h3>
             <div class="cadre">
               <div class="num">

               </div>
             </div>
           </div>

           <div class="logo">
             <img src="images/rpi_logo.png" alt="">
             <img src="images/python.png" alt="">
             <div class="blanc_logo">

             </div>
           </div>

           <div class="bloc_intro">
             <p class="intro">Ce projet est une application web grâce à laquelle on visualisera sur une page HTML des tweets comportant un certain hashtag streamés en temps réel. On pourra générer un PDF de ces tweets mis en page automatiquement dans le navigateur à tout moment.</p>
             <div class="blanc_intro">
             </div>
           </div>
           <div class="remplissage" style="background-image:url('images/tb05_titre.png'); background-position: 41% 40%;">

           </div>
         </div>

         <h4>streamer.py</h4>

         <p>On commence par le script <span class="code">streamer.py</span> car c'est lui qui va lancer le stream Twitter qu'on affichera sur la page web. On utilisera <span class="code">tweepy</span> pour se connecter à notre API. <br/>Ce script commence donc par s'y connecter à l'aide des clés secrètes que vous mettrez dans <span class="code">consumer_key</span>, <span class="code">consumer_secret</span>, <span class="code">access_token</span> et <span class="code">access_secret</span>. Suite à cela on crée l'objet <span class="code">tp.API()</span> dans la variable <span class="code">api</span>.</p>
         <p class="expl_code">On crée le tableau dans lequel on va stocker les tweets (<span class="code">data = []</span>). Ensuite on étend la classe <span class="code">StreamListener</span> de <span class="code">tweepy</span> pour initialiser notre propre streamer, <span class="code">MyStream<br/>Listener()</span>. On utilise la méthode <span class="code">on_<br/>data()</span> de <span class="code">StreamListener</span> qui nous signale quand le stream repère des tweets comportant le hashtag recherché. On convertit alors chaque tweet en chaîne de caractères et on l'ajoute dans le tableau <span class="code">data</span>. <br/>Ensuite on crée une instance de <span class="code">MyStream<br/>Listener()</span> dans la variable <span class="code">myStream<br/>Listener</span>, on lance le stream avec la fonction <span class="code">tp.Stream()</span> et on demande à ce stream de rechercher le hashtag #python.</p>

         <pre class="prenb">
        <span class="type">import</span> tweepy <span class="type">as</span> tp
        <span class="type">import</span> json

        consumer_key = '****'
        consumer_secret = '****'
        access_token = '****'
        access_secret = '****'

        auth = tp.<span class="fonction">OAuthHandler</span>(consumer_key,
        consumer_secret)
        auth.<span class="fonction">set_access_token</span>(access_token,
        access_secret)
        api = tp.<span class="fonction">API</span>(auth)
         </pre>
         <pre id="pre29">
        data = []

        <span class="type">class</span> <span class="fonction">MyStreamListener</span>(tp.StreamListener):
            <span class="type">def</span> <span class="fonction">on_data</span>(self, tweet):
                tweet_data = json.<span class="fonction">loads</span>(tweet)
                data.<span class="fonction">append</span>(tweet_data)

        myStreamListener = <span class="fonction">MyStreamListener</span>()
        myStream = tp.<span class="fonction">Stream</span>(auth = api.auth,
        listener=myStreamListener)

        myStream.<span class="fonction">filter</span>(track=['python'], is_async=<span class="type">True</span>)
         </pre>


         <h4>app.py</h4>

         <p>On importe <span class="code">flask</span> car on développe l'appli sous ce framework Python, <span class="code">streamer</span>, notre autre script Python pour pouvoir récupérer les tweets streamés et <span class="code">flask_weasyprint</span>, le module qui nous permettra de générer un PDF depuis la page web. On crée l'objet <span class="code">Flask</span>, puis on ajoute une extension à Jinja (<span class="code">app.jinja_options['extensions']. append('jinja2.ext.do')</span>) car nous allons devoir utiliser une fonction complexe dans le template HTML.</p>
         <p class="expl_code">On termine par la définition des routes de l'application. La page web qui affiche les tweets sera placée à la racine. On passe au template HTML les tweets streamés à la ligne <span class="code">return render_template('index.<br/>html', len = len(data), value=data)</span>. On crée une deuxième route, <span class="code">@app.route<br/>('/print.pdf')</span>, qui va générer la mise en page des tweets en un document PDF. <br/>Dans la fonction <span class="code">print()</span>, en plus de faire un <span class="code">render_template()</span> du template HTML, <br/>la ligne <span class="code">return render_pdf(HTML(string<br/>=html))</span> va mettre en page le contenu d'après les indications de media paginé données dans <span class="code">style.css</span>.</p>

         <pre class="prenb pre01">
        <span class="type">from</span> flask <span class="type">import</span> *
        <span class="type">from</span> flask_weasyprint <span class="type">import</span> HTML, render_pdf
        <span class="type">from</span> time <span class="type">import</span> sleep
        <span class="type">from</span> streamer <span class="type">import</span> *

        app = <span class="fonction">Flask</span>(__name__)
        app.jinja_options['extensions']\
        .<span class="fonction">append</span>('jinja2.ext.do')
        </pre>
        <pre  id="pre30">
        @app.<span class="fonction">route</span>("/")
        <span class="type">def</span> <span class="fonction">index</span>():
            <span class="type">return</span> <span class="fonction">render_template</span>('index.html',\
            len = <span class="fonction">len</span>(data), value = data)

        @app.<span class="fonction">route</span>('/print')
            <span class="type">def</span> <span class="fonction">print</span>():
            html = <span class="fonction">render_template</span>('index.html',\
            len = <span class="fonction">len</span>(data), value = data)
            <span class="type">return</span> <span class="fonction">render_pdf</span>(<span class="fonction">HTML</span>(string=html))

        <span class="type">if</span> __name__ == '__main__':
            app.<span class="fonction">run</span>(debug=<span class="type">True</span>, host='0.0.0.0')
        </pre>


         <h4>index.html</h4>
         <p>On a vu dans <span class="code">app.py</span> qu'on passait au template HTML la liste des tweets extraits du fichier JSON. On traite donc cette liste dans le template Jinja en faisant appel à des boucles&nbsp;: par exemple dans le premier bloc <span class="code">&lt;article&gt;</span> on parcourt la liste de tweets pour récupérer l'attribut <span class="code">timestamp</span> du premier tweet (<span class="code">&#123;%for x in list[0:1]%} &#123;{value[x]['timestamp']}} &#123;%endfor%}</span>) ainsi que du dernier (<span class="code">&#123;%for y in list[:-2<br/>:-1]%} &#123;{value[y]['timestamp']}} &#123;%endfor%}</span>) pour placer ces deux valeurs dans le contenu de la balise <span class="code">&lt;h2&gt;</span>.<br/>
         Dans la seconde balise <span class="code">&lt;article&gt;</span> on par-court l'ensemble des tweets <span class="code">&#123;%for i in value%}</span> et pour chacun on passe ses attributs <span class="code">timestamp</span> et <span class="code">content</span> dans une balise <span class="code">&lt;p&gt;</span>. Ainsi le contenu de la page HTML est généré dynamiquement.</p>

         <pre class="prenb">
        &lt;!doctype html>
          &lt;html>
            &lt;head>
            &#123;% block head %}
              &lt;link <span class="type">rel</span>="stylesheet"
              <span class="type">href</span>="&#123;{ url_for('static',
              filename='style.css') }}">
              &lt;meta <span class="type">charset</span>="utf-8">
              &lt;meta <span class="type">name</span>="viewport"
              <span class="type">content</span>="width=initial-scale=1.0">
              &lt;meta <span class="type">http-equiv</span>="refresh" <span class="type">content</span>="5" >
            &#123;% endblock %}
            &lt;/head>

            &lt;body>
              &lt;div <span class="type">id</span>="main">
              &#123;%for i in value%}
                &lt;p>&lt;span <span class="type">class</span>="nom" <span class="type">id</span>="&#123;{i.id}}">
                &#123;{i.user.screen_name}}&lt;/span>
                &lt;span <span class="type">class</span>="message">&#123;{i.text}}&lt;/span>
                &lt;/p>
                &#123;%if i.media_url%}
                  &lt;img <span class="type">src</span>="&#123;{i.media_url}}" alt="">
                &#123;%endif%}
                &lt;div <span class="type">class</span>="tweet_dev">
                  &lt;p <span class="type">class</span>="retweet">
                    Retweets: &#123;{i.retweet_count}}
                  &lt;/p>
                  &lt;p <span class="type">class</span>="reply">
                    Replies: &#123;{i.reply_count}}
                  &lt;/p>
                  &lt;p <span class="type">class</span>="fav">
                    Favorited: &#123;{i.favorite_count}}
                  &lt;/p>
                &lt;/div>
              &#123;%endfor%}
         </pre>

         <p>Cette partie du template est utile pour la version imprimée de la page web (en effet on a défini dans le CSS que ce bloc n'est visible que lorsqu'on veut imprimer la page)&nbsp;: il s'agit d'un index des tweets classé par nom d'utilisateur. Afin d'éviter les doublons dans les entrées, on crée un tableau vide <span class="code">prev</span> dans lequel on ajoutera le nom d'utilisateur à l'index que s'il ne fait pas déjà partie de la liste. On classe ensuite l'ensemble des tweets par ordre alphabétique des noms d'utilisateurs avec <span class="code">&#123;% for j in value|sort(attribute="user.screen<br/>_name") %}</span>, et pour chaque tweet, si le nom de l'utilisateur ne figure pas déjà dans la liste (<span class="code">&#123;% if j.user.screen_name not in prev %}</span>), alors on affiche le nom de l'utilisateur dans une balise <span class="code">&lt;a&gt;</span>, et dans tous les cas on affiche la référence de la page (<span class="code">&lt;a class="num" href="#&#123;{j.id}}">&lt;/a></span>), et on ajoute le nom d'utilisateur à la liste avec <span class="code">&#123;% do prev.append(j.user.<br/>screen_name) %}</span>.</p>

         <pre class="prenb">
              &lt;div <span class="type">class</span>="index">
                &lt;p>INDEX&lt;/p>
                &#123;% set prev = [] %}
                &#123;% for j in value|sort(attribute=\
                "user.screen_name") %}
                  &lt;p <span class="type">class</span>="ref">
                  &#123;% if j.user.screen_name not in prev %}
                    &lt;a <span class="type">class</span>="name" <span class="type">href</span>="#&#123;{j.id}}">&lt;/a>
                  &#123;% endif %}
                    &lt;a <span class="type">class</span>="num" <span class="type">href</span>="#&#123;{j.id}}">&lt;/a>
                  &lt;/p>
                  &#123;% do prev.append(j.user.screen_name) %}
                &#123;%endfor%}
              &lt;/div>
            &lt;/div>

            &lt;script <span class="type">type</span>="text/javascript">
              window.scrollTo(0,document.body.scrollHeight);
            &lt;/script>
          &lt;/body>
        &lt;/html>
         </pre>

         <h4>style.css</h4>

         <p>Le fichier CSS modifie l'apparence des éléments HTML. Tout ce qui est contenu dans le media query <span class="code">@media print</span> gère le document paginé. Par exemple <span class="code">@page</span> permet de déterminer le format des pages ainsi que les marges du document.</p>

         <pre class="prenb pre01">
        <span class="type">body</span> {
          margin: 0;
          padding: 0;
          font-family: 'VG5000';
        }

        #main {
          font-size: 3vw;
        }

        <span class="type">p</span> {
          padding: 2vw;
          margin: 0;
          border-top: 2px solid black;
          border-bottom: 0px solid white;
        }

        <span class="type">span</span>.nom {
          margin-right: 10vw;
          margin-left: 2vw;
          color: red;
          string-set: heading <span class="fonction">content</span>();
        }

        .index {
          display: none;
        }

        .tweet_dev {
          display: flex;
          flex-direction: row;
          border-top: 2px solid black;
          justify-content: flex-start;
          margin-left: 60vw;
          width: 40vw;
          font-size: 2vw;
        }
       </pre>
       <pre class="prefp">
            .tweet_dev > <span class="type">p</span> {
              border: 0px solid white;
            }


            <span class="type">@font-face</span> {
              font-family: 'VG5000';
              src: <span class="fonction">url</span>(fonts/VG5000-Regular_web.eot),
                <span class="fonction">url</span>(fonts/VG5000-Regular_web.ttf),
                <span class="fonction">url</span>(fonts/VG5000-Regular_web.woff),
                <span class="fonction">url</span>(fonts/VG5000-Regular_web.woff2);
            }

            <span class="type">@media</span> print {
              <span class="type">@page</span> {
                size: 100mm 140mm !important;
                padding: 0mm;
                margin: 10mm;
                <span class="type">@top-left</span> {
                  content: <span class="fonction">string</span>(heading);
                  display: inline-block !important;
                  color: red;
                  font-family: 'VG5000';
                  font-size: 12pt;
                  text-align: left;
                  vertical-align: bottom;
                  width: 90mm;
                  height: 18mm;
                }
              }
       </pre>
       <pre class="prefp">
          <span class="type">@page</span> <span class="fonction">:right</span> {
            margin-left: 8mm;
            <span class="type">@bottom-right</span> {
              content: <span class="fonction">counter</span>(page);
              font-family: 'VG5000';
              font-size: 10pt;
              text-align: right;
              vertical-align: top;
              width: 8mm;
              margin-left: 3mm;
              height: 5mm;
            }
          }

          <span class="type">@page</span> <span class="fonction">:left</span> {
            margin-left: 8mm;
            <span class="type">@bottom-left</span> {
              content: <span class="fonction">counter</span>(page);
              font-family: 'VG5000';
              font-size: 10pt;
              text-align: left;
              vertical-align: top;
              width: 5mm;
              height: 5mm;
            }
          }

          <span class="type">@page</span> index {
            <span class="type">@top-left</span> {
              content: none; }
            <span class="type">@bottom-left</span> {
              content: none; }
            <span class="type">@bottom-right</span> {
              content: none; }
            }
          }
         </pre>

         <pre class="prefp">
              .index {
                display: inherit;
                columns: 2 !important;
              }

              <span class="type">span</span>.nom {
                color: white !important;
                display: block;
              }

              <span class="type">p</span>.ref {
                page: index;
                margin-left: 0mm;
                font-size: 8pt;
              }

              <span class="type">p</span> {
                font-size: 16pt !important;
                margin-left: 15mm;
                border-top: 0px solid white;
              }

              <span class="type">a</span> {
                font-size: 11pt;
              text-decoration: none;
              color: black;
            }

            <span class="type">a</span>.name<span class="fonction">::before</span> {
              content: <span class="fonction">target-text</span>(<span class="fonction">attr</span>(href));
            }

            <span class="type">a</span>.num<span class="fonction">::after</span> {
              content: <span class="fonction">target-counter</span>(<span class="fonction">attr</span>(href), page);
            }

        </pre>
        <pre class="prefp">

          <span class="type">a</span>.name {
            margin-right: 10mm;
          }

          <span class="type">a</span>.num {
            margin-left: 15mm;
            margin-top: 0;
            margin-bottom: 2mm;
          }

          .tweet_dev {
            page-break-after: always;
            flex-direction: column;
            justify-content: flex-start;
            border-top: 0px solid white;
            width: 30mm;
            height: 50mm;
            margin-top: -6mm;
          }

          .tweet_dev > <span class="type">p</span> {
            margin: 0;
            margin-left: 10mm;
            padding-top: 10mm;
            font-size: 12pt !important;
            width: 30mm;
          }

          .tweet_dev > <span class="type">p</span><span class="fonction">:not</span>(<span class="fonction">:last-of-type</span>){
            border-bottom: 1px solid black;
          }
        }
         </pre>


         <p class="expl_nn">Les fichiers <span class="code">app.py</span> et <span class="code">streamer.py</span> doivent être placés à la racine du dossier de l'application, <span class="code">index.html</span> doit se trouver dans un dossier nommé «&nbsp;templates&nbsp;» et <span class="code">style.css</span> dans un dossier nommé «&nbsp;static&nbsp;».</p>

         <p class="expl_nn">Pour lancer l'application entrez dans un terminal (une fois Flask et éventuellement les autres modules Python installés sur votre ordinateur) la commande&nbsp;: <span class="code">python3 app.py</span>, puis ouvrez un navigateur à l'adresse <span class="code">nom_du_raspberry_pi.<br/>local:5000</span>.</p>

         <img src="images/tb03.png" class="img_full_page" alt="">
         <img src="images/tb05.png" class="img_full_page" alt="">
         <img src="images/tb06.png" class="img_full_page" alt="">

         <div class="page_blanche">

         </div>

         <div class="annexe" id="gloss">
           GLOSSAIRE
         </div>
         <div class="glossaire">
           <div class="lettre">
             A
           </div>
           <div class="entree">
             <span>Alimentation</span>
             Source d'énergie. Dans les projets de ce recueil, on utilise le port USB d'un ordinateur ou une pile. Habituellement la tension de l'alimentation est indiquée sur celle-ci ainsi que le courant maximal qu'elle peut débiter.
           </div>
           <div class="entree">
             <span>Analogique (signal)</span>
             Signal électrique qui peut varier dans le temps.
           </div>
           <div class="entree col_break">
             <span>Anode</span>
             Côté positif d'un condensateur ou d'une diode (qui doit être connecté à l'alimentation).
           </div>
           <div class="entree">
             <span>Arduino</span>
             Carte électronique dotée d'un micro-contrôleur programmable en C via un environnement de programmation dédié.
           </div>
           <div class="entree">
             <span>Argument</span>
             Donnée que l'on passe à une fonction en l'appelant. Toutes les fonctions ne prennent pas d'argument.
           </div>
           <div class="lettre">
             B
           </div>
           <div class="entree col_break">
             <span>Baud</span>
             Diminutif de bit par seconde. Représente la vitesse à laquelle les ordinateurs communiquent entre eux.
           </div>
           <div class="entree">
             <span>Bit</span>
             Unité binaire de quantité d'information (ne peut valoir que 0 ou 1).
           </div>
           <div class="entree">
             <span>Booléen</span>
             Type de donnée ne pouvant valoir que Vrai ou Faux.
           </div>
           <div class="lettre">
             C
           </div>
           <div class="entree">
             <span>C</span>
             Langage de programmation compilé orienté objet. Arduino utilise ce langage.
           </div>
           <div class="entree">
             <span>Capteur</span>
             Composant capable de mesurer une grandeur physique et de la convertir en signal électrique dans le but d'établir une mesure ou une commande.
           </div>
           <div class="entree">
             <span>Cathode</span>
             Côté d'une diode devant être relié à la terre.
           </div>
           <div class="entree col_break">
             <span>Charge (électrique)</span>
             Puissance fournie par un dispositif, pouvant être transformée en autre chose (lumière, chaleur, son).
           </div>
           <div class="entree">
             <span>Circuit (électrique)</span>
             Chemin partant d'une alimentation, traversant une charge et terminant à la terre. Le courant ne circule que si tous les chemins du circuit sont ininterrompus.
           </div>
           <div class="entree">
             <span>Circuit intégré (CI)</span>
             Circuit intégré dans du silicone ou du plastique dont les broches extérieures per-mettent d'interagir avec la circuiterie interne.
           </div>
           <div class="entree">
             <span>Classe</span>
             En programmation, constructeur d'objet.
           </div>
           <div class="entree">
             <span>CNC</span>
             Machine-outil à commande numérique («&nbsp;computer numerical control&nbsp;» en anglais). On désigne souvent les fraiseuses numériques par le terme « CNC », mais en réalité il existe bien d'autres types de machines CNC.
           </div>

           <div class="entree col_break">
             <span>Condensateur</span>
             Composant électronique capable de stocker une charge électrique, principalement utilisé pour stabiliser une alimentation ou filtrer des signaux périodiques.
           </div>
           <div class="entree">
             <span>Constante</span>
             Variable nommée dont la valeur ne changera pas au cours du programme.
           </div>
           <div class="entree">
             <span>Courant</span>
             Flot de charges électriques passant dans un circuit fermé, mesuré en Ampères.
           </div>
           <div class="entree">
             <span>Courant alternatif</span>
             Courant dont la direction change périodiquement.
           </div>
           <div class="entree">
             <span>Courant continu</span>
             Courant allant toujours dans la même direction.
           </div>
           <div class="entree">
             <span>Court-circuit</span>
             Connexion accidentelle ou involontaire de plusieurs points d'un circuit électrique se trouvant normalement à des tensions différentes.
           </div>
           <div class="entree">
             <span>CSS</span>
             «&nbsp;Cascading Style Sheets&nbsp;» en anglais, langage informatique permettant de gérer le style des pages web.
           </div>

           <div class="entree">
             <span>Cura</span>
             Logiciel open source de type slicer pour l'impression 3D.
           </div>
           <div class="lettre">
             D
           </div>
           <div class="entree">
             <span>Debug</span>
             Exercice consistant à parcourir le code à la recherche d'erreurs empêchant le fonctionnement attendu d'un programme.
           </div>
           <div class="entree">
             <span>Découpe laser</span>
             Procédé de fabrication consistant à découper la matière grâce à une grande quantité d’énergie générée par un laser et concentrée sur une très faible surface.
           </div>
           <div class="entree">
             <span>Digital (signal)</span>
             Signal électrique dont la valeur ne peut être que de 0 ou 1.
           </div>
           <div class="entree">
             <span>Diode</span>
             Composant électronique dans lequel le courant ne peut circuler que dans un sens.
           </div>

           <div class="lettre">
             E
           </div>
           <div class="entree  col_break">
             <span>Électricité</span>
             Énergie générée par des charges électriques.
           </div>
           <div class="entree">
             <span>Électronique</span>
             Branche de la physique appliquée, utilisant l'électricité comme support pour le traitement, la transmission et le stockage d'informations.
           </div>
           <div class="entree">
             <span>ESP8266</span>
             Carte électronique équipée d'un micro-contrôleur et d'une connexion Wi-Fi, programmable via l'IDE Arduino ou en MicroPython.
           </div>
           <div class="lettre">
             F
           </div>
           <div class="entree">
             <span>Flask</span>
             Framework Python dédié au développement d'applications web.
           </div>
           <div class="entree">
             <span>Float</span>
             Donnée numérique pouvant être exprimée sous forme de fraction, écrite sous forme de nombre décimal.
           </div>
           <div class="entree col_break">
             <span>Flora (Adafruit)</span>
             Micro-contrôleur programmable via l'IDE Arduino, il a la particularité de posséder des broches perforées pouvant être cousues.
           </div>
           <div class="entree">
             <span>Fonction</span>
             Bloc de code écrit pour exécuter une tâche spécifique.
           </div>
           <div class="entree">
             <span>Fraisage numérique</span>
             Procédé d'usinage par enlèvement de matière réalisé par une machine-outil (CNC).
           </div>
           <div class="entree">
             <span>Freecad</span>
             Logiciel open source de modélisation 3D paramétrique.
           </div>
           <div class="lettre">
             G
           </div>
           <div class="entree">
             <span>G-CODE</span>
             Langage informatique utilisé pour contrôler une machine à commande numérique, diminutif de Geometric code.
           </div>
           <div class="entree">
             <span>Gravure laser</span>
             Méthode de fabrication soustractive, qui se base sur l’utilisation d’un faisceau laser pour altérer la surface d’un objet.
           </div>
           <div class="entree">
             <span>Ground</span>
             Point d'un circuit où la tension électrique est la plus faible, aussi appelé la terre ou la masse.
           </div>

           <div class="lettre">
             H
           </div>
           <div class="entree">
             <span>HTML</span>
             «&nbsp;HyperText Markup Language&nbsp;», langage informatique de balisage permettant de structurer les pages web.
           </div>
           <div class="lettre">
             I
           </div>
           <div class="entree">
             <span>I2C</span>
             Dispositif informatique de transmission de données entre deux micro-contrôleurs ou micro-processeurs.
           </div>
           <div class="entree col_break">
             <span>IDE</span>
             Environnement de développement intégré («&nbsp;Integrated Development Environment&nbsp;» en anglais). Arduino et Processing possèdent leurs propres IDE.
           </div>
           <div class="entree">
             <span>Impression 3D</span>
             Procédé technologique permettant la reproduction matérielle d'un modèle 3D par ajout de matière. Les principales techniques d'impression 3D sont le FDM (filament), la résine et le SLS (poudre).
           </div>
           <div class="entree">
             <span>Index</span>
             En programmation, position d'un élément dans un tableau à laquelle on se réfère pour appeler l'élément.
           </div>
           <div class="entree">
             <span>Inkscape</span>
             Logiciel libre de dessin vectoriel gérant des formats standard comme XML et SVG.
           </div>
           <div class="entree">
             <span>Instance</span>
             En programmation orientée objet, objet constituant un exemplaire d'une classe.
           </div>
           <div class="entree">
             <span>Int (Integer)</span>
             Donnée numérique écrite sous forme de nombre entier.
           </div>
           <div class="entree col_break">
             <span>Interrupteur</span>
             Composant pouvant ouvrir ou fermer un circuit électrique.
           </div>
           <div class="lettre" style="margin-top: 0mm;">
             J
           </div>
           <div class="entree">
             <span>Java</span>
             Langage de programmation orienté objet, utilisé par Processing.
           </div>
           <div class="entree">
             <span>Javascript</span>
             Langage de programmation de scripts employé dans les pages web interactives et pour les serveurs.
           </div>
           <div class="lettre">
             L
           </div>
           <div class="entree">
             <span>LED</span>
             «&nbsp;Light Emitting Diode&nbsp;», diode électro-luminescente en français. Type de diode pouvant produire de la lumière.
           </div>
           <div class="entree col_break">
             <span>Librairie</span>
             Morceau de code qui étend les fonctionnalités d'un programme, généralement dédié à un type d'utilisation particulier.
           </div>
           <div class="entree">
             <span>Ligne de commande</span>
             Dans un système UNIX, instruction textuelle donnée dans un terminal pour interagir avec le système informatique.
           </div>
           <div class="entree">
             <span>Linux</span>
             Système d'exploitation open source pouvant être utilisé sur différentes plateformes.<br/>Linux est, au sens restreint, le noyau de système d'exploitation Linux, et au sens large, tout système d'exploitation fondé sur le noyau Linux.
           </div>
           <div class="entree col_break">
             <span>Logiciel libre</span>
             Logiciel dont l'utilisation, l'étude, la modification et la duplication par autrui en vue de sa diffusion sont permises, techniquement et légalement, ceci afin de garantir certaines libertés induites, dont le contrôle du programme par l'utilisateur et la possibilité de partage entre individus. Ces droits peuvent être simplement disponibles (domaine public), ou bien établis par une licence dite « libre », basée sur le droit d'auteur.
           </div>
           <div class="lettre" style="margin-top: 0mm;">
             M
           </div>
           <div class="entree">
             <span>Mach3</span>
             Logiciel de commande de machine, il transforme un PC en contrôleur de CNC.
           </div>
           <div class="entree">
             <span>Méthode</span>
             En programmation orientée objet, fonction appartenant à une classe.
           </div>
           <div class="entree">
             <span>Micro-contrôleur</span>
             Circuit intégré doté d'un processeur, de mémoire et d'interfaces d'entrées-sorties. Une carte Arduino en comporte un.
           </div>
           <div class="entree">
             <span>Moniteur série</span>
             Outil intégré à l'IDE Arduino permettant d'afficher des données transitant par une carte branchée.
           </div>
           <div class="lettre">
             N
           </div>
           <div class="entree">
             <span>Numérique</span>
             Système de valeurs ne connaissant que deux états&nbsp;: allumé ou éteint.
           </div>
           <div class="lettre">
             O
           </div>
           <div class="entree">
             <span>Objet</span>
             En programmation, conteneur symbolique et autonome qui contient des informations et des mécanismes pouvant être manipulés dans un programme.
           </div>
           <div class="entree">
             <span>Open source (logiciel)</span>
             Programme dont le code source est ouvert, et dont la licence respecte les critères suivants&nbsp;: possibilité de libre redistribution, d'accès au code source et de création de travaux dérivés. Pour autant, un programme dont le code source est ouvert n'est pas forcément libre.
           </div>
           <div class="lettre">
             P
           </div>
           <div class="entree col_break">
             <span>Parallèle (montage)</span>
             Montage électronique accordant aux composants la même tension à leurs bornes.
           </div>
           <div class="entree">
             <span>Paramètre</span>
             Variable locale lorsqu'on déclare une fonction, rem-placée par un argument à l'appel de celle-ci.
           </div>
           <div class="entree">
             <span>Paramétrique (logiciel)</span>
             Mode de fonctionnement de logiciels de modélisation 3D dans lequel on définit une entité par des paramètres pouvant être modifiés.
           </div>
           <div class="entree">
             <span>Période</span>
             Laps de temps pendant lequel une fréquence se produira.
           </div>
           <div class="entree">
             <span>Photorésistance</span>
             Composant dont la résistance varie en fonction de la quantité de lumière qu'il perçoit.
           </div>
           <div class="entree">
             <span>Polarisé (composant)</span>
             Composants dont les pattes doivent être connectées dans un certain sens pour bien fonctionner.
           </div>
           <div class="entree">
             <span>Pont diviseur de tension</span>
             Circuit dont la tension de sortie est une fraction de la tension d'alimentation. On obtient généralement ce procédé en connectant en série des résistances.
           </div>
           <div class="entree">
             <span>Port série</span>
             Port par lequel Arduino communique avec un ordinateur. La communication se fait par l'envoi d'un bit à la fois selon un ordre précis.
           </div>
           <div class="entree">
             <span>Processing</span>
             Environnement de programmation open source utilisant le langage Java, permettant notamment de créer des visuels génératifs.
           </div>
           <div class="entree">
             <span>PWM</span>
             «&nbsp;Pulse Width Modulation&nbsp;», modulation en largeur d'impulsion en français. Simulation de signal analogique en changeant continuellement l'état d'une broche. On joue sur la fréquence de cette alternance pour faire varier la valeur analogique.
           </div>
           <div class="entree col_break">
             <span>Python</span>
             Langage de programmation interprété orienté objet.
           </div>
           <div class="lettre" style="margin-top:0;">
             R
           </div>
           <div class="entree">
             <span>Raspberry Pi</span>
             Nano-ordinateur monocarte open source, principalement exécuté avec un système d'exploitation Linux (Raspberry Pi OS).
           </div>
           <div class="entree">
             <span>Repetier Host</span>
             Logiciel open source de type slicer pour l'impression 3D.
           </div>
           <div class="entree">
             <span>Résistance</span>
             Capacité d'un matériau ou d'un composant à laisser plus ou moins bien circuler un courant à travers lui. Exprimée en Ohms (Ω).
           </div>
           <div class="lettre">
             S
           </div>
           <div class="entree">
             <span>Série (montage)</span>
             Montage électronique dans lequel le courant traverse successivement les composants.
           </div>
           <div class="entree col_break">
             <span>Sketch</span>
             Nom donné aux projets dans l'IDE Arduino.
           </div>
           <div class="entree">
             <span>Slicer</span>
             Logiciel dédié à la préparation de l'impression 3D, qui tranche l'objet 3D en un ensemble de couches superposées et génère le fichier G-CODE.
           </div>
           <div class="lettre">
             T
           </div>
           <div class="entree">
             <span>Tableau</span>
             En programmation, type de variable pouvant contenir plusieurs variables auxquelles on accède par leurs numéros d'index.
           </div>
           <div class="entree">
             <span>Tension</span>
             Différence de potentiel électrique (le terme «&nbsp;potentiel électrique&nbsp;» remplace d'ailleurs parfois le mot «&nbsp;tension&nbsp;») dans la circulation d'un courant entre un point A et un point B d'un circuit, mesurée en Volts.
           </div>
           <div class="entree col_break">
             <span>Terre</span>
             Point d'un circuit où la tension électrique est la plus faible, aussi appelé le ground ou la masse.
           </div>
           <div class="entree">
             <span>Type de données</span>
             Classification des différentes valeurs que peut prendre une donnée en programmation. <br/>Les types communs à un grand nombre de langages de programmation sont&nbsp;: Integer (int), Float, Boolean.
           </div>
           <div class="lettre">
             U
           </div>
           <div class="entree">
             <span>Usinage</span>
             Réalisation d'une pièce par enlèvement de matière à l'aide d'une machine-outil.
           </div>
           <div class="lettre">
             V
           </div>
           <div class="entree col_break">
             <span>Variable</span>
             Information identifiée par un nom ou par une adresse mémoire dans un programme, pouvant prendre des valeurs de différents types (nombre, booléen, chaîne de caractères).
           </div>
           <div class="entree">
             <span>Variable globale</span>
             Variable à laquelle on peut accéder depuis n'importe où dans un programme.
           </div>
           <div class="entree">
             <span>Variable locale</span>
             Variable qui n'est créée et accessible que dans une partie d'un programme, pour un temps donné.
           </div>
           <div class="lettre">
             W
           </div>
           <div class="entree">
             <span>Weasyprint</span>
             Librairie Python dédiée à la mise en page de documents à partir de fichiers HTML.
           </div>
           <div class="entree">
             <span>Web-to-print</span>
             Ensemble de procédés de mise en page de documents depuis des interfaces web dédiées.
           </div>
         </div>

         <div class="annexe" style="margin-top:7mm;left:-26mm;" id="liens">
           LIENS UTILES
         </div>
         <div class="glossaire" style="margin-left:0mm;column-gap:14mm;width:110mm;">
           <div class="entrees">
             <span style="margin-top:0;">Modélisation 3D</span>
             <div class="ressource">
               Documentation de Freecad
               <span>wiki.freecadweb.org</span>
             </div>
             <div class="ressource">
               OpenSCAD (logiciel de modélisation paramétrique)
               <span>openscad.org</span>
             </div>
             <div class="ressource">
               Chaîne Youtube de CAD Printer (tutoriels Freecad en français)
             </div>
             <div class="ressource">
               Thingiverse (modèles 3D disponibles en open source)
               <span>thingiverse.com</span>
             </div>
           </div>
           <div class="entrees">
             <span>Impression 3D</span>
             <div class="ressource">
               Glossaire de l'impression 3D de RepRap
               <span>reprap.org/wiki/<br/>Glossary</span>
             </div>
             <div class="ressource">
               Documentation de Repetier Host
               <span>repetier.com/<br/>documentation/<br/>repetier-host/</span>
             </div>
           </div>
           <div class="entrees">
             <span>Découpe laser</span>
             <div class="ressource">
               Documentation d'Inkscape
               <span>inkscape-manuals<br/>.readthedocs.io</span>
             </div>
             <div class="ressource">
               Tutoriel Inkscape basique
               <span>inkscape.org/doc/basic/<br/>tutorial-basic.fr.html</span>
             </div>
             <div class="ressource">
               QCAD (logiciel de dessin 2D paramétrique)
               <span>qcad.org/fr/</span>
             </div>
           </div>

           <div class="entrees">
             <span>CNC</span>
             <div class="ressource">
               Documentation de l'atelier Path de Freecad
               <span>wiki.freecadweb.org/<br/>Path_Workbench</span>
             </div>
             <div class="ressource">
               FlatCam (logiciel générateur de G-Code pour circuits imprimés)
               <span>flatcam.org/</span>
             </div>
           </div>
           <div class="entrees">
             <span>Arduino</span>
             <div class="ressource">
               Documentation Arduino
               <span>arduino.cc/en/<br/>Tutorial/HomePage</span>
             </div>
             <div class="ressource">
               Dépôt Git des projets présentés
               <span>gitlab.com/ameliedumont/<br/>cityfab-2/-/tree/<br/>master/Arduino</span>
             </div>
           </div>
           <div class="entrees">
             <span>Raspberry Pi</span>
             <div class="ressource">
               Documentation officielle de la Raspberry Pi Foundation
               <span>raspberrypi.org/<br/>documentation/</span>
             </div>
             <div class="ressource">
               Dépôt Git des projets présentés
               <span>gitlab.com/ameliedumont/<br/>cityfab-2/-/tree/<br/>master/Raspberry Pi</span>
             </div>
             <div class="ressource">
               Lignes de commande Linux
               <span>linuxtrainingacademy.com/<br/>linux-commands-cheat-sheet/</span>
             </div>
           </div>
         </div>


         <div class="annexe" id="col">
           COLOPHON
         </div>
         <div class="glossaire">
           <div class="entrees">
             <span style="margin-top:0">Contenu</span>
               Amélie Dumont, dans le cadre des workshops préparés pour le fablab Cityfab2 à Bruxelles entre décembre 2019 et mai 2020
             <span>Design graphique et relecture</span>
                 Amélie Dumont
             <span>Typographies</span>
             <div class="ressource">
               Elaine Sans, par Wei Huang
             </div>
             <div class="ressource">
               Snapit Mono, par Corentin Moussard et Morgane Bartoli
             </div>
             <div class="ressource">
               Fablab, par Amélie Dumont (fonte dessinée dans Freecad)
             </div>
             <div class="ressource col_break">
               Elaine Test, par Amélie Dumont (fonte modifiée avec Processing et Opentype.js)
             </div>
             <span style="margin-top:0">Outils utilisés</span>
               Paged.js, Gimp, Inkscape, Freecad, Opentype.js
               <span>Impression</span>
                 AJM Print-shop, Bruxelles, octobre 2020
           </div>
         </div>

  </body>
</html>
