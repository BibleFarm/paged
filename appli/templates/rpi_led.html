<!doctype html>
<html>
  <head>
    {% block head %}
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>{% block title %}Cityfab2.docs{% endblock %}</title>
    {% endblock %}
  </head>

  <body>
    <div id="entete">
      <a href="/">Cityfab2.docs</a>
    </div>
      <ul id="menu">
        <li><a href="/ressources_pedagogiques">Ressources pédagogiques</a></li>
        <li>Liens</li>

      </ul>

      <div class="print">
        <a href="/rpi_led.pdf">Version PDF</a>
      </div>
      <div class="previous">
        <p>Raspberry Pi</p>
      </div>

      <div class="main">
        <h3>Faire clignoter une LED</h3>
        <p class="circuitb">Un Raspberry Pi est pourvu de broches GPIO qui nous permettent d'y brancher des composants électroniques. De la même façon que le ferait une carte Arduino, le Raspberry Pi est capable de lire et d'envoyer des signaux électriques à des composants branchés à ses broches GPIO.</p>
        <div id="schemas"><img id="img_rpi01" class="scheme" src="{{ url_for('static', filename='rpi_led.svg') }}" alt=""></div>
        <div id="onglets">
          <div id="onglet_code" onclick="codeTop()">Script Python</div>
          <div id="onglet_circuit" onclick="circuitTop()">Circuit</div>
        </div>

        <p class="circuit">Il existe deux façons de cartographier les broches GPIO d'un Raspberry Pi&nbsp;: BCM et BOARD. Le résultat sera le même mais selon la méthode choisie on ne référence pas les broches avec la même numérotation. En mode BOARD, les broches sont numérotées selon leur disposition physique sur la carte si on la lit de gauche à droite et de haut en bas. En mode BCM, les broches sont numérotées selon la «&nbsp;Broadcom SOC channel&nbsp;», il faut se référer à un schéma du Raspberry Pi pour connaître leur disposition.<br/> Dans ce premier circuit on va utiliser les broches en mode BCM.</p>
        <ol>
          <li>Branchez la LED d'un côté à l'une des broches 5V du Raspberry, et l'autre à l'une des broches GROUND par l'intermédiaire d'une résistance de 220Ω.</li>
        </ol>
        <div id="block_code">
          <p>Script Python</p>
          <pre class="code_full">

  <span class="type">import</span> <span class="fonction">RPi.GPIO</span> <span class="type">as</span> GPIO
  <span class="type">import</span> time

  GPIO.<span class="fonction">setmode</span>(GPIO.BCM)
  GPIO.<span class="fonction">setwarnings</span>(<span class="type">False</span>)

  led = 4

  GPIO.<span class="fonction">setup</span>(led,GPIO.OUT)

  <span class="type">for</span> i <span class="type">in</span> <span class="fonction">range</span>(5):
      <span class="fonction">print</span> "LED on"
      GPIO.<span class="fonction">output</span>(led,1)
      time.<span class="fonction">sleep</span>(2)
      <span class="fonction">print</span> "LED off"
      GPIO.<span class="fonction">output</span>(led,0)
      time.<span class="fonction">sleep</span>(2)

        </pre>
      </div>

      <h4>LE CODE</h4>

        <pre>

  <span class="type">import</span> <span class="fonction">RPi.GPIO</span> <span class="type">as</span> GPIO
  <span class="type">import</span> time
        </pre>
        <p>Python est un langage de programmation très puissant qui peut interagir avec les Raspberry Pi. Il fonctionne par l'importation de modules, de différents morceaux de code que l'on peut combiner.</p>
        <p>Les deux premières lignes du script font appel aux deux modules dont nous allons avoir besoin ici&nbsp;: <span class="code">RPi.GPIO</span> (pour inetragir avec les broches GPIO) et <span class="code">time</span> pour pouvoir exprimer des délais temporels.</p>
        <pre>

  GPIO.<span class="fonction">setmode</span>(GPIO.BCM)
  GPIO.<span class="fonction">setwarnings</span>(<span class="type">False</span>)

  led = 4

  GPIO.<span class="fonction">setup</span>(led,GPIO.OUT)
        </pre>
        <p>Ensuite, de façon similaire à ce que nous ferions en Arduino, nous initialisons les broches et leurs modes. <span class="code">GPIO.setmode(GPIO.BCM)</span> nous sert à dire au Raspberry Pi qu'il doit prendre en compte le numérotage des broches en mode BCM. <span class="code">GPIO.setwarnings(False)</span> sert à empêcher le script d'afficher des avertissements dans le terminal. On déclare la variable <span class="code">led</span> sur la broche 4 (en mode BCM toujours), puis on initialise le mode de la broche avec <span class="code">GPIO.setup(led,GPIO.OUT)</span> qui prend comme arguments le numéro de la broche et son mode (ici <span class="code">OUT</span>).</p>
        <pre>

  <span class="type">for</span> i <span class="type">in</span> <span class="fonction">range</span>(5):
      <span class="fonction">print</span> "LED on"
      GPIO.<span class="fonction">output</span>(led,1)
      time.<span class="fonction">sleep</span>(2)
      <span class="fonction">print</span> "LED off"
      GPIO.<span class="fonction">output</span>(led,0)
      time.<span class="fonction">sleep</span>(2)
        </pre>
        <p>Le reste du script est une boucle qui répètera le code 5 fois. <span class="code">for i in range(5):</span> signifie que la boucle va se répéter jusqu'à ce que <span class="code">i</span> vale 5 (il vaut initialement 0). 5 fois donc, on va afficher dans le terminal <span class="code">"led ON"</span>, puis envoyer un signal électrique à la broche de la LED avec <span class="code">GPIO.output(led,1)</span>, et ce pendant 2 secondes car la ligne suivant est&nbsp;: <span class="code">time.sleep(2)</span>, ce qui implique que l'action demandée à la ligne précédente va restrer active pendant ce délai. Puis on fait le code inverse&nbsp;: on affiche <span class="code">"led OFF"</span> dans le terminal, on n'envoie plus de signal électrique vers la LED (<span class="code">GPIO.output(led,0)</span>), et ce pendant 2 secondes également.</p>
        <p>Une fois toutes les actions de la boucle réalisées, on repasse par chacune des étapes 4 autres fois.</p>

    <script type="text/javascript" src="{{ url_for('static', filename='script.js') }}"></script>
  </body>
</html>
