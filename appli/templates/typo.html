<!doctype html>
<html>
  <head>
    {% block head %}
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>{% block title %}Cityfab2.docs{% endblock %}</title>
    <script src="https://greasyfork.org/scripts/20469-opentype-js/code/opentypejs.js?version=130870"></script>
    <script src="https://cdn.jsdelivr.net/npm/opentype.js@latest/dist/opentype.min.js"></script>

        <style>
        .container {
            width: 940px;
            margin-left: auto;
            margin-right: auto;
        }
        #glyphs {
            clear: both;
        }
        .wrapper {
            float: left;
            margin: 5px;
            border: 1px solid #ccc;
        }
        .wrapper span {
            text-align: center;
            background: #ddd;
            display: block;
        }
    </style>
    {% endblock %}
  </head>

  <body style="background-color: white;">

    <div class="container">
      <button onclick="fontDownload()">Download Font</button>

      <div id="glyphs"></div>
      <canvas id="canvas" width="1300" height="300"></canvas>
    </div>

    <script type="text/javascript">
    const font = opentype.load('../static/fonts/reelaine-webfont.ttf', function(err, font) {
    if (err) {
        alert('Font could not be loaded: ' + err);
    } else {
        // Now let's display it on a canvas with id "canvas"
  //       function createGlyphCanvas(glyph, size) {
	//   var canvasId, html, glyphsDiv, wrap, canvas, ctx;
	//   canvasId = 'c' + glyph.index;
	//   html = '<div class="wrapper" style="width:' + size + 'px"><canvas id="' + canvasId + '" width="' + size + '" height="' + size + '"></canvas><span>' + glyph.index + '</span><span>' + glyph.name + '</span><span>U ' + glyph.unicode + '</span></div>';
	//   glyphsDiv = document.getElementById('glyphs');
	//   wrap = document.createElement('div');
	//   wrap.innerHTML = html;
	//   glyphsDiv.appendChild(wrap);
	//   canvas = document.getElementById(canvasId);
	//   ctx = canvas.getContext('2d');
	//   return ctx;
	// }
  function getRandomInt(min, max) {
     return min + Math.floor(Math.random() * (max - min + 1));
 }

  const context = document.getElementById('canvas').getContext('2d');
  const path = font.getPath('Modélisation 3D', 0, 150, 110);
  const aw = font.getAdvanceWidth('RESSOURCES PÉDAGOGIQUES', 36);

        // If you just want to draw the text you can also use font.draw(ctx, text, x, y, fontSize).
        path.draw(context);

        console.log(aw);
        let ok = 0;

        for(let i of path.commands) {
        let nbr = getRandomInt(0,10);


          //console.log(i);
          if(i.type == 'L') {
            if(ok%3 == 0) {
              if(nbr != 0) {
                context.beginPath();
                context.fillStyle = "white";
                context.arc(i.x, i.y, 3.5, 0, 2 * Math.PI);
                context.fill();
                context.stroke();
              } else {
                context.beginPath();
                context.fillStyle = "#668cff";
                context.arc(i.x, i.y, 3.5, 0, 2 * Math.PI);
                context.fill();
                context.stroke();
              }
            }

          }

          ok += 1;
        }

  // Construct a Path object containing the letter shapes of the given text.
  // The other parameters are x, y and fontSize.
  // Note that y is the position of the baseline.
  console.log(path);

}
        // let phrase = font.glyphs;
        // let lglyphes = Object.values(phrase);
        // let glyphes = lglyphes[1];
        // let glyphes_values = Object.values(glyphes)
        //
        //
        //
        //
        // function getRandomInt(min, max) {
        //   return min + Math.floor(Math.random() * (max - min + 1));
        // }
        //
        // let newGlyphs = [];
        //
        // for(let i of glyphes_values) {
        //
        //   let iPath = new opentype.Path();
        //   let nom = i.name;
        //   let uni = i.unicode;
        //   let aw = i.advanceWidth;
        //   iPath.fillStyle = "black";
        //   var com = i.path.commands;
        //   //console.log(com);
        //   //console.log(i); // tableau d'objets
        //   com.forEach(function(item, index) {
        //     //console.log(item);
        //     if(item.type == 'L') {
        //       context.beginPath();
        //       context.arc(item.x, item.y, 10, 0, 2 * Math.PI);
        //       context.stroke();
        //     }

        //   let nbr = getRandomInt(-20, 20);
        //   let nbr2 = getRandomInt(-20, 20);
        //
		    // iPath.moveTo(item.x, item.y);
		    // iPath.quadraticCurveTo(item.x+nbr,item.y+nbr,item.x+20,item.y+20);
		    // iPath.moveTo(item.x+20,item.y+20);
		    // iPath.quadraticCurveTo(item.x+20-nbr,item.y,item.x,item.y);
        //
        // iPath.moveTo(item.x, item.y);
		    // iPath.quadraticCurveTo(item.x+nbr2,item.y+nbr2,item.x-20,item.y-20);
		    // iPath.moveTo(item.x-20,item.y-20);
		    // iPath.quadraticCurveTo(item.x-20-nbr2,item.y,item.x,item.y);
		    // //iPath.lineTo(next1.x, next1.y);
		    // iPath.closePath;

              //console.log(iPath);

              // } else if(j.type == "L") {
              //   iPath.lineTo(j.x, j.y);
              // } else if(j.type == "Q") {
              //   iPath.quadraticCurveTo(j.x1, j.y1, j.x, j.y);
              //   //iPath.fillStyle = "white";
              //
              //   //iPath.arc(j.x, j.y, 3, 0, 2 * Math.PI);
              // } else if(j.type == "Z") {
              //   iPath.closePath();
              //   iPath.lineTo(j.x, j.y);

          //});


	    // var ctx = createGlyphCanvas(i, 300);
	    //   var x = 100;
	    //   var y = 200;
	    //   var fontSize = 144;


            // iPath.fillStyle = "transparent";
            // iPath.stroke = "black";
            // iPath.strokeWidth = 2;
            // let depart = getRandomInt(-350, 1150);
            // let arrivee = getRandomInt(-350, 1150);
            // //iPath.moveTo(getRandomInt(-350, 1150), getRandomInt(-350, 1150));
            // iPath.bezierCurveTo(getRandomInt(-350, 1150), getRandomInt(-350, 1150), getRandomInt(-350, 1150), getRandomInt(-350, 1150), getRandomInt(-350, 1150), getRandomInt(-350, 1150));
            //


      //       let glyphe = new opentype.Glyph({
      //         name: nom,
      //         unicode: uni,
      //         advanceWidth: aw,
      //         path: iPath
      //       });
      //
      //       newGlyphs.push(glyphe);
      //       //console.log(newGlyphs);
      //       glyphe.draw(ctx, x, y, fontSize);
      //       //let contours = glyphe.getContours();
	    //        //console.log(contours);
      //   }
      //     //console.log(newGlyphs);
      //
      //     for(let glyphe of newGlyphs) {
	    // var ctx = createGlyphCanvas(glyphe, 150);
	    //   var x = 50;
	    //   var y = 120;
	    //   var fontSize = 72;
	    //   glyphe.draw(ctx, x, y, fontSize);
      //     }
      //
      //     const newfont = new opentype.Font({
      //       familyName: 'ElaineTest',
      //       styleName: 'Medium',
      //       unitsPerEm: 1000,
      //       ascender: 1105,
      //       descender: -343,
      //       glyphs: newGlyphs});
      //
      //       function fontDownload() {
      //         delete font.tables.gsub;
      //         newfont.download();
      //       }


        // let commandes = path.commands;
        //
        // function regularpolygon(ctx, x, y, radius, sides) {
        //   if (sides < 3) return;
        //   ctx.beginPath();
        //   var a = ((Math.PI * 2)/sides);
        //   ctx.translate(x,y);
        //   ctx.moveTo(radius,0);
        //   for (var i = 1; i < sides; i++) {
        //     ctx.lineTo(radius*Math.cos(a*i),radius*Math.sin(a*i));
        //   }
        //   ctx.closePath();
        // }
        //
        // function getRandomInt(min, max) {
        //   return min + Math.floor(Math.random() * (max - min + 1));
        // }

        //console.log(commandes);
        // for(let commande = 0; commande < commandes.length-1; commande++) {
        //   let long = commandes.length;
        //   if(commande.type == "Q") {
        //     let xx = commande.x + getRandomInt(-25, 25);
        //     let yy = commande.y + getRandomInt(-25, 25);
        //     //ctx.beginPath();
        //     //ctx.lineWidth = 0.75;
        //     //ctx.moveTo(x,y);
        //     //ctx.bezierCurveTo(x-getRandomInt(-25, 25), y-getRandomInt(-25, 25), x+getRandomInt(-15, 15), y+getRandomInt(-15, 15), x, y);
        //     //ctx.arc(x, y, 3, 0, 2 * Math.PI);
        //     //ctx.fillStyle = "white";
        //     //ctx.stroke();
        //     let a = {type: "M", x: xx, y: yy};
        //     let b = {type: "C", x1: getRandomInt(-25, 25), y1: getRandomInt(-25, 25), x2: getRandomInt(-25, 25), y2: getRandomInt(-25, 25), x: getRandomInt(-25, 25), y: getRandomInt(-25, 25)};
        //     let c = {type: 'Z'};
        //     commandes.push(a);
        //     commandes.push(b);
        //
        //   }
        //   console.log(commandes);
        //
        // }

        //delete font.tables.gsub;
        //var table = font.toTables();

        //font.download();
      //}
});

    </script>
  </body>
</html>
