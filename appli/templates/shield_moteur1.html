<!doctype html>
<html>
  <head>
    {% block head %}
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>{% block title %}Cityfab2.docs{% endblock %}</title>
    {% endblock %}
  </head>

  <body>
    <div id="entete">
      <a href="/">Cityfab2.docs</a>
    </div>
    <ul id="menu">
      <li><a href="/ressources_pedagogiques">Ressources pédagogiques</a></li>
      <li>Liens</li>
    </ul>

      <div class="print">
        <a href="/arduino_shield_moteur1.pdf">Version PDF</a>
      </div>
      <div class="previous">
        <p>Arduino</p>
      </div>

      <div class="main">
        <div id="onglets">
          <div id="onglet_circuit" onclick="circuitTop()">Circuit</div>
          <div id="onglet_code" onclick="codeTop()">Code Arduino</div>
        </div>
        <h3>Shield moteur + photorésistance</h3>
        <p class="circuitb">Pour commencer avec les shields, la toute première étape est de comprendre que les shields sont des ajouts à votre Arduino, mais ils ne constituent pas des cartes programmables seules. Vous devez donc brancher votre shield sur votre Arduino, venir le mettre dessus (les broches d'un shield viennent s'encastrer parfaitement dans celles de l'Arduino).</p>
        <div id="schemas">
          <img id="img_ard15" class="scheme" src="{{ url_for('static', filename='shield1.svg') }}" alt="">
        </div>

        <ol>
          <li>Une fois le shield installé sur l'Arduino, nous pouvons commencer le montage. Le shield moteur possède sa propre source d'alimentation indépendante de celle de l'Arduino, on peut donc brancher une pile de 9V dans les broches VIN ey GND du shield sans craindre de griller l'Arduino en-dessous.</li>
          <li>Si vous prenez le temps d'observer le shield, vous pouvez lire différentes informations sur ses broches&nbsp;: certaines sont marquées "Servo", d'autres "M1", "M2", etc. En effet le shield peut contrôler les trois grands types de moteurs&nbsp;: servo, courant continu et moteur pas-à-pas. Pour notre projet nous utiliserons deux moteurs à courant continu, branchés chacun sur l'une des entrées numérotée "M1" et "M2". Ces entrées comportent à la fois une alimentation et un GND, vous n'avez qu'à mettre un câble de l'une des broches et l'autre dans la seconde.</li>
          <li>Enfin connectez la photorésistance entre la broche 5V (qui est directement liée celle du 5V de l'Arduino) et la pin A0.</li>
        </ol>

        <div id="block_code">
          <p>Code Arduino</p>
          <pre class="code_full">

  <span class="type">#include</span> &lt;Wire.h&gt;
  <span class="type">#include</span> &lt;Adafruit_MotorShield.h&gt;

  <span class="type">Adafruit_MotorShield</span> AFMS =
  <span class="type">Adafruit_MotorShield()</span>;

  <span class="type">Adafruit_DCMotor</span> *myMotor1 =
  AFMS.<span class="fonction">getMotor</span>(1);
  <span class="type">Adafruit_DCMotor</span> *myMotor2 =
  AFMS.<span class="fonction">getMotor</span>(2);

  <span class="type">int</span> photo = A0;

  <span class="type">void</span> <span class="fonction">setup()</span> {
    <span class="fonction">pinMode</span>(bouton, INPUT);
    <span class="type">Serial</span>.begin(9600);

    AFMS.<span class="fonction">begin()</span>;

    myMotor1-><span class="fonction">setSpeed</span>(150);
    myMotor1-><span class="fonction">run</span>(FORWARD);
    myMotor1-><span class="fonction">run</span>(RELEASE);

    myMotor2-><span class="fonction">setSpeed</span>(150);
    myMotor2-><span class="fonction">run</span>(FORWARD);
    myMotor2-><span class="fonction">run</span>(RELEASE);
  }

  <span class="type">void</span> <span class="fonction">loop()</span> {
    <span class="type">int</span> speed = <span class="fonction">analogRead</span>(photo);

    <span class="type">Serial</span>.<span class="fonction">println</span>(speed);

    myMotor1-><span class="fonction">setSpeed</span>(speed);
    myMotor1-><span class="fonction">run</span>(FORWARD);

    myMotor2-><span class="fonction">setSpeed</span>(speed);
    myMotor2-><span class="fonction">run</span>(BACKWARD);
  }

        </pre>
      </div>

      <h4>LE CODE</h4>
      <pre>

  <span class="type">#include</span> &lt;Wire.h&gt;
  <span class="type">#include</span> &lt;Adafruit_MotorShield.h&gt;

  <span class="type">Adafruit_MotorShield</span> AFMS =
  <span class="type">Adafruit_MotorShield()</span>;

  <span class="type">Adafruit_DCMotor</span> *myMotor1 =
  AFMS.<span class="fonction">getMotor</span>(1);
  <span class="type">Adafruit_DCMotor</span> *myMotor2 =
  AFMS.<span class="fonction">getMotor</span>(2);

  <span class="type">int</span> photo = A0;
      </pre>
      <p>Ce modèle de shield moteur est fabriqué par Adafruit et requiert l'appel à la librairie <span class="code">Adafruit_MotorShield</span> en plus de la librairie <span class="code">Wire</span> (car le shield communique avec l'Arduino via le protocole I2C). Nous devons ensuite déclarer un objet <span class="code">Adafruit_MotorShield</span> que nous nommons <span class="code">AFMS</span> pour pouvoir communiquer avec le shield. La librairie <span class="code">Adafruit_MotorShield</span> inclut nativement les différents types de moteurs&nbsp;; étant donné que nous avons deux moteurs à courant continu, nous devons déclarer deux objets <span class="code">Adafruit_DCMotor</span> associés à la fonction <span class="code">AFMS.getMotor()</span>, dont l'argument est le port sur lequel est branché le moteur. Sur notre circuit ils sont respectivement sur les ports M1 et M2, d'où les arguments 1 et 2 ici présents. Puis nous initialisons la pin de la photorésistance sur l'A0.</p>
      <pre>

  <span class="type">void</span> <span class="fonction">setup()</span> {
    <span class="fonction">pinMode</span>(bouton, INPUT);
    <span class="type">Serial</span>.begin(9600);

    AFMS.<span class="fonction">begin()</span>;

    myMotor1-><span class="fonction">setSpeed</span>(150);
    myMotor1-><span class="fonction">run</span>(FORWARD);
    myMotor1-><span class="fonction">run</span>(RELEASE);

    myMotor2-><span class="fonction">setSpeed</span>(150);
    myMotor2-><span class="fonction">run</span>(FORWARD);
    myMotor2-><span class="fonction">run</span>(RELEASE);
  }
      </pre>
      <p>Dans le <span class="code">setup()</span> nous faisons démarrer le shield (<span class="code">AFMS.begin();</span>). Puis nous initialisons les moteurs en les faisant simplement tourner puis s'arrêter une première fois à la vitesse de 150.</p>
      <pre>

  <span class="type">void</span> <span class="fonction">loop()</span> {
    <span class="type">int</span> speed = <span class="fonction">analogRead</span>(photo);

    <span class="type">Serial</span>.<span class="fonction">println</span>(speed);

    myMotor1-><span class="fonction">setSpeed</span>(speed);
    myMotor1-><span class="fonction">run</span>(FORWARD);

    myMotor2-><span class="fonction">setSpeed</span>(speed);
    myMotor2-><span class="fonction">run</span>(BACKWARD);
  }
      </pre>
      <p>Pour le reste, nous utilisons la photorésistance comme régulateur de la vitesse des moteurs. En effet en lisant perpétuellement cette valeur et en la passant aux moteurs via la fonction <span class="code">setSpeed()</span>, nous indexons la vitesse des moteurs sur la luminosité perçue par le capteur. Nous différencions l'action des deux moteurs en faisant tourner le premier à l'endroit et le second à l'envers.</p>

    <script type="text/javascript" src="{{ url_for('static', filename='script.js') }}"></script>
  </body>
</html>
