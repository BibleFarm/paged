<!doctype html>
<html>
  <head>
    {% block head %}
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>{% block title %}Cityfab2.docs{% endblock %}</title>
    {% endblock %}
  </head>

  <body>
    <div id="entete">
      <a href="/">Cityfab2.docs</a>
    </div>
    <ul id="menu">
      <li><a href="/ressources_pedagogiques">Ressources pédagogiques</a></li>
      <li>Liens</li>

    </ul>

      <div class="print">
        <a href="/arduino_flora_gps.pdf">Version PDF</a>
      </div>
      <div class="previous">
        <p>Arduino</p>
      </div>

      <div class="main">
        <div id="onglets">
          <div id="onglet_circuit" onclick="circuitTop()">Circuit</div>
          <div id="onglet_code" onclick="codeTop()">Code Arduino</div>
        </div>
        <h3>Adafruit Flora + module GPS</h3>
        <p class="circuitb">Le fabricant Adafruit propose également un module GPS portable et cousable. Nous allons l'associer au Flora pour réaliser un projet dans lequel une bande de NeoPixels s'allume d'une façon particulière quand on se trouve à des coordonnées GPS que l'on va définir.</p>
        <div id="schemas">
          <img id="img_ard25" class="scheme" src="{{ url_for('static', filename='flora_gps.svg') }}" alt="">
        </div>


        <ol>
          <li>Le module GPS se monte de façon simple sur le Flora&nbsp;: connectez les ports 3.3V de chacun ensemble, de même pour les ports GND, branchez le port RX du Flora sur le TX du module GPS, et le TX du Flora sur le RX du GPS.</li>
          <li> Ensuite branchez 6 NeoPixels en bande à un autre port 3.3V et un autre GND du Flora, et au port 10 pour la ligne du milieu.</li>
        </ol>

      <div id="block_code">
        <p>Code Arduino</p>
        <pre class="code_full">

  <span class="type">#include</span> &lt;Adafruit_GPS.h&gt;
  <span class="type">#include</span> &lt;Adafruit_NeoPixel.h&gt;

  <span class="type">#define</span> GPSSerial Serial1
  <span class="type">Adafruit_GPS</span> GPS(&GPSSerial);

  <span class="type">#define</span> GPSECHO false
  <span class="type">#define</span> PIN 10

  <span class="type">Adafruit_NeoPixel</span> strip =
  <span class="type">Adafruit_NeoPixel</span>(6, PIN, NEO_GRB + NEO_KHZ800);

  <span class="type">uint32_t</span> timer = millis();

  <span class="type">float</span> latitude;
  <span class="type">float</span> longitude;

  <span class="type">void</span> <span class="fonction">setup()</span> {
    strip.<span class="fonction">begin()</span>;
    strip.<span class="fonction">setBrightness</span>(50);
    strip.<span class="fonction">show()</span>;

    <span class="type">Serial</span>.<span class="fonction">begin</span>(115200);

    GPS.<span class="fonction">begin</span>(9600);
    GPS.<span class="fonction">sendCommand</span>(PMTK_SET_NMEA_OUTPUT_RMCGGA);
    GPS.<span class="fonction">sendCommand</span>(PMTK_SET_NMEA_UPDATE_1HZ);
    GPS.<span class="fonction">sendCommand</span>(PGCMD_ANTENNA);

    <span class="fonction">delay</span>(1000);

    GPSSerial.<span class="fonction">println</span>(PMTK_Q_RELEASE);
  }

  <span class="type">void</span> <span class="fonction">loop()</span> {
    <span class="type">char</span> c = GPS.<span class="fonction">read()</span>;

    <span class="type">if</span>(GPSECHO)
      <span class="type">if</span>(c) <span class="type">Serial</span>.<span class="fonction">print(c)</span>;

    <span class="type">if</span>(GPS.<span class="fonction">newNMEAreceived()</span>) {
      <span class="type">if</span>(!GPS.<span class="fonction">parse</span>(GPS.<span class="fonction">lastNMEA()</span>))
        <span class="type">return</span>;
    }

    <span class="type">if</span>(timer > <span class="fonction">millis()</span>) timer = <span class="fonction">millis()</span>;

    <span class="type">if</span>(<span class="fonction">millis()</span> - timer > 2000) {
      timer = <span class="fonction">millis()</span>;
      <span class="type">if</span>(GPS.fix) {
        <span class="type">Serial</span>.<span class="fonction">println</span>("Location: ");
        <span class="type">Serial</span>.<span class="fonction">println</span>(GPS.latitude, 1);
        <span class="type">Serial</span>.<span class="fonction">println</span>(GPS.longitude, 1);
      }
      latitude = GPS.latitude;
      longitude = GPS.longitude;
      <span class="type">if</span>((latitude > 5052.2 && latitude < 5052.5)
      && (longitude > 424.8 && longitude < 425.1)){
        <span class="fonction">rainbowCycle</span>(20);
      } <span class="type">else</span> {
        <span class="fonction">colorWipe</span>(strip.Color(0, 0, 0));
      }
    }
  }

  <span class="type">void</span> <span class="fonction">colorWipe</span>(<span class="type">uint32_t</span> c) {
    <span class="type">for</span>(<span class="type">uint16_t</span> i=0; i&lt;strip.<span class="fonction">numPixels()</span>; i++) {
      strip.<span class="fonction">setPixelColor</span>(i, c);
      strip.<span class="fonction">show()</span>;
    }
  }

  <span class="type">void</span> <span class="fonction">rainbowCycle</span>(<span class="type">uint8_t</span> wait) {
    <span class="type">uint16_t</span> i, j;
    <span class="type">for</span>(j=0; j&lt;256; j++) {
      <span class="type">for</span>(i=0; i< strip.<span class="fonction">numPixels()</span>; i++) {
        strip.<span class="fonction">setPixelColor</span>(i, Wheel((
        (i*256 / strip.<span class="fonction">numPixels()</span>) + j) & 255));
      }
      strip.<span class="fonction">show()</span>;
      <span class="fonction">delay</span>(wait);
    }
  }

  <span class="type">uint32_t</span> Wheel(<span class="type">byte</span> WheelPos) {
    WheelPos = 255 - WheelPos;
    <span class="type">if</span>(WheelPos < 85) {
      <span class="type">return</span> strip.Color(255 - WheelPos * 3,
      0, WheelPos * 3);
    } <span class="type">else if</span>(WheelPos < 170) {
      WheelPos -= 85;
      <span class="type">return</span> strip.Color(0, WheelPos * 3,
      255 - WheelPos * 3);
    } <span class="type">else</span> {
      WheelPos -= 170;
      <span class="type">return</span> strip.Color(WheelPos * 3,
      255 - WheelPos * 3, 0);
    }
  }

      </pre>
    </div>

    <h4>LE CODE</h4>
    <pre>

  <span class="type">#include</span> &lt;Adafruit_GPS.h&gt;
  <span class="type">#include</span> &lt;Adafruit_NeoPixel.h&gt;

  <span class="type">#define</span> GPSSerial Serial1

  <span class="type">Adafruit_GPS</span> GPS(&GPSSerial);

  <span class="type">#define</span> GPSECHO false
  <span class="type">#define</span> PIN 10

  <span class="type">Adafruit_NeoPixel</span> strip =
  <span class="type">Adafruit_NeoPixel</span>(6, PIN,
  NEO_GRB + NEO_KHZ800);

  <span class="type">uint32_t</span> timer = millis();

  <span class="type">float</span> latitude;
  <span class="type">float</span> longitude;
    </pre>
    <p>On aura besoin pour ce projet des librairies <span class="code">Adafruit_GPS</span> et <span class="code">Adafruit_NeoPixel</span>. Le module GPS requiert qu'on initialise un port série pour lui seul, c'est pourquoi on crée la constante <span class="code">Serial1</span> et qu'on l'associe à l'objet <span class="code">Adafruit_GPS</span>. Ensuite on initialise la pin 10 et on la déclare dans l'objet <span class="code">Adafruit_NeoPixel</span>, composé de 6 NeoPixels rattachés à la pin 10 du Flora. La valeur contenue dans <span class="code">timer</span> nous servira de délai plus tard. Enfin on crée déjà les variables <span class="code">latitude</span> et <span class="code">longitude</span> qui stockeront ces données.</p>
    <pre>

  <span class="type">void</span> <span class="fonction">setup()</span> {
    strip.<span class="fonction">begin()</span>;
    strip.<span class="fonction">setBrightness</span>(50);
    strip.<span class="fonction">show()</span>;

    <span class="type">Serial</span>.<span class="fonction">begin</span>(115200);

    GPS.<span class="fonction">begin</span>(9600);

    GPS.<span class="fonction">sendCommand</span>(PMTK_SET_NMEA
    _OUTPUT_RMCGGA);
    GPS.<span class="fonction">sendCommand</span>(PMTK_SET_NMEA
    _UPDATE_1HZ);
    GPS.<span class="fonction">sendCommand</span>(PGCMD_ANTENNA);

    <span class="fonction">delay</span>(1000);

    GPSSerial.<span class="fonction">println</span>(PMTK_Q_RELEASE);
  }
    </pre>
    <p>Dans le <span class="code">setup()</span> on commence par démarrer et configurer la bande de NeoPixels. Puis on initialise un port série à 115200 bauds, celui-ci pour afficher les données et déboguer. Juste en-dessous c'est celui du GPS que nous initialisons, à 9600 bauds. Le reste de la fonction fait démarrer le module GPS et envoie des informations dans le moniteur série afin que nous puissions vérifier que tout est correct. La ligne <span class="code">GPS.sendCommand(PMTK_SET_NMEA _OUTPUT_RMCGGA);</span> envoie les données de base du GPS (NMEA) ainsi que les coordonnées repérées. La ligne <span class="code">GPS.sendCommand(PMTK_SET_NMEA _UPDATE_1HZ);</span> détermine la fréquence d'envoi des données (ici 1Hz). La ligne <span class="code">GPS.sendCommand(PGCMD_ANTENNA);</span> envoie des données sur l'état de l'antenne du module GPS. Enfin la ligne <span class="code">GPSSerial.println(PMTK_Q_RELEASE);</span> affiche dans le moniteur série le firmware utilisé par le module.</p>
    <pre>

  <span class="type">void</span> <span class="fonction">loop()</span> {
    <span class="type">char</span> c = GPS.<span class="fonction">read()</span>;

    <span class="type">if</span>(GPSECHO)
      <span class="type">if</span>(c) <span class="type">Serial</span>.<span class="fonction">print(c)</span>;

    <span class="type">if</span>(GPS.<span class="fonction">newNMEAreceived()</span>) {
      <span class="type">if</span>(!GPS.<span class="fonction">parse</span>(GPS.<span class="fonction">lastNMEA()</span>))
        <span class="type">return</span>;
    }

    <span class="type">if</span>(timer > <span class="fonction">millis()</span>) timer = <span class="fonction">millis()</span>;

    <span class="type">if</span>(<span class="fonction">millis()</span> - timer > 2000) {
      timer = <span class="fonction">millis()</span>;
      <span class="type">if</span>(GPS.fix) {
        <span class="type">Serial</span>.<span class="fonction">println</span>("Location: ");
        <span class="type">Serial</span>.<span class="fonction">println</span>(GPS.latitude, 1);
        <span class="type">Serial</span>.<span class="fonction">println</span>(GPS.longitude, 1);
      }
      latitude = GPS.latitude;
      longitude = GPS.longitude;
      <span class="type">if</span>((latitude > 5052.2
      && latitude < 5052.5)
      && (longitude > 424.8
      && longitude < 425.1)){
        <span class="fonction">rainbowCycle</span>(20);
      } <span class="type">else</span> {
        <span class="fonction">colorWipe</span>(strip.Color(0, 0, 0));
      }
    }
  }

    </pre>
    <p>Dans la <span class="code">loop()</span> on lit ce que dit le GPS. On réinitialise le <span class="code">timer</span> pour qu'il se remette à 0 toutes les 2000 millisecondes (2 secondes), et à cet intervalle nous récupérons les valeurs de latitude et longitude et les enregistrons dans leurs variables (nous affchons également ces valeurs dans le moniteur série dès lors que le GPS reconnaît sa position avec <span class="code">if (GPS.fix) {}</span>). Grâce à ces valeurs récupérées dans les variables <span class="code">latitude</span> et <span class="code">longitude</span>, nous pouvons faire opérer une boucle conditionnelle sur ces données. Les coordonnées GPS que nous comparons avec celles que le GPS envoie sont celles de Cityfab 2. Ce que nous voulons, c'est que si nous nous trouvons bien à une latitude et à une longitude correspondant à celles du fablab, une fonction impliquant les NeoPixels se déclenche. Si c'est le cas, la fonction <span class="code">rainbowCycle()</span> se lance, sinon les NeoPixels restent éteints.</p>
    <pre>

  <span class="type">void</span> <span class="fonction">colorWipe</span>(<span class="type">uint32_t</span> c) {
    <span class="type">for</span>(<span class="type">uint16_t</span> i=0;
    i&lt;strip.<span class="fonction">numPixels()</span>; i++) {
      strip.<span class="fonction">setPixelColor</span>(i, c);
      strip.<span class="fonction">show()</span>;
    }
  }

  <span class="type">void</span> <span class="fonction">rainbowCycle</span>(<span class="type">uint8_t</span> wait) {
    <span class="type">uint16_t</span> i, j;
    <span class="type">for</span>(j=0; j&lt;256; j++) {
      <span class="type">for</span>(i=0; i< strip.<span class="fonction">numPixels()</span>; i++) {
        strip.<span class="fonction">setPixelColor</span>(i,
        Wheel(((i*256 / strip.<span class="fonction">numPixels()</span>)
        + j) & 255));
      }
      strip.<span class="fonction">show()</span>;
      <span class="fonction">delay</span>(wait);
    }
  }

  <span class="type">uint32_t</span> Wheel(<span class="type">byte</span> WheelPos) {
    WheelPos = 255 - WheelPos;
    <span class="type">if</span>(WheelPos < 85) {
      <span class="type">return</span> strip.Color(255 - WheelPos * 3,
      0, WheelPos * 3);
    } <span class="type">else if</span>(WheelPos < 170) {
      WheelPos -= 85;
      <span class="type">return</span> strip.Color(0, WheelPos * 3,
      255 - WheelPos * 3);
    } <span class="type">else</span> {
      WheelPos -= 170;
      <span class="type">return</span> strip.Color(WheelPos * 3,
      255 - WheelPos * 3, 0);
    }
  }
    </pre>
    <p>Voici les fonctions qui interagissent avec la bande de NeoPixels. La première, <span class="code">colorWipe()</span> donne simplement la même couleur à chacun des NeoPixels de la bande. La deuxième, <span class="code">rainbowCycle()</span> fait apparaître sur chaque NeoPixel, avec un intervalle entre chacun de telle sorte que les couleurs apparaîssent en décalé, l'ensemble des couleurs de l'arc-en-ciel. La fonction <span class="code">Wheel()</span> quant à elle décompose le spectre coloré et convertit les valeurs de rouge, de vert et de bleu de chaque couleur du spectre en bytes que les NeoPixels comprennent.</p>

    </div>

    <script type="text/javascript" src="{{ url_for('static', filename='script.js') }}"></script>
  </body>
</html>
